Interrupt Vectors
    00000 940C 009F JMP	__text_start|__start
    0003C 940C 24D9 JMP	_uart1_rx_isr

Program Code (text area)
__text_start|__start:
    0009F EFCF      LDI	R28,0xFF
    000A0 E1D0      LDI	R29,0x10
    000A1 BFCD      OUT	0x3D,R28
    000A2 BFDE      OUT	0x3E,R29
    000A3 51CE      SUBI	R28,0x1E
    000A4 40D0      SBCI	R29,0
    000A5 EA0A      LDI	R16,0xAA
    000A6 8308      ST	Y,R16
    000A7 2400      CLR	R0
    000A8 EBE1      LDI	R30,0xB1
    000A9 E0F1      LDI	R31,1
    000AA E013      LDI	R17,3
    000AB 3BE5      CPI	R30,0xB5
    000AC 07F1      CPC	R31,R17
    000AD F011      BEQ	0x00B0
    000AE 9201      ST	Z+,R0
    000AF CFFB      RJMP	0x00AB
    000B0 8300      ST	Z,R16
    000B1 E8EC      LDI	R30,0x8C
    000B2 E0F0      LDI	R31,0
    000B3 E0A0      LDI	R26,0
    000B4 E0B1      LDI	R27,1
    000B5 E011      LDI	R17,1
    000B6 E000      LDI	R16,0
    000B7 BF0B      OUT	0x3B,R16
    000B8 33ED      CPI	R30,0x3D
    000B9 07F1      CPC	R31,R17
    000BA F021      BEQ	0x00BF
    000BB 95C8      LPM
    000BC 9631      ADIW	R30,1
    000BD 920D      ST	X+,R0
    000BE CFF9      RJMP	0x00B8
    000BF 940E 2259 CALL	_main
_exit:
    000C1 CFFF      RJMP	_exit
_disk_initialize:
  state                --> R20
  drv                  --> R10
    000C2 92AA      ST	-Y,R10
    000C3 934A      ST	-Y,R20
    000C4 2EA0      MOV	R10,R16
FILE: D:\LQD\工程仿真2012_7_5\software\MEGA128\FILERW\software_src\diskio.c
(0001) 
(0002) 
(0003) /*-----------------------------------------------------------------------*/
(0004) /* Low level disk I/O module skeleton for FatFs     (C)ChaN, 2007        */
(0005) /*-----------------------------------------------------------------------*/
(0006) /* This is a stub disk I/O module that acts as front end of the existing */
(0007) /* disk I/O modules and attach it to FatFs module with common interface. */
(0008) /*-----------------------------------------------------------------------*/
(0009) 
(0010) #include "diskio.h"
(0011) #include "sd.h"
(0012) 
(0013) 
(0014) /*-----------------------------------------------------------------------*/
(0015) /* Correspondence between physical drive number and physical drive.      */
(0016) /* Note that Tiny-FatFs supports only single drive and always            */
(0017)                                       
(0018) 
(0019) ////////////////////////////
(0020)    struct tm {
(0021)    	int tm_sec;   // 秒 seconds after the minute, 0 to 60
(0022)    	int tm_min;   // 分 minutes after the hour, 0 to 59
(0023) 	int tm_hour;  // 时 hours since midnight, 0 to 23*
(0024) 	int tm_mday;  // 日 day of the month, 1 to 31
(0025) 	int tm_mon;   // 月 months since January, 0 to 11
(0026) 	int tm_year;  // 年 years since 1900
(0027) 	int tm_wday;  // 星期 days since Sunday, 0 to 6
(0028) 	int tm_yday;  // 从元旦起的天数 days since January 1, 0 to 365
(0029)  	int tm_isdst; // 夏令时？？Daylight Savings Time flag
(0030)  	};
(0031) 
(0032) /*-----------------------------------------------------------------------*/
(0033) /* Inidialize a Drive                                                    */
(0034) 
(0035) DSTATUS disk_initialize ( 
(0036) BYTE drv				/* Physical drive nmuber (0..) */
(0037) )
(0038) {
(0039)     unsigned char state;
(0040) 
(0041)     if(drv)
    000C5 20AA      TST	R10
    000C6 F011      BEQ	0x00C9
(0042)     {
(0043)         return STA_NOINIT;  //仅支持磁盘0的操作
    000C7 E001      LDI	R16,1
    000C8 C00C      RJMP	0x00D5
(0044)     }
(0045) 
(0046)     state = SD_Init();
    000C9 940E 22EF CALL	_SD_Init
    000CB 2F40      MOV	R20,R16
(0047)     if(state == STA_NODISK)
    000CC 3002      CPI	R16,2
    000CD F411      BNE	0x00D0
(0048)     {
(0049)         return STA_NODISK;
    000CE E002      LDI	R16,2
    000CF C005      RJMP	0x00D5
(0050)     }
(0051)     else if(state != 0)
    000D0 2344      TST	R20
    000D1 F011      BEQ	0x00D4
(0052)     {
(0053)         return STA_NOINIT;  //其他错误：初始化失败
    000D2 E001      LDI	R16,1
    000D3 C001      RJMP	0x00D5
(0054)     }
(0055)     else
(0056)     {
(0057)         return 0;           //初始化成功
    000D4 2700      CLR	R16
    000D5 9149      LD	R20,Y+
    000D6 90A9      LD	R10,Y+
    000D7 9508      RET
(0058)     }
(0059) }
(0060) 
(0061) 
(0062) 
(0063) /*-----------------------------------------------------------------------*/
(0064) /* Return Disk Status                                                    */
(0065) 
(0066) DSTATUS disk_status (
(0067) 	BYTE drv		/* Physical drive nmuber (0..) */
(0068) )
(0069) {
(0070)     if(drv)
_disk_status:
  drv                  --> R16
    000D8 2300      TST	R16
    000D9 F011      BEQ	0x00DC
(0071)     {
(0072)         return STA_NOINIT;  //仅支持磁盘0操作
    000DA E001      LDI	R16,1
    000DB C001      RJMP	0x00DD
(0073)     }
(0074)     return 0;
    000DC 2700      CLR	R16
    000DD 9508      RET
_disk_read:
  res                  --> R10
  count                --> R20
  sector               --> Y,+10
  buff                 --> R12
  drv                  --> R14
    000DE 940E 277E CALL	push_xgset30FC
    000E0 0169      MOVW	R12,R18
    000E1 2EE0      MOV	R14,R16
    000E2 9722      SBIW	R28,2
    000E3 854E      LDD	R20,Y+14
(0075) }
(0076) 
(0077) 
(0078) 
(0079) /*-----------------------------------------------------------------------*/
(0080) /* Read Sector(s)                                                        */
(0081) 
(0082) DRESULT disk_read (
(0083) 	BYTE drv,		/* Physical drive nmuber (0..) */
(0084) 	BYTE *buff,		/* Data buffer to store read data */
(0085) 	DWORD sector,	/* Sector address (LBA) */
(0086) 	BYTE count		/* Number of sectors to read (1..255) */
(0087) )
(0088) {
(0089) 	unsigned char res=0;
    000E4 24AA      CLR	R10
(0090)     if (drv || !count)
    000E5 20EE      TST	R14
    000E6 F411      BNE	0x00E9
    000E7 2344      TST	R20
    000E8 F411      BNE	0x00EB
(0091)     {    
(0092)         return RES_PARERR;  //仅支持单磁盘操作，count不能等于0，否则返回参数错误
    000E9 E004      LDI	R16,4
    000EA C010      RJMP	0x00FB
(0093)     }
(0094) 
(0095)     if(count==1)            //1个sector的读操作      
    000EB 3041      CPI	R20,1
    000EC F449      BNE	0x00F6
(0096)     {                                                
(0097)         res = SD_Read_Sector(sector, buff);      
    000ED 82D9      STD	Y+1,R13
    000EE 82C8      ST	Y,R12
    000EF 850A      LDD	R16,Y+10
    000F0 851B      LDD	R17,Y+11
    000F1 852C      LDD	R18,Y+12
    000F2 853D      LDD	R19,Y+13
    000F3 940E 23C1 CALL	_SD_Read_Sector
    000F5 2EA0      MOV	R10,R16
(0098)     }                                                                                                 
(0099) 
(0100)     //处理返回值，将SD_driver.c的返回值转成ff.c的返回值
(0101)     if(res == 0x00)
    000F6 20AA      TST	R10
    000F7 F411      BNE	0x00FA
(0102)     {
(0103)         return RES_OK;
    000F8 2700      CLR	R16
    000F9 C001      RJMP	0x00FB
(0104)     }
(0105)     else
(0106)     {
(0107)         return RES_ERROR;
    000FA E001      LDI	R16,1
    000FB 9622      ADIW	R28,2
    000FC 940C 2768 JMP	pop_xgset30FC
_disk_write:
  count                --> R12
  sector               --> Y,+8
  buff                 --> R10
  drv                  --> R14
    000FE 940E 2780 CALL	push_xgset00FC
    00100 0159      MOVW	R10,R18
    00101 2EE0      MOV	R14,R16
    00102 9722      SBIW	R28,2
    00103 84CC      LDD	R12,Y+12
(0108)     }
(0109) }
(0110) 
(0111) 
(0112) 
(0113) /*-----------------------------------------------------------------------*/
(0114) /* Write Sector(s)                                                       */
(0115) 
(0116) #if _READONLY == 0
(0117) DRESULT disk_write (
(0118) 	BYTE drv,			/* Physical drive nmuber (0..) */
(0119) 	BYTE *buff,	        /* Data to be written */
(0120) 	DWORD sector,		/* Sector address (LBA) */
(0121) 	BYTE count			/* Number of sectors to write (1..255) */
(0122) )
(0123) {
(0124)     if (drv || !count)
    00104 20EE      TST	R14
    00105 F411      BNE	0x0108
    00106 20CC      TST	R12
    00107 F411      BNE	0x010A
(0125)     {    
(0126)         return RES_PARERR;  //仅支持单磁盘操作，count不能等于0，否则返回参数错误
    00108 E004      LDI	R16,4
    00109 C009      RJMP	0x0113
(0127)     }   
(0128)    // 读写操作
(0129)     SD_Write_Sector(sector,buff);
    0010A 82B9      STD	Y+1,R11
    0010B 82A8      ST	Y,R10
    0010C 8508      LDD	R16,Y+8
    0010D 8519      LDD	R17,Y+9
    0010E 852A      LDD	R18,Y+10
    0010F 853B      LDD	R19,Y+11
    00110 940E 233B CALL	_SD_Write_Sector
(0130) 	  
(0131)     return RES_OK;
    00112 2700      CLR	R16
    00113 9622      ADIW	R28,2
    00114 940C 2761 JMP	pop_xgset00FC
_disk_ioctl:
  buff                 --> Y,+4
  ctrl                 --> Y,+2
  drv                  --> Y,+0
    00116 940E 26A9 CALL	push_arg4
(0132) }
(0133) #endif /* _READONLY */
(0134) 
(0135) 
(0136) 
(0137) /*-----------------------------------------------------------------------*/
(0138) /* Miscellaneous Functions                                               */
(0139) DRESULT disk_ioctl (
(0140) 	BYTE drv,		/* Physical drive nmuber (0..) */
(0141) 	BYTE ctrl,		/* Control code */
(0142) 	void *buff		/* Buffer to send/receive control data */
(0143) )
(0144) {
(0145)  	drv=drv;
(0146) 	ctrl=ctrl;
(0147) 	buff=buff;
(0148) 	return 0;
    00118 2700      CLR	R16
    00119 9624      ADIW	R28,4
    0011A 9508      RET
(0149) }
(0150) DWORD get_fattime (void)
(0151) {
(0152) 
(0153)   return 1950466005;
_get_fattime:
    0011B ED05      LDI	R16,0xD5
    0011C EB1F      LDI	R17,0xBF
    0011D E421      LDI	R18,0x41
    0011E E734      LDI	R19,0x74
    0011F 9508      RET
ff.c:mem_cpy:
  s                    --> R12
  d                    --> R10
  cnt                  --> R20
  src                  --> R18
  dst                  --> R16
    00120 940E 27A9 CALL	push_xgset303C
    00122 814E      LDD	R20,Y+6
    00123 815F      LDD	R21,Y+7
FILE: D:\LQD\工程仿真2012_7_5\software\MEGA128\FILERW\software_src\ff.c
(0001) /*----------------------------------------------------------------------------/
(0002) /  FatFs - FAT file system module  R0.09                  (C)ChaN, 2011
(0003) /-----------------------------------------------------------------------------/
(0004) / FatFs module is a generic FAT file system module for small embedded systems.
(0005) / This is a free software that opened for education, research and commercial
(0006) / developments under license policy of following terms.
(0007) /
(0008) /  Copyright (C) 2011, ChaN, all right reserved.
(0009) /
(0010) / * The FatFs module is a free software and there is NO WARRANTY.
(0011) / * No restriction on use. You can use, modify and redistribute it for
(0012) /   personal, non-profit or commercial products UNDER YOUR RESPONSIBILITY.
(0013) / * Redistributions of source code must retain the above copyright notice.
(0014) /
(0015) /-----------------------------------------------------------------------------/
(0016) / Feb 26,'06 R0.00  Prototype.
(0017) /
(0018) / Apr 29,'06 R0.01  First stable version.
(0019) /
(0020) / Jun 01,'06 R0.02  Added FAT12 support.
(0021) /                   Removed unbuffered mode.
(0022) /                   Fixed a problem on small (<32M) partition.
(0023) / Jun 10,'06 R0.02a Added a configuration option (_FS_MINIMUM).
(0024) /
(0025) / Sep 22,'06 R0.03  Added f_rename().
(0026) /                   Changed option _FS_MINIMUM to _FS_MINIMIZE.
(0027) / Dec 11,'06 R0.03a Improved cluster scan algorithm to write files fast.
(0028) /                   Fixed f_mkdir() creates incorrect directory on FAT32.
(0029) /
(0030) / Feb 04,'07 R0.04  Supported multiple drive system.
(0031) /                   Changed some interfaces for multiple drive system.
(0032) /                   Changed f_mountdrv() to f_mount().
(0033) /                   Added f_mkfs().
(0034) / Apr 01,'07 R0.04a Supported multiple partitions on a physical drive.
(0035) /                   Added a capability of extending file size to f_lseek().
(0036) /                   Added minimization level 3.
(0037) /                   Fixed an endian sensitive code in f_mkfs().
(0038) / May 05,'07 R0.04b Added a configuration option _USE_NTFLAG.
(0039) /                   Added FSInfo support.
(0040) /                   Fixed DBCS name can result FR_INVALID_NAME.
(0041) /                   Fixed short seek (<= csize) collapses the file object.
(0042) /
(0043) / Aug 25,'07 R0.05  Changed arguments of f_read(), f_write() and f_mkfs().
(0044) /                   Fixed f_mkfs() on FAT32 creates incorrect FSInfo.
(0045) /                   Fixed f_mkdir() on FAT32 creates incorrect directory.
(0046) / Feb 03,'08 R0.05a Added f_truncate() and f_utime().
(0047) /                   Fixed off by one error at FAT sub-type determination.
(0048) /                   Fixed btr in f_read() can be mistruncated.
(0049) /                   Fixed cached sector is not flushed when create and close without write.
(0050) /
(0051) / Apr 01,'08 R0.06  Added fputc(), fputs(), fprintf() and fgets().
(0052) /                   Improved performance of f_lseek() on moving to the same or following cluster.
(0053) /
(0054) / Apr 01,'09 R0.07  Merged Tiny-FatFs as a configuration option. (_FS_TINY)
(0055) /                   Added long file name feature.
(0056) /                   Added multiple code page feature.
(0057) /                   Added re-entrancy for multitask operation.
(0058) /                   Added auto cluster size selection to f_mkfs().
(0059) /                   Added rewind option to f_readdir().
(0060) /                   Changed result code of critical errors.
(0061) /                   Renamed string functions to avoid name collision.
(0062) / Apr 14,'09 R0.07a Separated out OS dependent code on reentrant cfg.
(0063) /                   Added multiple sector size feature.
(0064) / Jun 21,'09 R0.07c Fixed f_unlink() can return FR_OK on error.
(0065) /                   Fixed wrong cache control in f_lseek().
(0066) /                   Added relative path feature.
(0067) /                   Added f_chdir() and f_chdrive().
(0068) /                   Added proper case conversion to extended char.
(0069) / Nov 03,'09 R0.07e Separated out configuration options from ff.h to ffconf.h.
(0070) /                   Fixed f_unlink() fails to remove a sub-dir on _FS_RPATH.
(0071) /                   Fixed name matching error on the 13 char boundary.
(0072) /                   Added a configuration option, _LFN_UNICODE.
(0073) /                   Changed f_readdir() to return the SFN with always upper case on non-LFN cfg.
(0074) /
(0075) / May 15,'10 R0.08  Added a memory configuration option. (_USE_LFN = 3)
(0076) /                   Added file lock feature. (_FS_SHARE)
(0077) /                   Added fast seek feature. (_USE_FASTSEEK)
(0078) /                   Changed some types on the API, XCHAR->TCHAR.
(0079) /                   Changed fname member in the FILINFO structure on Unicode cfg.
(0080) /                   String functions support UTF-8 encoding files on Unicode cfg.
(0081) / Aug 16,'10 R0.08a Added f_getcwd(). (_FS_RPATH = 2)
(0082) /                   Added sector erase feature. (_USE_ERASE)
(0083) /                   Moved file lock semaphore table from fs object to the bss.
(0084) /                   Fixed a wrong directory entry is created on non-LFN cfg when the given name contains ';'.
(0085) /                   Fixed f_mkfs() creates wrong FAT32 volume.
(0086) / Jan 15,'11 R0.08b Fast seek feature is also applied to f_read() and f_write().
(0087) /                   f_lseek() reports required table size on creating CLMP.
(0088) /                   Extended format syntax of f_printf function.
(0089) /                   Ignores duplicated directory separators in given path names.
(0090) /
(0091) / Sep 06,'11 R0.09  f_mkfs() supports multiple partition to finish the multiple partition feature.
(0092) /                   Added f_fdisk(). (_MULTI_PARTITION = 2)
(0093) /---------------------------------------------------------------------------*/
(0094) 
(0095) #include "ff.h"			/* FatFs configurations and declarations */
(0096) #include "diskio.h"		/* Declarations of low level disk I/O functions */
(0097) #include <string.h>
(0098) 
(0099) /*--------------------------------------------------------------------------
(0100) 
(0101)    Module Private Definitions
(0102) 
(0103) ---------------------------------------------------------------------------*/
(0104) 
(0105) #if _FATFS != 6502	/* Revision ID */
(0106) #error Wrong include file (ff.h).
(0107) #endif
(0108) 
(0109) 
(0110) /* Definitions on sector size */
(0111) #if _MAX_SS != 512 && _MAX_SS != 1024 && _MAX_SS != 2048 && _MAX_SS != 4096
(0112) #error Wrong sector size.
(0113) #endif
(0114) #if _MAX_SS != 512
(0115) #define	SS(fs)	((fs)->ssize)	/* Variable sector size */
(0116) #else
(0117) #define	SS(fs)	512U			/* Fixed sector size */
(0118) #endif
(0119) 
(0120) 
(0121) /* Reentrancy related */
(0122) #if _FS_REENTRANT
(0123) #if _USE_LFN == 1
(0124) #error Static LFN work area must not be used in re-entrant configuration.
(0125) #endif
(0126) #define	ENTER_FF(fs)		{ if (!lock_fs(fs)) return FR_TIMEOUT; }
(0127) #define	LEAVE_FF(fs, res)	{ unlock_fs(fs, res); return res; }
(0128) #else
(0129) #define	ENTER_FF(fs)
(0130) #define LEAVE_FF(fs, res)	return res
(0131) #endif
(0132) 
(0133) #define	ABORT(fs, res)		{ fp->flag |= FA__ERROR; LEAVE_FF(fs, res); }
(0134) 
(0135) 
(0136) /* File shareing feature */
(0137) #if _FS_SHARE
(0138) #if _FS_READONLY
(0139) #error _FS_SHARE must be 0 on read-only cfg.
(0140) #endif
(0141) typedef struct {
(0142) 	FATFS *fs;				/* File ID 1, volume (NULL:blank entry) */
(0143) 	DWORD clu;				/* File ID 2, directory */
(0144) 	WORD idx;				/* File ID 3, directory index */
(0145) 	WORD ctr;				/* File open counter, 0:none, 0x01..0xFF:read open count, 0x100:write mode */
(0146) } FILESEM;
(0147) #endif
(0148) 
(0149) 
(0150) /* Misc definitions */
(0151) #define LD_CLUST(dir)	(((DWORD)LD_WORD(dir+DIR_FstClusHI)<<16) | LD_WORD(dir+DIR_FstClusLO))
(0152) #define ST_CLUST(dir,cl) {ST_WORD(dir+DIR_FstClusLO, cl); ST_WORD(dir+DIR_FstClusHI, (DWORD)cl>>16);}
(0153) 
(0154) 
(0155) /* DBCS code ranges and SBCS extend char conversion table */
(0156) 
(0157) #if _CODE_PAGE == 932	/* Japanese Shift-JIS */
(0158) #define _DF1S	0x81	/* DBC 1st byte range 1 start */
(0159) #define _DF1E	0x9F	/* DBC 1st byte range 1 end */
(0160) #define _DF2S	0xE0	/* DBC 1st byte range 2 start */
(0161) #define _DF2E	0xFC	/* DBC 1st byte range 2 end */
(0162) #define _DS1S	0x40	/* DBC 2nd byte range 1 start */
(0163) #define _DS1E	0x7E	/* DBC 2nd byte range 1 end */
(0164) #define _DS2S	0x80	/* DBC 2nd byte range 2 start */
(0165) #define _DS2E	0xFC	/* DBC 2nd byte range 2 end */
(0166) 
(0167) #elif _CODE_PAGE == 936	/* Simplified Chinese GBK */
(0168) #define _DF1S	0x81
(0169) #define _DF1E	0xFE
(0170) #define _DS1S	0x40
(0171) #define _DS1E	0x7E
(0172) #define _DS2S	0x80
(0173) #define _DS2E	0xFE
(0174) 
(0175) #elif _CODE_PAGE == 949	/* Korean */
(0176) #define _DF1S	0x81
(0177) #define _DF1E	0xFE
(0178) #define _DS1S	0x41
(0179) #define _DS1E	0x5A
(0180) #define _DS2S	0x61
(0181) #define _DS2E	0x7A
(0182) #define _DS3S	0x81
(0183) #define _DS3E	0xFE
(0184) 
(0185) #elif _CODE_PAGE == 950	/* Traditional Chinese Big5 */
(0186) #define _DF1S	0x81
(0187) #define _DF1E	0xFE
(0188) #define _DS1S	0x40
(0189) #define _DS1E	0x7E
(0190) #define _DS2S	0xA1
(0191) #define _DS2E	0xFE
(0192) 
(0193) #elif _CODE_PAGE == 437	/* U.S. (OEM) */
(0194) #define _DF1S	0
(0195) #define _EXCVT {0x80,0x9A,0x90,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x49,0x49,0x49,0x8E,0x8F,0x90,0x92,0x92,0x4F,0x99,0x4F,0x55,0x55,0x59,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
(0196) 				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0197) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0198) 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
(0199) 
(0200) #elif _CODE_PAGE == 720	/* Arabic (OEM) */
(0201) #define _DF1S	0
(0202) #define _EXCVT {0x80,0x81,0x45,0x41,0x84,0x41,0x86,0x43,0x45,0x45,0x45,0x49,0x49,0x8D,0x8E,0x8F,0x90,0x92,0x92,0x93,0x94,0x95,0x49,0x49,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
(0203) 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0204) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0205) 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
(0206) 
(0207) #elif _CODE_PAGE == 737	/* Greek (OEM) */
(0208) #define _DF1S	0
(0209) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x92,0x92,0x93,0x94,0x95,0x96,0x97,0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87, \
(0210) 				0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0xAA,0x92,0x93,0x94,0x95,0x96,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0211) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0212) 				0x97,0xEA,0xEB,0xEC,0xE4,0xED,0xEE,0xE7,0xE8,0xF1,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
(0213) 
(0214) #elif _CODE_PAGE == 775	/* Baltic (OEM) */
(0215) #define _DF1S	0
(0216) #define _EXCVT {0x80,0x9A,0x91,0xA0,0x8E,0x95,0x8F,0x80,0xAD,0xED,0x8A,0x8A,0xA1,0x8D,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0x95,0x96,0x97,0x97,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
(0217) 				0xA0,0xA1,0xE0,0xA3,0xA3,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0218) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xB5,0xB6,0xB7,0xB8,0xBD,0xBE,0xC6,0xC7,0xA5,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0219) 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE3,0xE8,0xE8,0xEA,0xEA,0xEE,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
(0220) 
(0221) #elif _CODE_PAGE == 850	/* Multilingual Latin 1 (OEM) */
(0222) #define _DF1S	0
(0223) #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0xDE,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x59,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
(0224) 				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0225) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0226) 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE7,0xE9,0xEA,0xEB,0xED,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
(0227) 
(0228) #elif _CODE_PAGE == 852	/* Latin 2 (OEM) */
(0229) #define _DF1S	0
(0230) #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xDE,0x8F,0x80,0x9D,0xD3,0x8A,0x8A,0xD7,0x8D,0x8E,0x8F,0x90,0x91,0x91,0xE2,0x99,0x95,0x95,0x97,0x97,0x99,0x9A,0x9B,0x9B,0x9D,0x9E,0x9F, \
(0231) 				0xB5,0xD6,0xE0,0xE9,0xA4,0xA4,0xA6,0xA6,0xA8,0xA8,0xAA,0x8D,0xAC,0xB8,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBD,0xBF, \
(0232) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC6,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD2,0xD3,0xD2,0xD5,0xD6,0xD7,0xB7,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0233) 				0xE0,0xE1,0xE2,0xE3,0xE3,0xD5,0xE6,0xE6,0xE8,0xE9,0xE8,0xEB,0xED,0xED,0xDD,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xEB,0xFC,0xFC,0xFE,0xFF}
(0234) 
(0235) #elif _CODE_PAGE == 855	/* Cyrillic (OEM) */
(0236) #define _DF1S	0
(0237) #define _EXCVT {0x81,0x81,0x83,0x83,0x85,0x85,0x87,0x87,0x89,0x89,0x8B,0x8B,0x8D,0x8D,0x8F,0x8F,0x91,0x91,0x93,0x93,0x95,0x95,0x97,0x97,0x99,0x99,0x9B,0x9B,0x9D,0x9D,0x9F,0x9F, \
(0238) 				0xA1,0xA1,0xA3,0xA3,0xA5,0xA5,0xA7,0xA7,0xA9,0xA9,0xAB,0xAB,0xAD,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB6,0xB6,0xB8,0xB8,0xB9,0xBA,0xBB,0xBC,0xBE,0xBE,0xBF, \
(0239) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD3,0xD3,0xD5,0xD5,0xD7,0xD7,0xDD,0xD9,0xDA,0xDB,0xDC,0xDD,0xE0,0xDF, \
(0240) 				0xE0,0xE2,0xE2,0xE4,0xE4,0xE6,0xE6,0xE8,0xE8,0xEA,0xEA,0xEC,0xEC,0xEE,0xEE,0xEF,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF8,0xFA,0xFA,0xFC,0xFC,0xFD,0xFE,0xFF}
(0241) 
(0242) #elif _CODE_PAGE == 857	/* Turkish (OEM) */
(0243) #define _DF1S	0
(0244) #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0x98,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x98,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9E, \
(0245) 				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA6,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0246) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0247) 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xDE,0x59,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
(0248) 
(0249) #elif _CODE_PAGE == 858	/* Multilingual Latin 1 + Euro (OEM) */
(0250) #define _DF1S	0
(0251) #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0xDE,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x59,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
(0252) 				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0253) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0254) 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE7,0xE9,0xEA,0xEB,0xED,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
(0255) 
(0256) #elif _CODE_PAGE == 862	/* Hebrew (OEM) */
(0257) #define _DF1S	0
(0258) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
(0259) 				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0260) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0261) 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
(0262) 
(0263) #elif _CODE_PAGE == 866	/* Russian (OEM) */
(0264) #define _DF1S	0
(0265) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
(0266) 				0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0267) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0268) 				0x90,0x91,0x92,0x93,0x9d,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F,0xF0,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
(0269) 
(0270) #elif _CODE_PAGE == 874	/* Thai (OEM, Windows) */
(0271) #define _DF1S	0
(0272) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
(0273) 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0274) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0275) 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
(0276) 
(0277) #elif _CODE_PAGE == 1250 /* Central Europe (Windows) */
(0278) #define _DF1S	0
(0279) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x8D,0x8E,0x8F, \
(0280) 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xA3,0xB4,0xB5,0xB6,0xB7,0xB8,0xA5,0xAA,0xBB,0xBC,0xBD,0xBC,0xAF, \
(0281) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0282) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xFF}
(0283) 
(0284) #elif _CODE_PAGE == 1251 /* Cyrillic (Windows) */
(0285) #define _DF1S	0
(0286) #define _EXCVT {0x80,0x81,0x82,0x82,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x80,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x8D,0x8E,0x8F, \
(0287) 				0xA0,0xA2,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB2,0xA5,0xB5,0xB6,0xB7,0xA8,0xB9,0xAA,0xBB,0xA3,0xBD,0xBD,0xAF, \
(0288) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0289) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF}
(0290) 
(0291) #elif _CODE_PAGE == 1252 /* Latin 1 (Windows) */
(0292) #define _DF1S	0
(0293) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0xAd,0x9B,0x8C,0x9D,0xAE,0x9F, \
(0294) 				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0295) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0296) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0x9F}
(0297) 
(0298) #elif _CODE_PAGE == 1253 /* Greek (Windows) */
(0299) #define _DF1S	0
(0300) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
(0301) 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0302) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xA2,0xB8,0xB9,0xBA, \
(0303) 				0xE0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xF2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xFB,0xBC,0xFD,0xBF,0xFF}
(0304) 
(0305) #elif _CODE_PAGE == 1254 /* Turkish (Windows) */
(0306) #define _DF1S	0
(0307) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x9D,0x9E,0x9F, \
(0308) 				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0309) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0310) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0x9F}
(0311) 
(0312) #elif _CODE_PAGE == 1255 /* Hebrew (Windows) */
(0313) #define _DF1S	0
(0314) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
(0315) 				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0316) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0317) 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
(0318) 
(0319) #elif _CODE_PAGE == 1256 /* Arabic (Windows) */
(0320) #define _DF1S	0
(0321) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x8C,0x9D,0x9E,0x9F, \
(0322) 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0323) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0324) 				0x41,0xE1,0x41,0xE3,0xE4,0xE5,0xE6,0x43,0x45,0x45,0x45,0x45,0xEC,0xED,0x49,0x49,0xF0,0xF1,0xF2,0xF3,0x4F,0xF5,0xF6,0xF7,0xF8,0x55,0xFA,0x55,0x55,0xFD,0xFE,0xFF}
(0325) 
(0326) #elif _CODE_PAGE == 1257 /* Baltic (Windows) */
(0327) #define _DF1S	0
(0328) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
(0329) 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xA8,0xB9,0xAA,0xBB,0xBC,0xBD,0xBE,0xAF, \
(0330) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0331) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xFF}
(0332) 
(0333) #elif _CODE_PAGE == 1258 /* Vietnam (OEM, Windows) */
(0334) #define _DF1S	0
(0335) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0xAC,0x9D,0x9E,0x9F, \
(0336) 				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0337) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0338) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xEC,0xCD,0xCE,0xCF,0xD0,0xD1,0xF2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xFE,0x9F}
(0339) 
(0340) #elif _CODE_PAGE == 1	/* ASCII (for only non-LFN cfg) */
(0341) #if _USE_LFN
(0342) #error Cannot use LFN feature without valid code page.
(0343) #endif
(0344) #define _DF1S	0
(0345) 
(0346) #else
(0347) #error Unknown code page
(0348) 
(0349) #endif
(0350) 
(0351) 
(0352) /* Character code support macros */
(0353) #define IsUpper(c)	(((c)>='A')&&((c)<='Z'))
(0354) #define IsLower(c)	(((c)>='a')&&((c)<='z'))
(0355) #define IsDigit(c)	(((c)>='0')&&((c)<='9'))
(0356) 
(0357) #if _DF1S		/* Code page is DBCS */
(0358) 
(0359) #ifdef _DF2S	/* Two 1st byte areas */
(0360) #define IsDBCS1(c)	(((BYTE)(c) >= _DF1S && (BYTE)(c) <= _DF1E) || ((BYTE)(c) >= _DF2S && (BYTE)(c) <= _DF2E))
(0361) #else			/* One 1st byte area */
(0362) #define IsDBCS1(c)	((BYTE)(c) >= _DF1S && (BYTE)(c) <= _DF1E)
(0363) #endif
(0364) 
(0365) #ifdef _DS3S	/* Three 2nd byte areas */
(0366) #define IsDBCS2(c)	(((BYTE)(c) >= _DS1S && (BYTE)(c) <= _DS1E) || ((BYTE)(c) >= _DS2S && (BYTE)(c) <= _DS2E) || ((BYTE)(c) >= _DS3S && (BYTE)(c) <= _DS3E))
(0367) #else			/* Two 2nd byte areas */
(0368) #define IsDBCS2(c)	(((BYTE)(c) >= _DS1S && (BYTE)(c) <= _DS1E) || ((BYTE)(c) >= _DS2S && (BYTE)(c) <= _DS2E))
(0369) #endif
(0370) 
(0371) #else			/* Code page is SBCS */
(0372) 
(0373) #define IsDBCS1(c)	0
(0374) #define IsDBCS2(c)	0
(0375) 
(0376) #endif /* _DF1S */
(0377) 
(0378) 
(0379) /* Name status flags */
(0380) #define NS			11		/* Index of name status byte in fn[] */
(0381) #define NS_LOSS		0x01	/* Out of 8.3 format */
(0382) #define NS_LFN		0x02	/* Force to create LFN entry */
(0383) #define NS_LAST		0x04	/* Last segment */
(0384) #define NS_BODY		0x08	/* Lower case flag (body) */
(0385) #define NS_EXT		0x10	/* Lower case flag (ext) */
(0386) #define NS_DOT		0x20	/* Dot entry */
(0387) 
(0388) 
(0389) /* FAT sub-type boundaries */
(0390) /* Note that the FAT spec by Microsoft says 4085 but Windows works with 4087! */
(0391) #define MIN_FAT16	4086	/* Minimum number of clusters for FAT16 */
(0392) #define	MIN_FAT32	65526	/* Minimum number of clusters for FAT32 */
(0393) 
(0394) 
(0395) /* FatFs refers the members in the FAT structures as byte array instead of
(0396) / structure member because the structure is not binary compatible between
(0397) / different platforms */
(0398) 
(0399) #define BS_jmpBoot			0	/* Jump instruction (3) */
(0400) #define BS_OEMName			3	/* OEM name (8) */
(0401) #define BPB_BytsPerSec		11	/* Sector size [byte] (2) */
(0402) #define BPB_SecPerClus		13	/* Cluster size [sector] (1) */
(0403) #define BPB_RsvdSecCnt		14	/* Size of reserved area [sector] (2) */
(0404) #define BPB_NumFATs			16	/* Number of FAT copies (1) */
(0405) #define BPB_RootEntCnt		17	/* Number of root dir entries for FAT12/16 (2) */
(0406) #define BPB_TotSec16		19	/* Volume size [sector] (2) */
(0407) #define BPB_Media			21	/* Media descriptor (1) */
(0408) #define BPB_FATSz16			22	/* FAT size [sector] (2) */
(0409) #define BPB_SecPerTrk		24	/* Track size [sector] (2) */
(0410) #define BPB_NumHeads		26	/* Number of heads (2) */
(0411) #define BPB_HiddSec			28	/* Number of special hidden sectors (4) */
(0412) #define BPB_TotSec32		32	/* Volume size [sector] (4) */
(0413) #define BS_DrvNum			36	/* Physical drive number (2) */
(0414) #define BS_BootSig			38	/* Extended boot signature (1) */
(0415) #define BS_VolID			39	/* Volume serial number (4) */
(0416) #define BS_VolLab			43	/* Volume label (8) */
(0417) #define BS_FilSysType		54	/* File system type (1) */
(0418) #define BPB_FATSz32			36	/* FAT size [sector] (4) */
(0419) #define BPB_ExtFlags		40	/* Extended flags (2) */
(0420) #define BPB_FSVer			42	/* File system version (2) */
(0421) #define BPB_RootClus		44	/* Root dir first cluster (4) */
(0422) #define BPB_FSInfo			48	/* Offset of FSInfo sector (2) */
(0423) #define BPB_BkBootSec		50	/* Offset of backup boot sectot (2) */
(0424) #define BS_DrvNum32			64	/* Physical drive number (2) */
(0425) #define BS_BootSig32		66	/* Extended boot signature (1) */
(0426) #define BS_VolID32			67	/* Volume serial number (4) */
(0427) #define BS_VolLab32			71	/* Volume label (8) */
(0428) #define BS_FilSysType32		82	/* File system type (1) */
(0429) #define	FSI_LeadSig			0	/* FSI: Leading signature (4) */
(0430) #define	FSI_StrucSig		484	/* FSI: Structure signature (4) */
(0431) #define	FSI_Free_Count		488	/* FSI: Number of free clusters (4) */
(0432) #define	FSI_Nxt_Free		492	/* FSI: Last allocated cluster (4) */
(0433) #define MBR_Table			446	/* MBR: Partition table offset (2) */
(0434) #define	SZ_PTE				16	/* MBR: Size of a partition table entry */
(0435) #define BS_55AA				510	/* Boot sector signature (2) */
(0436) 
(0437) #define	DIR_Name			0	/* Short file name (11) */
(0438) #define	DIR_Attr			11	/* Attribute (1) */
(0439) #define	DIR_NTres			12	/* NT flag (1) */
(0440) #define	DIR_CrtTime			14	/* Created time (2) */
(0441) #define	DIR_CrtDate			16	/* Created date (2) */
(0442) #define	DIR_FstClusHI		20	/* Higher 16-bit of first cluster (2) */
(0443) #define	DIR_WrtTime			22	/* Modified time (2) */
(0444) #define	DIR_WrtDate			24	/* Modified date (2) */
(0445) #define	DIR_FstClusLO		26	/* Lower 16-bit of first cluster (2) */
(0446) #define	DIR_FileSize		28	/* File size (4) */
(0447) #define	LDIR_Ord			0	/* LFN entry order and LLE flag (1) */
(0448) #define	LDIR_Attr			11	/* LFN attribute (1) */
(0449) #define	LDIR_Type			12	/* LFN type (1) */
(0450) #define	LDIR_Chksum			13	/* Sum of corresponding SFN entry */
(0451) #define	LDIR_FstClusLO		26	/* Filled by zero (0) */
(0452) #define	SZ_DIR				32		/* Size of a directory entry */
(0453) #define	LLE					0x40	/* Last long entry flag in LDIR_Ord */
(0454) #define	DDE					0xE5	/* Deleted directory enrty mark in DIR_Name[0] */
(0455) #define	NDDE				0x05	/* Replacement of a character collides with DDE */
(0456) 
(0457) 
(0458) /*------------------------------------------------------------*/
(0459) /* Module private work area                                   */
(0460) /*------------------------------------------------------------*/
(0461) /* Note that uninitialized variables with static duration are
(0462) /  zeroed/nulled at start-up. If not, the compiler or start-up
(0463) /  routine is out of ANSI-C standard.
(0464) */
(0465) 
(0466) #if _VOLUMES
(0467) static
(0468) FATFS *FatFs[_VOLUMES];	/* Pointer to the file system objects (logical drives) */
(0469) #else
(0470) #error Number of volumes must not be 0.
(0471) #endif
(0472) 
(0473) static
(0474) WORD Fsid;				/* File system mount ID */
(0475) 
(0476) #if _FS_RPATH
(0477) static
(0478) BYTE CurrVol;			/* Current drive */
(0479) #endif
(0480) 
(0481) #if _FS_SHARE
(0482) static
(0483) FILESEM	Files[_FS_SHARE];	/* File lock semaphores */
(0484) #endif
(0485) 
(0486) #if _USE_LFN == 0			/* No LFN feature */
(0487) #define	DEF_NAMEBUF			BYTE sfn[12]
(0488) #define INIT_BUF(dobj)		(dobj).fn = sfn
(0489) #define	FREE_BUF()
(0490) 
(0491) #elif _USE_LFN == 1			/* LFN feature with static working buffer */
(0492) static WCHAR LfnBuf[_MAX_LFN+1];
(0493) #define	DEF_NAMEBUF			BYTE sfn[12]
(0494) #define INIT_BUF(dobj)		{ (dobj).fn = sfn; (dobj).lfn = LfnBuf; }
(0495) #define	FREE_BUF()
(0496) 
(0497) #elif _USE_LFN == 2 		/* LFN feature with dynamic working buffer on the stack */
(0498) #define	DEF_NAMEBUF			BYTE sfn[12]; WCHAR lbuf[_MAX_LFN+1]
(0499) #define INIT_BUF(dobj)		{ (dobj).fn = sfn; (dobj).lfn = lbuf; }
(0500) #define	FREE_BUF()
(0501) 
(0502) #elif _USE_LFN == 3 		/* LFN feature with dynamic working buffer on the heap */
(0503) #define	DEF_NAMEBUF			BYTE sfn[12]; WCHAR *lfn
(0504) #define INIT_BUF(dobj)		{ lfn = ff_memalloc((_MAX_LFN + 1) * 2); \
(0505) 							  if (!lfn) LEAVE_FF((dobj).fs, FR_NOT_ENOUGH_CORE); \
(0506) 							  (dobj).lfn = lfn;	(dobj).fn = sfn; }
(0507) #define	FREE_BUF()			ff_memfree(lfn)
(0508) 
(0509) #else
(0510) #error Wrong LFN configuration.
(0511) #endif
(0512) 
(0513) 
(0514) 
(0515) 
(0516) /*--------------------------------------------------------------------------
(0517) 
(0518)    Module Private Functions
(0519) 
(0520) ---------------------------------------------------------------------------*/
(0521) 
(0522) 
(0523) /*-----------------------------------------------------------------------*/
(0524) /* String functions                                                      */
(0525) /*-----------------------------------------------------------------------*/
(0526) 
(0527) /* Copy memory to memory */
(0528) static
(0529) void mem_cpy (void* dst, const void* src, UINT cnt) {
(0530) 	BYTE *d = (BYTE*)dst;
    00124 0158      MOVW	R10,R16
(0531) 	const BYTE *s = (const BYTE*)src;
    00125 0169      MOVW	R12,R18
    00126 C006      RJMP	0x012D
(0532) 
(0533) #if _WORD_ACCESS == 1
(0534) 	while (cnt >= sizeof(int)) {
(0535) 		*(int*)d = *(int*)s;
(0536) 		d += sizeof(int); s += sizeof(int);
(0537) 		cnt -= sizeof(int);
(0538) 	}
(0539) #endif
(0540) 	while (cnt--)
(0541) 		*d++ = *s++;
    00127 01F6      MOVW	R30,R12
    00128 01D5      MOVW	R26,R10
    00129 9001      LD	R0,Z+
    0012A 016F      MOVW	R12,R30
    0012B 920D      ST	X+,R0
    0012C 015D      MOVW	R10,R26
    0012D 011A      MOVW	R2,R20
    0012E 5041      SUBI	R20,1
    0012F 4050      SBCI	R21,0
    00130 2022      TST	R2
    00131 F7A9      BNE	0x0127
    00132 2033      TST	R3
    00133 F799      BNE	0x0127
    00134 940C 27B0 JMP	pop_xgset303C
ff.c:mem_set:
  d                    --> R10
  cnt                  --> R20
  val                  --> R18
  dst                  --> R16
    00136 940E 2787 CALL	push_xgset300C
    00138 814C      LDD	R20,Y+4
    00139 815D      LDD	R21,Y+5
(0542) }
(0543) 
(0544) /* Fill memory */
(0545) static
(0546) void mem_set (void* dst, int val, UINT cnt) {
(0547) 	BYTE *d = (BYTE*)dst;
    0013A 0158      MOVW	R10,R16
    0013B C003      RJMP	0x013F
(0548) 
(0549) 	while (cnt--)
(0550) 		*d++ = (BYTE)val;
    0013C 01F5      MOVW	R30,R10
    0013D 9321      ST	Z+,R18
    0013E 015F      MOVW	R10,R30
    0013F 011A      MOVW	R2,R20
    00140 5041      SUBI	R20,1
    00141 4050      SBCI	R21,0
    00142 2022      TST	R2
    00143 F7C1      BNE	0x013C
    00144 2033      TST	R3
    00145 F7B1      BNE	0x013C
    00146 940C 278C JMP	pop_xgset300C
ff.c:mem_cmp:
  s                    --> R14
  d                    --> R12
  r                    --> R10
  cnt                  --> R20
  src                  --> R18
  dst                  --> R16
    00148 940E 277E CALL	push_xgset30FC
    0014A 8548      LDD	R20,Y+8
    0014B 8559      LDD	R21,Y+9
(0551) }
(0552) 
(0553) /* Compare memory to memory */
(0554) static
(0555) int mem_cmp (const void* dst, const void* src, UINT cnt) {
(0556) 	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
    0014C 0168      MOVW	R12,R16
    0014D 0179      MOVW	R14,R18
(0557) 	int r = 0;
    0014E 24AA      CLR	R10
    0014F 24BB      CLR	R11
(0558) 
(0559) 	while (cnt-- && (r = *d++ - *s++) == 0) ;
    00150 011A      MOVW	R2,R20
    00151 5041      SUBI	R20,1
    00152 4050      SBCI	R21,0
    00153 2022      TST	R2
    00154 F411      BNE	0x0157
    00155 2033      TST	R3
    00156 F079      BEQ	0x0166
    00157 01F7      MOVW	R30,R14
    00158 9021      LD	R2,Z+
    00159 017F      MOVW	R14,R30
    0015A 2433      CLR	R3
    0015B 01F6      MOVW	R30,R12
    0015C 9041      LD	R4,Z+
    0015D 016F      MOVW	R12,R30
    0015E 2455      CLR	R5
    0015F 1842      SUB	R4,R2
    00160 0853      SBC	R5,R3
    00161 0152      MOVW	R10,R4
    00162 20AA      TST	R10
    00163 F411      BNE	0x0166
    00164 20BB      TST	R11
    00165 F351      BEQ	0x0150
(0560) 	return r;
    00166 0185      MOVW	R16,R10
    00167 940C 2768 JMP	pop_xgset30FC
(0561) }
(0562) 
(0563) /* Check if chr is contained in the string */
(0564) static
(0565) int chk_chr (const char* str, int chr) {
ff.c:chk_chr:
  chr                  --> R18
  str                  --> R16
    00169 C002      RJMP	0x016C
(0566) 	while (*str && *str != chr) str++;
    0016A 5F0F      SUBI	R16,0xFF
    0016B 4F1F      SBCI	R17,0xFF
    0016C 01F8      MOVW	R30,R16
    0016D 8020      LD	R2,Z
    0016E 2433      CLR	R3
    0016F 2022      TST	R2
    00170 F021      BEQ	0x0175
    00171 2433      CLR	R3
    00172 1622      CP	R2,R18
    00173 0633      CPC	R3,R19
    00174 F7A9      BNE	0x016A
(0567) 	return *str;
    00175 01F8      MOVW	R30,R16
    00176 8100      LD	R16,Z
    00177 2711      CLR	R17
    00178 9508      RET
ff.c:move_window:
  nf                   --> R10
  wsect                --> Y,+5
  sector               --> Y,+13
  fs                   --> R20
    00179 933A      ST	-Y,R19
    0017A 932A      ST	-Y,R18
    0017B 940E 2787 CALL	push_xgset300C
    0017D 01A8      MOVW	R20,R16
    0017E 9729      SBIW	R28,0x9
(0568) }
(0569) 
(0570) 
(0571) 
(0572) /*-----------------------------------------------------------------------*/
(0573) /* Request/Release grant to access the volume                            */
(0574) /*-----------------------------------------------------------------------*/
(0575) #if _FS_REENTRANT
(0576) 
(0577) static
(0578) int lock_fs (
(0579) 	FATFS *fs		/* File system object */
(0580) )
(0581) {
(0582) 	return ff_req_grant(fs->sobj);
(0583) }
(0584) 
(0585) 
(0586) static
(0587) void unlock_fs (
(0588) 	FATFS *fs,		/* File system object */
(0589) 	FRESULT res		/* Result code to be returned */
(0590) )
(0591) {
(0592) 	if (res != FR_NOT_ENABLED &&
(0593) 		res != FR_INVALID_DRIVE &&
(0594) 		res != FR_INVALID_OBJECT &&
(0595) 		res != FR_TIMEOUT) {
(0596) 		ff_rel_grant(fs->sobj);
(0597) 	}
(0598) }
(0599) #endif
(0600) 
(0601) 
(0602) 
(0603) /*-----------------------------------------------------------------------*/
(0604) /* File shareing control functions                                       */
(0605) /*-----------------------------------------------------------------------*/
(0606) #if _FS_SHARE
(0607) 
(0608) static
(0609) FRESULT chk_lock (	/* Check if the file can be accessed */
(0610) 	DIR* dj,		/* Directory object pointing the file to be checked */
(0611) 	int acc			/* Desired access (0:Read, 1:Write, 2:Delete/Rename) */
(0612) )
(0613) {
(0614) 	UINT i, be;
(0615) 
(0616) 	/* Search file semaphore table */
(0617) 	for (i = be = 0; i < _FS_SHARE; i++) {
(0618) 		if (Files[i].fs) {	/* Existing entry */
(0619) 			if (Files[i].fs == dj->fs &&	 	/* Check if the file matched with an open file */
(0620) 				Files[i].clu == dj->sclust &&
(0621) 				Files[i].idx == dj->index) break;
(0622) 		} else {			/* Blank entry */
(0623) 			be++;
(0624) 		}
(0625) 	}
(0626) 	if (i == _FS_SHARE)	/* The file is not opened */
(0627) 		return (be || acc == 2) ? FR_OK : FR_TOO_MANY_OPEN_FILES;	/* Is there a blank entry for new file? */
(0628) 
(0629) 	/* The file has been opened. Reject any open against writing file and all write mode open */
(0630) 	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
(0631) }
(0632) 
(0633) 
(0634) static
(0635) int enq_lock (void)	/* Check if an entry is available for a new file */
(0636) {
(0637) 	UINT i;
(0638) 
(0639) 	for (i = 0; i < _FS_SHARE && Files[i].fs; i++) ;
(0640) 	return (i == _FS_SHARE) ? 0 : 1;
(0641) }
(0642) 
(0643) 
(0644) static
(0645) UINT inc_lock (	/* Increment file open counter and returns its index (0:int error) */
(0646) 	DIR* dj,	/* Directory object pointing the file to register or increment */
(0647) 	int acc		/* Desired access mode (0:Read, !0:Write) */
(0648) )
(0649) {
(0650) 	UINT i;
(0651) 
(0652) 
(0653) 	for (i = 0; i < _FS_SHARE; i++) {	/* Find the file */
(0654) 		if (Files[i].fs == dj->fs &&
(0655) 			Files[i].clu == dj->sclust &&
(0656) 			Files[i].idx == dj->index) break;
(0657) 	}
(0658) 
(0659) 	if (i == _FS_SHARE) {				/* Not opened. Register it as new. */
(0660) 		for (i = 0; i < _FS_SHARE && Files[i].fs; i++) ;
(0661) 		if (i == _FS_SHARE) return 0;	/* No space to register (int err) */
(0662) 		Files[i].fs = dj->fs;
(0663) 		Files[i].clu = dj->sclust;
(0664) 		Files[i].idx = dj->index;
(0665) 		Files[i].ctr = 0;
(0666) 	}
(0667) 
(0668) 	if (acc && Files[i].ctr) return 0;	/* Access violation (int err) */
(0669) 
(0670) 	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */
(0671) 
(0672) 	return i + 1;
(0673) }
(0674) 
(0675) 
(0676) static
(0677) FRESULT dec_lock (	/* Decrement file open counter */
(0678) 	UINT i			/* Semaphore index */
(0679) )
(0680) {
(0681) 	WORD n;
(0682) 	FRESULT res;
(0683) 
(0684) 
(0685) 	if (--i < _FS_SHARE) {
(0686) 		n = Files[i].ctr;
(0687) 		if (n == 0x100) n = 0;
(0688) 		if (n) n--;
(0689) 		Files[i].ctr = n;
(0690) 		if (!n) Files[i].fs = 0;
(0691) 		res = FR_OK;
(0692) 	} else {
(0693) 		res = FR_INT_ERR;
(0694) 	}
(0695) 	return res;
(0696) }
(0697) 
(0698) 
(0699) static
(0700) void clear_lock (	/* Clear lock entries of the volume */
(0701) 	FATFS *fs
(0702) )
(0703) {
(0704) 	UINT i;
(0705) 
(0706) 	for (i = 0; i < _FS_SHARE; i++) {
(0707) 		if (Files[i].fs == fs) Files[i].fs = 0;
(0708) 	}
(0709) }
(0710) #endif
(0711) 
(0712) 
(0713) 
(0714) /*-----------------------------------------------------------------------*/
(0715) /* Change window offset                                                  */
(0716) /*-----------------------------------------------------------------------*/
(0717) 
(0718) static
(0719) FRESULT move_window (
(0720) 	FATFS *fs,		/* File system object */
(0721) 	DWORD sector	/* Sector number to make appearance in the fs->win[] */
(0722) )					/* Move to zero only writes back dirty window */
(0723) {
(0724) 	DWORD wsect;
(0725) 
(0726) 
(0727) 	wsect = fs->winsect;
    0017F 01FA      MOVW	R30,R20
    00180 96BA      ADIW	R30,0x2A
    00181 8020      LD	R2,Z
    00182 8031      LDD	R3,Z+1
    00183 8042      LDD	R4,Z+2
    00184 8053      LDD	R5,Z+3
    00185 822D      STD	Y+5,R2
    00186 823E      STD	Y+6,R3
    00187 824F      STD	Y+7,R4
    00188 8658      STD	Y+8,R5
(0728) 	if (wsect != sector) {	/* Changed current window */
    00189 842D      LDD	R2,Y+13
    0018A 843E      LDD	R3,Y+14
    0018B 844F      LDD	R4,Y+15
    0018C 8858      LDD	R5,Y+16
    0018D 806D      LDD	R6,Y+5
    0018E 807E      LDD	R7,Y+6
    0018F 808F      LDD	R8,Y+7
    00190 8498      LDD	R9,Y+8
    00191 1462      CP	R6,R2
    00192 0473      CPC	R7,R3
    00193 0484      CPC	R8,R4
    00194 0495      CPC	R9,R5
    00195 F409      BNE	0x0197
    00196 C07E      RJMP	0x0215
(0729) #if !_FS_READONLY
(0730) 		if (fs->wflag) {	/* Write back dirty window if needed */
    00197 01FA      MOVW	R30,R20
    00198 8024      LDD	R2,Z+4
    00199 2022      TST	R2
    0019A F409      BNE	0x019C
    0019B C055      RJMP	0x01F1
(0731) 			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
    0019C E081      LDI	R24,1
    0019D 838C      STD	Y+4,R24
    0019E 0113      MOVW	R2,R6
    0019F 0124      MOVW	R4,R8
    001A0 8228      ST	Y,R2
    001A1 8239      STD	Y+1,R3
    001A2 824A      STD	Y+2,R4
    001A3 825B      STD	Y+3,R5
    001A4 019A      MOVW	R18,R20
    001A5 5D22      SUBI	R18,0xD2
    001A6 4F3F      SBCI	R19,0xFF
    001A7 8101      LDD	R16,Z+1
    001A8 940E 00FE CALL	_disk_write
    001AA 2300      TST	R16
    001AB F011      BEQ	0x01AE
(0732) 				return FR_DISK_ERR;
    001AC E001      LDI	R16,1
    001AD C068      RJMP	0x0216
(0733) 			fs->wflag = 0;
    001AE 2422      CLR	R2
    001AF 01FA      MOVW	R30,R20
    001B0 8224      STD	Z+4,R2
(0734) 			if (wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area */
    001B1 8C22      LDD	R2,Z+26
    001B2 8C33      LDD	R3,Z+27
    001B3 8C44      LDD	R4,Z+28
    001B4 8C55      LDD	R5,Z+29
    001B5 967E      ADIW	R30,0x1E
    001B6 8060      LD	R6,Z
    001B7 8071      LDD	R7,Z+1
    001B8 8082      LDD	R8,Z+2
    001B9 8093      LDD	R9,Z+3
    001BA 0C62      ADD	R6,R2
    001BB 1C73      ADC	R7,R3
    001BC 1C84      ADC	R8,R4
    001BD 1C95      ADC	R9,R5
    001BE 802D      LDD	R2,Y+5
    001BF 803E      LDD	R3,Y+6
    001C0 804F      LDD	R4,Y+7
    001C1 8458      LDD	R5,Y+8
    001C2 1426      CP	R2,R6
    001C3 0437      CPC	R3,R7
    001C4 0448      CPC	R4,R8
    001C5 0459      CPC	R5,R9
    001C6 F550      BCC	0x01F1
(0735) 				BYTE nf;
(0736) 				for (nf = fs->n_fats; nf > 1; nf--) {	/* Reflect the change to all FAT copies */
    001C7 01FA      MOVW	R30,R20
    001C8 80A3      LDD	R10,Z+3
    001C9 C024      RJMP	0x01EE
(0737) 					wsect += fs->fsize;
    001CA 01FA      MOVW	R30,R20
    001CB 967A      ADIW	R30,0x1A
    001CC 8020      LD	R2,Z
    001CD 8031      LDD	R3,Z+1
    001CE 8042      LDD	R4,Z+2
    001CF 8053      LDD	R5,Z+3
    001D0 806D      LDD	R6,Y+5
    001D1 807E      LDD	R7,Y+6
    001D2 808F      LDD	R8,Y+7
    001D3 8498      LDD	R9,Y+8
    001D4 0C62      ADD	R6,R2
    001D5 1C73      ADC	R7,R3
    001D6 1C84      ADC	R8,R4
    001D7 1C95      ADC	R9,R5
    001D8 826D      STD	Y+5,R6
    001D9 827E      STD	Y+6,R7
    001DA 828F      STD	Y+7,R8
    001DB 8698      STD	Y+8,R9
(0738) 					disk_write(fs->drv, fs->win, wsect, 1);
    001DC E081      LDI	R24,1
    001DD 838C      STD	Y+4,R24
    001DE 802D      LDD	R2,Y+5
    001DF 803E      LDD	R3,Y+6
    001E0 804F      LDD	R4,Y+7
    001E1 8458      LDD	R5,Y+8
    001E2 8228      ST	Y,R2
    001E3 8239      STD	Y+1,R3
    001E4 824A      STD	Y+2,R4
    001E5 825B      STD	Y+3,R5
    001E6 019A      MOVW	R18,R20
    001E7 5D22      SUBI	R18,0xD2
    001E8 4F3F      SBCI	R19,0xFF
    001E9 01FA      MOVW	R30,R20
    001EA 8101      LDD	R16,Z+1
    001EB 940E 00FE CALL	_disk_write
    001ED 94AA      DEC	R10
    001EE E081      LDI	R24,1
    001EF 158A      CP	R24,R10
    001F0 F2C8      BCS	0x01CA
(0739) 				}
(0740) 			}
(0741) 		}
(0742) #endif
(0743) 		if (sector) {
    001F1 842D      LDD	R2,Y+13
    001F2 843E      LDD	R3,Y+14
    001F3 844F      LDD	R4,Y+15
    001F4 8858      LDD	R5,Y+16
    001F5 9488      BCLR	0
    001F6 2022      TST	R2
    001F7 0432      CPC	R3,R2
    001F8 0442      CPC	R4,R2
    001F9 0452      CPC	R5,R2
    001FA F0D1      BEQ	0x0215
(0744) 			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
    001FB E081      LDI	R24,1
    001FC 838C      STD	Y+4,R24
    001FD 8228      ST	Y,R2
    001FE 8239      STD	Y+1,R3
    001FF 824A      STD	Y+2,R4
    00200 825B      STD	Y+3,R5
    00201 019A      MOVW	R18,R20
    00202 5D22      SUBI	R18,0xD2
    00203 4F3F      SBCI	R19,0xFF
    00204 01FA      MOVW	R30,R20
    00205 8101      LDD	R16,Z+1
    00206 940E 00DE CALL	_disk_read
    00208 2300      TST	R16
    00209 F011      BEQ	0x020C
(0745) 				return FR_DISK_ERR;
    0020A E001      LDI	R16,1
    0020B C00A      RJMP	0x0216
(0746) 			fs->winsect = sector;
    0020C 842D      LDD	R2,Y+13
    0020D 843E      LDD	R3,Y+14
    0020E 844F      LDD	R4,Y+15
    0020F 8858      LDD	R5,Y+16
    00210 01FA      MOVW	R30,R20
    00211 A622      STD	Z+42,R2
    00212 A633      STD	Z+43,R3
    00213 A644      STD	Z+44,R4
    00214 A655      STD	Z+45,R5
(0747) 		}
(0748) 	}
(0749) 
(0750) 	return FR_OK;
    00215 2700      CLR	R16
    00216 9629      ADIW	R28,0x9
    00217 940E 278C CALL	pop_xgset300C
    00219 9622      ADIW	R28,2
    0021A 9508      RET
ff.c:sync:
  res                  --> R20
  fs                   --> R22
    0021B 940E 2791 CALL	push_xgsetF000
    0021D 01B8      MOVW	R22,R16
    0021E 9725      SBIW	R28,5
(0751) }
(0752) 
(0753) 
(0754) 
(0755) 
(0756) /*-----------------------------------------------------------------------*/
(0757) /* Clean-up cached data                                                  */
(0758) /*-----------------------------------------------------------------------*/
(0759) #if !_FS_READONLY
(0760) static
(0761) FRESULT sync (	/* FR_OK: successful, FR_DISK_ERR: failed */
(0762) 	FATFS *fs	/* File system object */
(0763) )
(0764) {
(0765) 	FRESULT res;
(0766) 
(0767) 
(0768) 	res = move_window(fs, 0);
    0021F E080      LDI	R24,0
    00220 E090      LDI	R25,0
    00221 E0A0      LDI	R26,0
    00222 E0B0      LDI	R27,0
    00223 83A8      ST	Y,R26
    00224 83B9      STD	Y+1,R27
    00225 019C      MOVW	R18,R24
    00226 018B      MOVW	R16,R22
    00227 DF51      RCALL	ff.c:move_window
    00228 2F40      MOV	R20,R16
(0769) 	if (res == FR_OK) {
    00229 2300      TST	R16
    0022A F009      BEQ	0x022C
    0022B C0C0      RJMP	0x02EC
(0770) 		/* Update FSInfo sector if needed */
(0771) 		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
    0022C 01FB      MOVW	R30,R22
    0022D 8180      LD	R24,Z
    0022E 3083      CPI	R24,3
    0022F F009      BEQ	0x0231
    00230 C0AC      RJMP	0x02DD
    00231 8025      LDD	R2,Z+5
    00232 2022      TST	R2
    00233 F409      BNE	0x0235
    00234 C0A8      RJMP	0x02DD
(0772) 			fs->winsect = 0;
    00235 96BA      ADIW	R30,0x2A
    00236 E080      LDI	R24,0
    00237 8380      ST	Z,R24
    00238 8381      STD	Z+1,R24
    00239 8382      STD	Z+2,R24
    0023A 8383      STD	Z+3,R24
(0773) 			/* Create FSInfo structure */
(0774) 			mem_set(fs->win, 0, 512);
    0023B E080      LDI	R24,0
    0023C E092      LDI	R25,2
    0023D 8399      STD	Y+1,R25
    0023E 8388      ST	Y,R24
    0023F 2722      CLR	R18
    00240 2733      CLR	R19
    00241 018B      MOVW	R16,R22
    00242 5D02      SUBI	R16,0xD2
    00243 4F1F      SBCI	R17,0xFF
    00244 DEF1      RCALL	ff.c:mem_set
(0775) 			ST_WORD(fs->win+BS_55AA, 0xAA55);
    00245 E585      LDI	R24,0x55
    00246 01FB      MOVW	R30,R22
    00247 5DE4      SUBI	R30,0xD4
    00248 4FFD      SBCI	R31,0xFD
    00249 8380      ST	Z,R24
    0024A 52EC      SUBI	R30,0x2C
    0024B 40F2      SBCI	R31,2
    0024C EA8A      LDI	R24,0xAA
    0024D 5DE3      SUBI	R30,0xD3
    0024E 4FFD      SBCI	R31,0xFD
    0024F 8380      ST	Z,R24
    00250 52ED      SUBI	R30,0x2D
    00251 40F2      SBCI	R31,2
(0776) 			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
    00252 E582      LDI	R24,0x52
    00253 A786      STD	Z+46,R24
    00254 A787      STD	Z+47,R24
    00255 E681      LDI	R24,0x61
    00256 AB80      STD	Z+48,R24
    00257 E481      LDI	R24,0x41
    00258 AB81      STD	Z+49,R24
(0777) 			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
    00259 E782      LDI	R24,0x72
    0025A 5EEE      SUBI	R30,0xEE
    0025B 4FFD      SBCI	R31,0xFD
    0025C 8380      ST	Z,R24
    0025D 51E2      SUBI	R30,0x12
    0025E 40F2      SBCI	R31,2
    0025F 5EED      SUBI	R30,0xED
    00260 4FFD      SBCI	R31,0xFD
    00261 8380      ST	Z,R24
    00262 51E3      SUBI	R30,0x13
    00263 40F2      SBCI	R31,2
    00264 E481      LDI	R24,0x41
    00265 5EEC      SUBI	R30,0xEC
    00266 4FFD      SBCI	R31,0xFD
    00267 8380      ST	Z,R24
    00268 51E4      SUBI	R30,0x14
    00269 40F2      SBCI	R31,2
    0026A E681      LDI	R24,0x61
    0026B 5EEB      SUBI	R30,0xEB
    0026C 4FFD      SBCI	R31,0xFD
    0026D 8380      ST	Z,R24
    0026E 51E5      SUBI	R30,0x15
    0026F 40F2      SBCI	R31,2
(0778) 			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
    00270 8426      LDD	R2,Z+14
    00271 8437      LDD	R3,Z+15
    00272 8840      LDD	R4,Z+16
    00273 8851      LDD	R5,Z+17
    00274 5EEA      SUBI	R30,0xEA
    00275 4FFD      SBCI	R31,0xFD
    00276 8220      ST	Z,R2
    00277 51E6      SUBI	R30,0x16
    00278 40F2      SBCI	R31,2
    00279 8426      LDD	R2,Z+14
    0027A 8437      LDD	R3,Z+15
    0027B 2C23      MOV	R2,R3
    0027C 2433      CLR	R3
    0027D 5EE9      SUBI	R30,0xE9
    0027E 4FFD      SBCI	R31,0xFD
    0027F 8220      ST	Z,R2
    00280 51E7      SUBI	R30,0x17
    00281 40F2      SBCI	R31,2
    00282 8426      LDD	R2,Z+14
    00283 8437      LDD	R3,Z+15
    00284 8840      LDD	R4,Z+16
    00285 8851      LDD	R5,Z+17
    00286 0112      MOVW	R2,R4
    00287 2444      CLR	R4
    00288 2455      CLR	R5
    00289 5EE8      SUBI	R30,0xE8
    0028A 4FFD      SBCI	R31,0xFD
    0028B 8220      ST	Z,R2
    0028C 51E8      SUBI	R30,0x18
    0028D 40F2      SBCI	R31,2
    0028E E188      LDI	R24,0x18
    0028F E090      LDI	R25,0
    00290 8506      LDD	R16,Z+14
    00291 8517      LDD	R17,Z+15
    00292 8920      LDD	R18,Z+16
    00293 8931      LDD	R19,Z+17
    00294 938A      ST	-Y,R24
    00295 940E 280A CALL	lsr32
    00297 01FB      MOVW	R30,R22
    00298 5EE7      SUBI	R30,0xE7
    00299 4FFD      SBCI	R31,0xFD
    0029A 8300      ST	Z,R16
    0029B 51E9      SUBI	R30,0x19
    0029C 40F2      SBCI	R31,2
(0779) 			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
    0029D 8422      LDD	R2,Z+10
    0029E 8433      LDD	R3,Z+11
    0029F 8444      LDD	R4,Z+12
    002A0 8455      LDD	R5,Z+13
    002A1 5EE6      SUBI	R30,0xE6
    002A2 4FFD      SBCI	R31,0xFD
    002A3 8220      ST	Z,R2
    002A4 51EA      SUBI	R30,0x1A
    002A5 40F2      SBCI	R31,2
    002A6 8422      LDD	R2,Z+10
    002A7 8433      LDD	R3,Z+11
    002A8 2C23      MOV	R2,R3
    002A9 2433      CLR	R3
    002AA 5EE5      SUBI	R30,0xE5
    002AB 4FFD      SBCI	R31,0xFD
    002AC 8220      ST	Z,R2
    002AD 51EB      SUBI	R30,0x1B
    002AE 40F2      SBCI	R31,2
    002AF 8422      LDD	R2,Z+10
    002B0 8433      LDD	R3,Z+11
    002B1 8444      LDD	R4,Z+12
    002B2 8455      LDD	R5,Z+13
    002B3 0112      MOVW	R2,R4
    002B4 2444      CLR	R4
    002B5 2455      CLR	R5
    002B6 5EE4      SUBI	R30,0xE4
    002B7 4FFD      SBCI	R31,0xFD
    002B8 8220      ST	Z,R2
    002B9 51EC      SUBI	R30,0x1C
    002BA 40F2      SBCI	R31,2
    002BB E188      LDI	R24,0x18
    002BC E090      LDI	R25,0
    002BD 8502      LDD	R16,Z+10
    002BE 8513      LDD	R17,Z+11
    002BF 8524      LDD	R18,Z+12
    002C0 8535      LDD	R19,Z+13
    002C1 938A      ST	-Y,R24
    002C2 940E 280A CALL	lsr32
    002C4 01FB      MOVW	R30,R22
    002C5 5EE3      SUBI	R30,0xE3
    002C6 4FFD      SBCI	R31,0xFD
    002C7 8300      ST	Z,R16
    002C8 51ED      SUBI	R30,0x1D
    002C9 40F2      SBCI	R31,2
(0780) 			/* Write it into the FSInfo sector */
(0781) 			disk_write(fs->drv, fs->win, fs->fsi_sector, 1);
    002CA E081      LDI	R24,1
    002CB 838C      STD	Y+4,R24
    002CC 8822      LDD	R2,Z+18
    002CD 8833      LDD	R3,Z+19
    002CE 8844      LDD	R4,Z+20
    002CF 8855      LDD	R5,Z+21
    002D0 8228      ST	Y,R2
    002D1 8239      STD	Y+1,R3
    002D2 824A      STD	Y+2,R4
    002D3 825B      STD	Y+3,R5
    002D4 019F      MOVW	R18,R30
    002D5 5D22      SUBI	R18,0xD2
    002D6 4F3F      SBCI	R19,0xFF
    002D7 8101      LDD	R16,Z+1
    002D8 940E 00FE CALL	_disk_write
(0782) 			fs->fsi_flag = 0;
    002DA 2422      CLR	R2
    002DB 01FB      MOVW	R30,R22
    002DC 8225      STD	Z+5,R2
(0783) 		}
(0784) 		/* Make sure that no pending write process in the physical drive */
(0785) 		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK)
    002DD 2422      CLR	R2
    002DE 2433      CLR	R3
    002DF 8239      STD	Y+1,R3
    002E0 8228      ST	Y,R2
    002E1 2722      CLR	R18
    002E2 2733      CLR	R19
    002E3 01FB      MOVW	R30,R22
    002E4 8101      LDD	R16,Z+1
    002E5 2711      CLR	R17
    002E6 940E 0116 CALL	_disk_ioctl
    002E8 3000      CPI	R16,0
    002E9 0701      CPC	R16,R17
    002EA F009      BEQ	0x02EC
(0786) 			res = FR_DISK_ERR;
    002EB E041      LDI	R20,1
(0787) 	}
(0788) 
(0789) 	return res;
    002EC 2F04      MOV	R16,R20
    002ED 9625      ADIW	R28,5
    002EE 940C 2796 JMP	pop_xgsetF000
_clust2sect:
  clst                 --> Y,+6
  fs                   --> R10
    002F0 933A      ST	-Y,R19
    002F1 932A      ST	-Y,R18
    002F2 940E 279B CALL	push_xgsetF00C
    002F4 0158      MOVW	R10,R16
(0790) }
(0791) #endif
(0792) 
(0793) 
(0794) 
(0795) 
(0796) /*-----------------------------------------------------------------------*/
(0797) /* Get sector# from cluster#                                             */
(0798) /*-----------------------------------------------------------------------*/
(0799) 
(0800) 
(0801) DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
(0802) 	FATFS *fs,		/* File system object */
(0803) 	DWORD clst		/* Cluster# to be converted */
(0804) )
(0805) {
(0806) 	clst -= 2;
    002F5 E042      LDI	R20,2
    002F6 E050      LDI	R21,0
    002F7 E060      LDI	R22,0
    002F8 E070      LDI	R23,0
    002F9 802E      LDD	R2,Y+6
    002FA 803F      LDD	R3,Y+7
    002FB 8448      LDD	R4,Y+8
    002FC 8459      LDD	R5,Y+9
    002FD 1A24      SUB	R2,R20
    002FE 0A35      SBC	R3,R21
    002FF 0A46      SBC	R4,R22
    00300 0A57      SBC	R5,R23
    00301 822E      STD	Y+6,R2
    00302 823F      STD	Y+7,R3
    00303 8648      STD	Y+8,R4
    00304 8659      STD	Y+9,R5
(0807) 	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
    00305 E042      LDI	R20,2
    00306 E050      LDI	R21,0
    00307 E060      LDI	R22,0
    00308 E070      LDI	R23,0
    00309 01F5      MOVW	R30,R10
    0030A 9676      ADIW	R30,0x16
    0030B 8020      LD	R2,Z
    0030C 8031      LDD	R3,Z+1
    0030D 8042      LDD	R4,Z+2
    0030E 8053      LDD	R5,Z+3
    0030F 1A24      SUB	R2,R20
    00310 0A35      SBC	R3,R21
    00311 0A46      SBC	R4,R22
    00312 0A57      SBC	R5,R23
    00313 806E      LDD	R6,Y+6
    00314 807F      LDD	R7,Y+7
    00315 8488      LDD	R8,Y+8
    00316 8499      LDD	R9,Y+9
    00317 1462      CP	R6,R2
    00318 0473      CPC	R7,R3
    00319 0484      CPC	R8,R4
    0031A 0495      CPC	R9,R5
    0031B F028      BCS	0x0321
    0031C E000      LDI	R16,0
    0031D E010      LDI	R17,0
    0031E E020      LDI	R18,0
    0031F E030      LDI	R19,0
    00320 C01D      RJMP	0x033E
(0808) 	return clst * fs->csize + fs->database;
    00321 01F5      MOVW	R30,R10
    00322 9632      ADIW	R30,2
    00323 8020      LD	R2,Z
    00324 2433      CLR	R3
    00325 2444      CLR	R4
    00326 2455      CLR	R5
    00327 810E      LDD	R16,Y+6
    00328 811F      LDD	R17,Y+7
    00329 8528      LDD	R18,Y+8
    0032A 8539      LDD	R19,Y+9
    0032B 925A      ST	-Y,R5
    0032C 924A      ST	-Y,R4
    0032D 923A      ST	-Y,R3
    0032E 922A      ST	-Y,R2
    0032F 940E 2728 CALL	empy32s|empy32u
    00331 0118      MOVW	R2,R16
    00332 0129      MOVW	R4,R18
    00333 01F5      MOVW	R30,R10
    00334 A066      LDD	R6,Z+38
    00335 A077      LDD	R7,Z+39
    00336 A480      LDD	R8,Z+40
    00337 A491      LDD	R9,Z+41
    00338 0C26      ADD	R2,R6
    00339 1C37      ADC	R3,R7
    0033A 1C48      ADC	R4,R8
    0033B 1C59      ADC	R5,R9
    0033C 0181      MOVW	R16,R2
    0033D 0192      MOVW	R18,R4
    0033E 940E 27A2 CALL	pop_xgsetF00C
    00340 9622      ADIW	R28,2
    00341 9508      RET
_get_fat:
  wc                   --> R14
  p                    --> R10
  bc                   --> R10
  clst                 --> Y,+12
  fs                   --> R12
    00342 933A      ST	-Y,R19
    00343 932A      ST	-Y,R18
    00344 940E 277C CALL	push_xgsetF0FC
    00346 0168      MOVW	R12,R16
    00347 9722      SBIW	R28,2
(0809) }
(0810) 
(0811) 
(0812) 
(0813) 
(0814) /*-----------------------------------------------------------------------*/
(0815) /* FAT access - Read value of a FAT entry                                */
(0816) /*-----------------------------------------------------------------------*/
(0817) 
(0818) 
(0819) DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, Else:Cluster status */
(0820) 	FATFS *fs,	/* File system object */
(0821) 	DWORD clst	/* Cluster# to get the link information */
(0822) )
(0823) {
(0824) 	UINT wc, bc;
(0825) 	BYTE *p;
(0826) 
(0827) 
(0828) 	if (clst < 2 || clst >= fs->n_fatent)	/* Chack range */
    00348 E042      LDI	R20,2
    00349 E050      LDI	R21,0
    0034A E060      LDI	R22,0
    0034B E070      LDI	R23,0
    0034C 842C      LDD	R2,Y+12
    0034D 843D      LDD	R3,Y+13
    0034E 844E      LDD	R4,Y+14
    0034F 845F      LDD	R5,Y+15
    00350 1624      CP	R2,R20
    00351 0635      CPC	R3,R21
    00352 0646      CPC	R4,R22
    00353 0657      CPC	R5,R23
    00354 F078      BCS	0x0364
    00355 01F6      MOVW	R30,R12
    00356 9676      ADIW	R30,0x16
    00357 8020      LD	R2,Z
    00358 8031      LDD	R3,Z+1
    00359 8042      LDD	R4,Z+2
    0035A 8053      LDD	R5,Z+3
    0035B 846C      LDD	R6,Y+12
    0035C 847D      LDD	R7,Y+13
    0035D 848E      LDD	R8,Y+14
    0035E 849F      LDD	R9,Y+15
    0035F 1462      CP	R6,R2
    00360 0473      CPC	R7,R3
    00361 0484      CPC	R8,R4
    00362 0495      CPC	R9,R5
    00363 F028      BCS	0x0369
(0829) 		return 1;
    00364 E001      LDI	R16,1
    00365 E010      LDI	R17,0
    00366 E020      LDI	R18,0
    00367 E030      LDI	R19,0
    00368 C124      RJMP	0x048D
(0830) 
(0831) 	switch (fs->fs_type) {
    00369 01F6      MOVW	R30,R12
    0036A 80A0      LD	R10,Z
    0036B 24BB      CLR	R11
    0036C 01C5      MOVW	R24,R10
    0036D 3081      CPI	R24,1
    0036E E0E0      LDI	R30,0
    0036F 079E      CPC	R25,R30
    00370 F059      BEQ	0x037C
    00371 3082      CPI	R24,2
    00372 E0E0      LDI	R30,0
    00373 079E      CPC	R25,R30
    00374 F409      BNE	0x0376
    00375 C06F      RJMP	0x03E5
    00376 3083      CPI	R24,3
    00377 E0E0      LDI	R30,0
    00378 079E      CPC	R25,R30
    00379 F409      BNE	0x037B
    0037A C0A6      RJMP	0x0421
    0037B C10D      RJMP	0x0489
(0832) 	case FS_FAT12 :
(0833) 		bc = (UINT)clst; bc += bc / 2;
    0037C 84AC      LDD	R10,Y+12
    0037D 84BD      LDD	R11,Y+13
    0037E 0115      MOVW	R2,R10
    0037F 9436      LSR	R3
    00380 9427      ROR	R2
    00381 0CA2      ADD	R10,R2
    00382 1CB3      ADC	R11,R3
(0834) 		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
    00383 E029      LDI	R18,0x9
    00384 E030      LDI	R19,0
    00385 0185      MOVW	R16,R10
    00386 940E 2803 CALL	lsr16
    00388 0118      MOVW	R2,R16
    00389 2444      CLR	R4
    0038A 2455      CLR	R5
    0038B 01F6      MOVW	R30,R12
    0038C 8C66      LDD	R6,Z+30
    0038D 8C77      LDD	R7,Z+31
    0038E A080      LDD	R8,Z+32
    0038F A091      LDD	R9,Z+33
    00390 0C62      ADD	R6,R2
    00391 1C73      ADC	R7,R3
    00392 1C84      ADC	R8,R4
    00393 1C95      ADC	R9,R5
    00394 8288      ST	Y,R8
    00395 8299      STD	Y+1,R9
    00396 0193      MOVW	R18,R6
    00397 018F      MOVW	R16,R30
    00398 DDE0      RCALL	ff.c:move_window
    00399 2300      TST	R16
    0039A F009      BEQ	0x039C
    0039B C0ED      RJMP	0x0489
(0835) 		wc = fs->win[bc % SS(fs)]; bc++;
    0039C 01C6      MOVW	R24,R12
    0039D 968E      ADIW	R24,0x2E
    0039E 01F5      MOVW	R30,R10
    0039F 70F1      ANDI	R31,1
    003A0 0FE8      ADD	R30,R24
    003A1 1FF9      ADC	R31,R25
    003A2 80E0      LD	R14,Z
    003A3 24FF      CLR	R15
    003A4 01C5      MOVW	R24,R10
    003A5 9601      ADIW	R24,1
    003A6 015C      MOVW	R10,R24
(0836) 		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
    003A7 E029      LDI	R18,0x9
    003A8 E030      LDI	R19,0
    003A9 018C      MOVW	R16,R24
    003AA 940E 2803 CALL	lsr16
    003AC 0118      MOVW	R2,R16
    003AD 2444      CLR	R4
    003AE 2455      CLR	R5
    003AF 01F6      MOVW	R30,R12
    003B0 8C66      LDD	R6,Z+30
    003B1 8C77      LDD	R7,Z+31
    003B2 A080      LDD	R8,Z+32
    003B3 A091      LDD	R9,Z+33
    003B4 0C62      ADD	R6,R2
    003B5 1C73      ADC	R7,R3
    003B6 1C84      ADC	R8,R4
    003B7 1C95      ADC	R9,R5
    003B8 8288      ST	Y,R8
    003B9 8299      STD	Y+1,R9
    003BA 0193      MOVW	R18,R6
    003BB 018F      MOVW	R16,R30
    003BC DDBC      RCALL	ff.c:move_window
    003BD 2300      TST	R16
    003BE F009      BEQ	0x03C0
    003BF C0C9      RJMP	0x0489
(0837) 		wc |= fs->win[bc % SS(fs)] << 8;
    003C0 01C6      MOVW	R24,R12
    003C1 968E      ADIW	R24,0x2E
    003C2 01F5      MOVW	R30,R10
    003C3 70F1      ANDI	R31,1
    003C4 0FE8      ADD	R30,R24
    003C5 1FF9      ADC	R31,R25
    003C6 8020      LD	R2,Z
    003C7 2433      CLR	R3
    003C8 2C32      MOV	R3,R2
    003C9 2422      CLR	R2
    003CA 28E2      OR	R14,R2
    003CB 28F3      OR	R15,R3
(0838) 		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
    003CC 842C      LDD	R2,Y+12
    003CD 843D      LDD	R3,Y+13
    003CE 844E      LDD	R4,Y+14
    003CF 845F      LDD	R5,Y+15
    003D0 2DE2      MOV	R30,R2
    003D1 70E1      ANDI	R30,1
    003D2 F051      BEQ	0x03DD
    003D3 0157      MOVW	R10,R14
    003D4 94B6      LSR	R11
    003D5 94A7      ROR	R10
    003D6 94B6      LSR	R11
    003D7 94A7      ROR	R10
    003D8 94B6      LSR	R11
    003D9 94A7      ROR	R10
    003DA 94B6      LSR	R11
    003DB 94A7      ROR	R10
    003DC C003      RJMP	0x03E0
    003DD 01C7      MOVW	R24,R14
    003DE 709F      ANDI	R25,0xF
    003DF 015C      MOVW	R10,R24
    003E0 0185      MOVW	R16,R10
    003E1 0196      MOVW	R18,R12
    003E2 2722      CLR	R18
    003E3 2733      CLR	R19
    003E4 C0A8      RJMP	0x048D
(0839) 
(0840) 	case FS_FAT16 :
(0841) 		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)))) break;
    003E5 E088      LDI	R24,0x8
    003E6 E090      LDI	R25,0
    003E7 850C      LDD	R16,Y+12
    003E8 851D      LDD	R17,Y+13
    003E9 852E      LDD	R18,Y+14
    003EA 853F      LDD	R19,Y+15
    003EB 938A      ST	-Y,R24
    003EC 940E 280A CALL	lsr32
    003EE 01F6      MOVW	R30,R12
    003EF 8C26      LDD	R2,Z+30
    003F0 8C37      LDD	R3,Z+31
    003F1 A040      LDD	R4,Z+32
    003F2 A051      LDD	R5,Z+33
    003F3 0E20      ADD	R2,R16
    003F4 1E31      ADC	R3,R17
    003F5 1E42      ADC	R4,R18
    003F6 1E53      ADC	R5,R19
    003F7 8248      ST	Y,R4
    003F8 8259      STD	Y+1,R5
    003F9 0191      MOVW	R18,R2
    003FA 018F      MOVW	R16,R30
    003FB DD7D      RCALL	ff.c:move_window
    003FC 2EA0      MOV	R10,R16
    003FD 2300      TST	R16
    003FE F009      BEQ	0x0400
    003FF C089      RJMP	0x0489
(0842) 		p = &fs->win[clst * 2 % SS(fs)];
    00400 EF4F      LDI	R20,0xFF
    00401 E051      LDI	R21,1
    00402 E060      LDI	R22,0
    00403 E070      LDI	R23,0
    00404 842C      LDD	R2,Y+12
    00405 843D      LDD	R3,Y+13
    00406 844E      LDD	R4,Y+14
    00407 845F      LDD	R5,Y+15
    00408 0C22      LSL	R2
    00409 1C33      ROL	R3
    0040A 1C44      ROL	R4
    0040B 1C55      ROL	R5
    0040C 2224      AND	R2,R20
    0040D 2235      AND	R3,R21
    0040E 2246      AND	R4,R22
    0040F 2257      AND	R5,R23
    00410 0151      MOVW	R10,R2
    00411 01C6      MOVW	R24,R12
    00412 968E      ADIW	R24,0x2E
    00413 0EA8      ADD	R10,R24
    00414 1EB9      ADC	R11,R25
(0843) 		return LD_WORD(p);
    00415 01F5      MOVW	R30,R10
    00416 8020      LD	R2,Z
    00417 2433      CLR	R3
    00418 8101      LDD	R16,Z+1
    00419 2711      CLR	R17
    0041A 2F10      MOV	R17,R16
    0041B 2700      CLR	R16
    0041C 2902      OR	R16,R2
    0041D 2913      OR	R17,R3
    0041E 2722      CLR	R18
    0041F 2733      CLR	R19
    00420 C06C      RJMP	0x048D
(0844) 
(0845) 	case FS_FAT32 :
(0846) 		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
    00421 E087      LDI	R24,7
    00422 E090      LDI	R25,0
    00423 850C      LDD	R16,Y+12
    00424 851D      LDD	R17,Y+13
    00425 852E      LDD	R18,Y+14
    00426 853F      LDD	R19,Y+15
    00427 938A      ST	-Y,R24
    00428 940E 280A CALL	lsr32
    0042A 01F6      MOVW	R30,R12
    0042B 8C26      LDD	R2,Z+30
    0042C 8C37      LDD	R3,Z+31
    0042D A040      LDD	R4,Z+32
    0042E A051      LDD	R5,Z+33
    0042F 0E20      ADD	R2,R16
    00430 1E31      ADC	R3,R17
    00431 1E42      ADC	R4,R18
    00432 1E53      ADC	R5,R19
    00433 8248      ST	Y,R4
    00434 8259      STD	Y+1,R5
    00435 0191      MOVW	R18,R2
    00436 018F      MOVW	R16,R30
    00437 DD41      RCALL	ff.c:move_window
    00438 2EE0      MOV	R14,R16
    00439 2300      TST	R16
    0043A F009      BEQ	0x043C
    0043B C04D      RJMP	0x0489
(0847) 		p = &fs->win[clst * 4 % SS(fs)];
    0043C E082      LDI	R24,2
    0043D E090      LDI	R25,0
    0043E 850C      LDD	R16,Y+12
    0043F 851D      LDD	R17,Y+13
    00440 852E      LDD	R18,Y+14
    00441 853F      LDD	R19,Y+15
    00442 938A      ST	-Y,R24
    00443 940E 27F7 CALL	lsl32
    00445 0118      MOVW	R2,R16
    00446 0129      MOVW	R4,R18
    00447 EF4F      LDI	R20,0xFF
    00448 E051      LDI	R21,1
    00449 E060      LDI	R22,0
    0044A E070      LDI	R23,0
    0044B 2224      AND	R2,R20
    0044C 2235      AND	R3,R21
    0044D 2246      AND	R4,R22
    0044E 2257      AND	R5,R23
    0044F 0151      MOVW	R10,R2
    00450 01C6      MOVW	R24,R12
    00451 968E      ADIW	R24,0x2E
    00452 0EA8      ADD	R10,R24
    00453 1EB9      ADC	R11,R25
(0848) 		return LD_DWORD(p) & 0x0FFFFFFF;
    00454 E188      LDI	R24,0x18
    00455 E090      LDI	R25,0
    00456 01F5      MOVW	R30,R10
    00457 8103      LDD	R16,Z+3
    00458 2711      CLR	R17
    00459 2722      CLR	R18
    0045A 2733      CLR	R19
    0045B 938A      ST	-Y,R24
    0045C 940E 27F7 CALL	lsl32
    0045E 0118      MOVW	R2,R16
    0045F 0129      MOVW	R4,R18
    00460 01F5      MOVW	R30,R10
    00461 8062      LDD	R6,Z+2
    00462 2477      CLR	R7
    00463 2488      CLR	R8
    00464 2499      CLR	R9
    00465 0143      MOVW	R8,R6
    00466 2466      CLR	R6
    00467 2477      CLR	R7
    00468 2826      OR	R2,R6
    00469 2837      OR	R3,R7
    0046A 2848      OR	R4,R8
    0046B 2859      OR	R5,R9
    0046C 8061      LDD	R6,Z+1
    0046D 2477      CLR	R7
    0046E 2C76      MOV	R7,R6
    0046F 2466      CLR	R6
    00470 2488      CLR	R8
    00471 2499      CLR	R9
    00472 2826      OR	R2,R6
    00473 2837      OR	R3,R7
    00474 2848      OR	R4,R8
    00475 2859      OR	R5,R9
    00476 8060      LD	R6,Z
    00477 2477      CLR	R7
    00478 2488      CLR	R8
    00479 2499      CLR	R9
    0047A 2826      OR	R2,R6
    0047B 2837      OR	R3,R7
    0047C 2848      OR	R4,R8
    0047D 2859      OR	R5,R9
    0047E EF4F      LDI	R20,0xFF
    0047F EF5F      LDI	R21,0xFF
    00480 EF6F      LDI	R22,0xFF
    00481 E07F      LDI	R23,0xF
    00482 2224      AND	R2,R20
    00483 2235      AND	R3,R21
    00484 2246      AND	R4,R22
    00485 2257      AND	R5,R23
    00486 0181      MOVW	R16,R2
    00487 0192      MOVW	R18,R4
    00488 C004      RJMP	0x048D
(0849) 	}
(0850) 
(0851) 	return 0xFFFFFFFF;	/* An error occurred at the disk I/O layer */
    00489 EF0F      LDI	R16,0xFF
    0048A EF1F      LDI	R17,0xFF
    0048B EF2F      LDI	R18,0xFF
    0048C EF3F      LDI	R19,0xFF
    0048D 9622      ADIW	R28,2
    0048E 940E 2771 CALL	pop_xgsetF0FC
    00490 9622      ADIW	R28,2
    00491 9508      RET
_put_fat:
  bc                   --> R12
  p                    --> R14
  res                  --> Y,+2
  val                  --> Y,+19
  clst                 --> Y,+15
  fs                   --> Y,+13
    00492 940E 26A9 CALL	push_arg4
    00494 940E 277C CALL	push_xgsetF0FC
    00496 9723      SBIW	R28,3
(0852) }
(0853) 
(0854) 
(0855) 
(0856) 
(0857) /*-----------------------------------------------------------------------*/
(0858) /* FAT access - Change value of a FAT entry                              */
(0859) /*-----------------------------------------------------------------------*/
(0860) #if !_FS_READONLY
(0861) 
(0862) FRESULT put_fat (
(0863) 	FATFS *fs,	/* File system object */
(0864) 	DWORD clst,	/* Cluster# to be changed in range of 2 to fs->n_fatent - 1 */
(0865) 	DWORD val	/* New value to mark the cluster */
(0866) )
(0867) {
(0868) 	UINT bc;
(0869) 	BYTE *p;
(0870) 	FRESULT res;
(0871) 
(0872) 
(0873) 	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
    00497 E042      LDI	R20,2
    00498 E050      LDI	R21,0
    00499 E060      LDI	R22,0
    0049A E070      LDI	R23,0
    0049B 842F      LDD	R2,Y+15
    0049C 8838      LDD	R3,Y+16
    0049D 8849      LDD	R4,Y+17
    0049E 885A      LDD	R5,Y+18
    0049F 1624      CP	R2,R20
    004A0 0635      CPC	R3,R21
    004A1 0646      CPC	R4,R22
    004A2 0657      CPC	R5,R23
    004A3 F080      BCS	0x04B4
    004A4 85ED      LDD	R30,Y+13
    004A5 85FE      LDD	R31,Y+14
    004A6 9676      ADIW	R30,0x16
    004A7 8020      LD	R2,Z
    004A8 8031      LDD	R3,Z+1
    004A9 8042      LDD	R4,Z+2
    004AA 8053      LDD	R5,Z+3
    004AB 846F      LDD	R6,Y+15
    004AC 8878      LDD	R7,Y+16
    004AD 8889      LDD	R8,Y+17
    004AE 889A      LDD	R9,Y+18
    004AF 1462      CP	R6,R2
    004B0 0473      CPC	R7,R3
    004B1 0484      CPC	R8,R4
    004B2 0495      CPC	R9,R5
    004B3 F018      BCS	0x04B7
(0874) 		res = FR_INT_ERR;
    004B4 E082      LDI	R24,2
    004B5 838A      STD	Y+2,R24
(0875) 
(0876) 	} else {
    004B6 C194      RJMP	0x064B
(0877) 		switch (fs->fs_type) {
    004B7 85ED      LDD	R30,Y+13
    004B8 85FE      LDD	R31,Y+14
    004B9 80A0      LD	R10,Z
    004BA 24BB      CLR	R11
    004BB 01C5      MOVW	R24,R10
    004BC 3081      CPI	R24,1
    004BD E0E0      LDI	R30,0
    004BE 079E      CPC	R25,R30
    004BF F059      BEQ	0x04CB
    004C0 3082      CPI	R24,2
    004C1 E0E0      LDI	R30,0
    004C2 079E      CPC	R25,R30
    004C3 F409      BNE	0x04C5
    004C4 C0B0      RJMP	0x0575
    004C5 3083      CPI	R24,3
    004C6 E0E0      LDI	R30,0
    004C7 079E      CPC	R25,R30
    004C8 F409      BNE	0x04CA
    004C9 C0E7      RJMP	0x05B1
    004CA C17A      RJMP	0x0645
(0878) 		case FS_FAT12 :
(0879) 			bc = clst; bc += bc / 2;
    004CB 84CF      LDD	R12,Y+15
    004CC 88D8      LDD	R13,Y+16
    004CD 0116      MOVW	R2,R12
    004CE 9436      LSR	R3
    004CF 9427      ROR	R2
    004D0 0CC2      ADD	R12,R2
    004D1 1CD3      ADC	R13,R3
(0880) 			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
    004D2 E029      LDI	R18,0x9
    004D3 E030      LDI	R19,0
    004D4 0186      MOVW	R16,R12
    004D5 940E 2803 CALL	lsr16
    004D7 0118      MOVW	R2,R16
    004D8 2444      CLR	R4
    004D9 2455      CLR	R5
    004DA 85ED      LDD	R30,Y+13
    004DB 85FE      LDD	R31,Y+14
    004DC 8C66      LDD	R6,Z+30
    004DD 8C77      LDD	R7,Z+31
    004DE A080      LDD	R8,Z+32
    004DF A091      LDD	R9,Z+33
    004E0 0C62      ADD	R6,R2
    004E1 1C73      ADC	R7,R3
    004E2 1C84      ADC	R8,R4
    004E3 1C95      ADC	R9,R5
    004E4 8288      ST	Y,R8
    004E5 8299      STD	Y+1,R9
    004E6 0193      MOVW	R18,R6
    004E7 018F      MOVW	R16,R30
    004E8 DC90      RCALL	ff.c:move_window
    004E9 830A      STD	Y+2,R16
(0881) 			if (res != FR_OK) break;
    004EA 2E00      MOV	R0,R16
    004EB 2300      TST	R16
    004EC F009      BEQ	0x04EE
    004ED C159      RJMP	0x0647
(0882) 			p = &fs->win[bc % SS(fs)];
    004EE 858D      LDD	R24,Y+13
    004EF 859E      LDD	R25,Y+14
    004F0 968E      ADIW	R24,0x2E
    004F1 01F6      MOVW	R30,R12
    004F2 70F1      ANDI	R31,1
    004F3 017F      MOVW	R14,R30
    004F4 0EE8      ADD	R14,R24
    004F5 1EF9      ADC	R15,R25
(0883) 			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
    004F6 842F      LDD	R2,Y+15
    004F7 8838      LDD	R3,Y+16
    004F8 8849      LDD	R4,Y+17
    004F9 885A      LDD	R5,Y+18
    004FA 93EF      PUSH	R30
    004FB 2DE2      MOV	R30,R2
    004FC 70E1      ANDI	R30,1
    004FD 91EF      POP	R30
    004FE F0B1      BEQ	0x0515
    004FF 882B      LDD	R2,Y+19
    00500 883C      LDD	R3,Y+20
    00501 884D      LDD	R4,Y+21
    00502 885E      LDD	R5,Y+22
    00503 2433      CLR	R3
    00504 0C22      LSL	R2
    00505 1C33      ROL	R3
    00506 0C22      LSL	R2
    00507 1C33      ROL	R3
    00508 0C22      LSL	R2
    00509 1C33      ROL	R3
    0050A 0C22      LSL	R2
    0050B 1C33      ROL	R3
    0050C 01F7      MOVW	R30,R14
    0050D 8180      LD	R24,Z
    0050E 2799      CLR	R25
    0050F 708F      ANDI	R24,0xF
    00510 7090      ANDI	R25,0
    00511 015C      MOVW	R10,R24
    00512 28A2      OR	R10,R2
    00513 28B3      OR	R11,R3
    00514 C006      RJMP	0x051B
    00515 882B      LDD	R2,Y+19
    00516 883C      LDD	R3,Y+20
    00517 884D      LDD	R4,Y+21
    00518 885E      LDD	R5,Y+22
    00519 2CA2      MOV	R10,R2
    0051A 24BB      CLR	R11
    0051B 01F7      MOVW	R30,R14
    0051C 82A0      ST	Z,R10
(0884) 			bc++;
    0051D 01C6      MOVW	R24,R12
    0051E 9601      ADIW	R24,1
    0051F 016C      MOVW	R12,R24
(0885) 			fs->wflag = 1;
    00520 E081      LDI	R24,1
    00521 85ED      LDD	R30,Y+13
    00522 85FE      LDD	R31,Y+14
    00523 8384      STD	Z+4,R24
(0886) 			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
    00524 E029      LDI	R18,0x9
    00525 E030      LDI	R19,0
    00526 0186      MOVW	R16,R12
    00527 940E 2803 CALL	lsr16
    00529 0118      MOVW	R2,R16
    0052A 2444      CLR	R4
    0052B 2455      CLR	R5
    0052C 85ED      LDD	R30,Y+13
    0052D 85FE      LDD	R31,Y+14
    0052E 8C66      LDD	R6,Z+30
    0052F 8C77      LDD	R7,Z+31
    00530 A080      LDD	R8,Z+32
    00531 A091      LDD	R9,Z+33
    00532 0C62      ADD	R6,R2
    00533 1C73      ADC	R7,R3
    00534 1C84      ADC	R8,R4
    00535 1C95      ADC	R9,R5
    00536 8288      ST	Y,R8
    00537 8299      STD	Y+1,R9
    00538 0193      MOVW	R18,R6
    00539 018F      MOVW	R16,R30
    0053A DC3E      RCALL	ff.c:move_window
    0053B 830A      STD	Y+2,R16
(0887) 			if (res != FR_OK) break;
    0053C 2E00      MOV	R0,R16
    0053D 2300      TST	R16
    0053E F009      BEQ	0x0540
    0053F C107      RJMP	0x0647
(0888) 			p = &fs->win[bc % SS(fs)];
    00540 858D      LDD	R24,Y+13
    00541 859E      LDD	R25,Y+14
    00542 968E      ADIW	R24,0x2E
    00543 01F6      MOVW	R30,R12
    00544 70F1      ANDI	R31,1
    00545 017F      MOVW	R14,R30
    00546 0EE8      ADD	R14,R24
    00547 1EF9      ADC	R15,R25
(0889) 			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
    00548 842F      LDD	R2,Y+15
    00549 8838      LDD	R3,Y+16
    0054A 8849      LDD	R4,Y+17
    0054B 885A      LDD	R5,Y+18
    0054C 93EF      PUSH	R30
    0054D 2DE2      MOV	R30,R2
    0054E 70E1      ANDI	R30,1
    0054F 91EF      POP	R30
    00550 F061      BEQ	0x055D
    00551 E084      LDI	R24,4
    00552 E090      LDI	R25,0
    00553 890B      LDD	R16,Y+19
    00554 891C      LDD	R17,Y+20
    00555 892D      LDD	R18,Y+21
    00556 893E      LDD	R19,Y+22
    00557 938A      ST	-Y,R24
    00558 940E 280A CALL	lsr32
    0055A 2EC0      MOV	R12,R16
    0055B 24DD      CLR	R13
    0055C C015      RJMP	0x0572
    0055D E088      LDI	R24,0x8
    0055E E090      LDI	R25,0
    0055F 890B      LDD	R16,Y+19
    00560 891C      LDD	R17,Y+20
    00561 892D      LDD	R18,Y+21
    00562 893E      LDD	R19,Y+22
    00563 938A      ST	-Y,R24
    00564 940E 280A CALL	lsr32
    00566 2F80      MOV	R24,R16
    00567 2799      CLR	R25
    00568 708F      ANDI	R24,0xF
    00569 7090      ANDI	R25,0
    0056A 01F7      MOVW	R30,R14
    0056B 81E0      LD	R30,Z
    0056C 27FF      CLR	R31
    0056D 7FE0      ANDI	R30,0xF0
    0056E 70F0      ANDI	R31,0
    0056F 016F      MOVW	R12,R30
    00570 2AC8      OR	R12,R24
    00571 2AD9      OR	R13,R25
    00572 01F7      MOVW	R30,R14
    00573 82C0      ST	Z,R12
(0890) 			break;
    00574 C0D2      RJMP	0x0647
(0891) 
(0892) 		case FS_FAT16 :
(0893) 			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
    00575 E088      LDI	R24,0x8
    00576 E090      LDI	R25,0
    00577 850F      LDD	R16,Y+15
    00578 8918      LDD	R17,Y+16
    00579 8929      LDD	R18,Y+17
    0057A 893A      LDD	R19,Y+18
    0057B 938A      ST	-Y,R24
    0057C 940E 280A CALL	lsr32
    0057E 85ED      LDD	R30,Y+13
    0057F 85FE      LDD	R31,Y+14
    00580 8C26      LDD	R2,Z+30
    00581 8C37      LDD	R3,Z+31
    00582 A040      LDD	R4,Z+32
    00583 A051      LDD	R5,Z+33
    00584 0E20      ADD	R2,R16
    00585 1E31      ADC	R3,R17
    00586 1E42      ADC	R4,R18
    00587 1E53      ADC	R5,R19
    00588 8248      ST	Y,R4
    00589 8259      STD	Y+1,R5
    0058A 0191      MOVW	R18,R2
    0058B 018F      MOVW	R16,R30
    0058C DBEC      RCALL	ff.c:move_window
    0058D 2EC0      MOV	R12,R16
    0058E 82CA      STD	Y+2,R12
(0894) 			if (res != FR_OK) break;
    0058F 2C0C      MOV	R0,R12
    00590 2300      TST	R16
    00591 F009      BEQ	0x0593
    00592 C0B4      RJMP	0x0647
(0895) 			p = &fs->win[clst * 2 % SS(fs)];
    00593 EF4F      LDI	R20,0xFF
    00594 E051      LDI	R21,1
    00595 E060      LDI	R22,0
    00596 E070      LDI	R23,0
    00597 842F      LDD	R2,Y+15
    00598 8838      LDD	R3,Y+16
    00599 8849      LDD	R4,Y+17
    0059A 885A      LDD	R5,Y+18
    0059B 0C22      LSL	R2
    0059C 1C33      ROL	R3
    0059D 1C44      ROL	R4
    0059E 1C55      ROL	R5
    0059F 2224      AND	R2,R20
    005A0 2235      AND	R3,R21
    005A1 2246      AND	R4,R22
    005A2 2257      AND	R5,R23
    005A3 0171      MOVW	R14,R2
    005A4 858D      LDD	R24,Y+13
    005A5 859E      LDD	R25,Y+14
    005A6 968E      ADIW	R24,0x2E
    005A7 0EE8      ADD	R14,R24
    005A8 1EF9      ADC	R15,R25
(0896) 			ST_WORD(p, (WORD)val);
    005A9 882B      LDD	R2,Y+19
    005AA 883C      LDD	R3,Y+20
    005AB 01F7      MOVW	R30,R14
    005AC 8220      ST	Z,R2
    005AD 2C23      MOV	R2,R3
    005AE 2433      CLR	R3
    005AF 8221      STD	Z+1,R2
(0897) 			break;
    005B0 C096      RJMP	0x0647
(0898) 
(0899) 		case FS_FAT32 :
(0900) 			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
    005B1 E087      LDI	R24,7
    005B2 E090      LDI	R25,0
    005B3 850F      LDD	R16,Y+15
    005B4 8918      LDD	R17,Y+16
    005B5 8929      LDD	R18,Y+17
    005B6 893A      LDD	R19,Y+18
    005B7 938A      ST	-Y,R24
    005B8 940E 280A CALL	lsr32
    005BA 85ED      LDD	R30,Y+13
    005BB 85FE      LDD	R31,Y+14
    005BC 8C26      LDD	R2,Z+30
    005BD 8C37      LDD	R3,Z+31
    005BE A040      LDD	R4,Z+32
    005BF A051      LDD	R5,Z+33
    005C0 0E20      ADD	R2,R16
    005C1 1E31      ADC	R3,R17
    005C2 1E42      ADC	R4,R18
    005C3 1E53      ADC	R5,R19
    005C4 8248      ST	Y,R4
    005C5 8259      STD	Y+1,R5
    005C6 0191      MOVW	R18,R2
    005C7 018F      MOVW	R16,R30
    005C8 DBB0      RCALL	ff.c:move_window
    005C9 2EC0      MOV	R12,R16
    005CA 82CA      STD	Y+2,R12
(0901) 			if (res != FR_OK) break;
    005CB 2C0C      MOV	R0,R12
    005CC 2300      TST	R16
    005CD F009      BEQ	0x05CF
    005CE C078      RJMP	0x0647
(0902) 			p = &fs->win[clst * 4 % SS(fs)];
    005CF E082      LDI	R24,2
    005D0 E090      LDI	R25,0
    005D1 850F      LDD	R16,Y+15
    005D2 8918      LDD	R17,Y+16
    005D3 8929      LDD	R18,Y+17
    005D4 893A      LDD	R19,Y+18
    005D5 938A      ST	-Y,R24
    005D6 940E 27F7 CALL	lsl32
    005D8 0118      MOVW	R2,R16
    005D9 0129      MOVW	R4,R18
    005DA EF4F      LDI	R20,0xFF
    005DB E051      LDI	R21,1
    005DC E060      LDI	R22,0
    005DD E070      LDI	R23,0
    005DE 2224      AND	R2,R20
    005DF 2235      AND	R3,R21
    005E0 2246      AND	R4,R22
    005E1 2257      AND	R5,R23
    005E2 0171      MOVW	R14,R2
    005E3 858D      LDD	R24,Y+13
    005E4 859E      LDD	R25,Y+14
    005E5 968E      ADIW	R24,0x2E
    005E6 0EE8      ADD	R14,R24
    005E7 1EF9      ADC	R15,R25
(0903) 			val |= LD_DWORD(p) & 0xF0000000;
    005E8 E188      LDI	R24,0x18
    005E9 E090      LDI	R25,0
    005EA 01F7      MOVW	R30,R14
    005EB 8103      LDD	R16,Z+3
    005EC 2711      CLR	R17
    005ED 2722      CLR	R18
    005EE 2733      CLR	R19
    005EF 938A      ST	-Y,R24
    005F0 940E 27F7 CALL	lsl32
    005F2 0118      MOVW	R2,R16
    005F3 0129      MOVW	R4,R18
    005F4 01F7      MOVW	R30,R14
    005F5 8062      LDD	R6,Z+2
    005F6 2477      CLR	R7
    005F7 2488      CLR	R8
    005F8 2499      CLR	R9
    005F9 0143      MOVW	R8,R6
    005FA 2466      CLR	R6
    005FB 2477      CLR	R7
    005FC 2826      OR	R2,R6
    005FD 2837      OR	R3,R7
    005FE 2848      OR	R4,R8
    005FF 2859      OR	R5,R9
    00600 8061      LDD	R6,Z+1
    00601 2477      CLR	R7
    00602 2C76      MOV	R7,R6
    00603 2466      CLR	R6
    00604 2488      CLR	R8
    00605 2499      CLR	R9
    00606 2826      OR	R2,R6
    00607 2837      OR	R3,R7
    00608 2848      OR	R4,R8
    00609 2859      OR	R5,R9
    0060A 8060      LD	R6,Z
    0060B 2477      CLR	R7
    0060C 2488      CLR	R8
    0060D 2499      CLR	R9
    0060E 2826      OR	R2,R6
    0060F 2837      OR	R3,R7
    00610 2848      OR	R4,R8
    00611 2859      OR	R5,R9
    00612 E040      LDI	R20,0
    00613 E050      LDI	R21,0
    00614 E060      LDI	R22,0
    00615 EF70      LDI	R23,0xF0
    00616 2224      AND	R2,R20
    00617 2235      AND	R3,R21
    00618 2246      AND	R4,R22
    00619 2257      AND	R5,R23
    0061A 886B      LDD	R6,Y+19
    0061B 887C      LDD	R7,Y+20
    0061C 888D      LDD	R8,Y+21
    0061D 889E      LDD	R9,Y+22
    0061E 2862      OR	R6,R2
    0061F 2873      OR	R7,R3
    00620 2884      OR	R8,R4
    00621 2895      OR	R9,R5
    00622 8A6B      STD	Y+19,R6
    00623 8A7C      STD	Y+20,R7
    00624 8A8D      STD	Y+21,R8
    00625 8A9E      STD	Y+22,R9
(0904) 			ST_DWORD(p, val);
    00626 882B      LDD	R2,Y+19
    00627 883C      LDD	R3,Y+20
    00628 884D      LDD	R4,Y+21
    00629 885E      LDD	R5,Y+22
    0062A 8220      ST	Z,R2
    0062B 2C23      MOV	R2,R3
    0062C 2433      CLR	R3
    0062D 9631      ADIW	R30,1
    0062E 8220      ST	Z,R2
    0062F 882B      LDD	R2,Y+19
    00630 883C      LDD	R3,Y+20
    00631 884D      LDD	R4,Y+21
    00632 885E      LDD	R5,Y+22
    00633 0112      MOVW	R2,R4
    00634 2444      CLR	R4
    00635 2455      CLR	R5
    00636 01F7      MOVW	R30,R14
    00637 9632      ADIW	R30,2
    00638 8220      ST	Z,R2
    00639 E188      LDI	R24,0x18
    0063A E090      LDI	R25,0
    0063B 890B      LDD	R16,Y+19
    0063C 891C      LDD	R17,Y+20
    0063D 892D      LDD	R18,Y+21
    0063E 893E      LDD	R19,Y+22
    0063F 938A      ST	-Y,R24
    00640 940E 280A CALL	lsr32
    00642 01F7      MOVW	R30,R14
    00643 8303      STD	Z+3,R16
(0905) 			break;
    00644 C002      RJMP	0x0647
(0906) 
(0907) 		default :
(0908) 			res = FR_INT_ERR;
    00645 E082      LDI	R24,2
    00646 838A      STD	Y+2,R24
(0909) 		}
(0910) 		fs->wflag = 1;
    00647 E081      LDI	R24,1
    00648 85ED      LDD	R30,Y+13
    00649 85FE      LDD	R31,Y+14
    0064A 8384      STD	Z+4,R24
(0911) 	}
(0912) 
(0913) 	return res;
    0064B 810A      LDD	R16,Y+2
    0064C 9623      ADIW	R28,3
    0064D 940E 2771 CALL	pop_xgsetF0FC
    0064F 9624      ADIW	R28,4
    00650 9508      RET
ff.c:remove_chain:
  res                  --> R10
  nxt                  --> Y,+6
  clst                 --> Y,+18
  fs                   --> R12
    00651 933A      ST	-Y,R19
    00652 932A      ST	-Y,R18
    00653 940E 27B7 CALL	push_xgsetF03C
    00655 0168      MOVW	R12,R16
    00656 972A      SBIW	R28,0xA
(0914) }
(0915) #endif /* !_FS_READONLY */
(0916) 
(0917) 
(0918) 
(0919) 
(0920) /*-----------------------------------------------------------------------*/
(0921) /* FAT handling - Remove a cluster chain                                 */
(0922) /*-----------------------------------------------------------------------*/
(0923) #if !_FS_READONLY
(0924) static
(0925) FRESULT remove_chain (
(0926) 	FATFS *fs,			/* File system object */
(0927) 	DWORD clst			/* Cluster# to remove a chain from */
(0928) )
(0929) {
(0930) 	FRESULT res;
(0931) 	DWORD nxt;
(0932) #if _USE_ERASE
(0933) 	DWORD scl = clst, ecl = clst, resion[2];
(0934) #endif
(0935) 
(0936) 	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
    00657 E042      LDI	R20,2
    00658 E050      LDI	R21,0
    00659 E060      LDI	R22,0
    0065A E070      LDI	R23,0
    0065B 882A      LDD	R2,Y+18
    0065C 883B      LDD	R3,Y+19
    0065D 884C      LDD	R4,Y+20
    0065E 885D      LDD	R5,Y+21
    0065F 1624      CP	R2,R20
    00660 0635      CPC	R3,R21
    00661 0646      CPC	R4,R22
    00662 0657      CPC	R5,R23
    00663 F078      BCS	0x0673
    00664 01F6      MOVW	R30,R12
    00665 9676      ADIW	R30,0x16
    00666 8020      LD	R2,Z
    00667 8031      LDD	R3,Z+1
    00668 8042      LDD	R4,Z+2
    00669 8053      LDD	R5,Z+3
    0066A 886A      LDD	R6,Y+18
    0066B 887B      LDD	R7,Y+19
    0066C 888C      LDD	R8,Y+20
    0066D 889D      LDD	R9,Y+21
    0066E 1462      CP	R6,R2
    0066F 0473      CPC	R7,R3
    00670 0484      CPC	R8,R4
    00671 0495      CPC	R9,R5
    00672 F018      BCS	0x0676
(0937) 		res = FR_INT_ERR;
    00673 E082      LDI	R24,2
    00674 2EA8      MOV	R10,R24
(0938) 
(0939) 	} else {
    00675 C088      RJMP	0x06FE
(0940) 		res = FR_OK;
    00676 24AA      CLR	R10
    00677 C076      RJMP	0x06EE
(0941) 		while (clst < fs->n_fatent) {			/* Not a last link? */
(0942) 			nxt = get_fat(fs, clst);			/* Get cluster status */
    00678 882A      LDD	R2,Y+18
    00679 883B      LDD	R3,Y+19
    0067A 884C      LDD	R4,Y+20
    0067B 885D      LDD	R5,Y+21
    0067C 8248      ST	Y,R4
    0067D 8259      STD	Y+1,R5
    0067E 0191      MOVW	R18,R2
    0067F 0186      MOVW	R16,R12
    00680 DCC1      RCALL	_get_fat
    00681 830E      STD	Y+6,R16
    00682 831F      STD	Y+7,R17
    00683 8728      STD	Y+8,R18
    00684 8739      STD	Y+9,R19
(0943) 			if (nxt == 0) break;				/* Empty cluster? */
    00685 802E      LDD	R2,Y+6
    00686 803F      LDD	R3,Y+7
    00687 8448      LDD	R4,Y+8
    00688 8459      LDD	R5,Y+9
    00689 9488      BCLR	0
    0068A 2022      TST	R2
    0068B 0432      CPC	R3,R2
    0068C 0442      CPC	R4,R2
    0068D 0452      CPC	R5,R2
    0068E F409      BNE	0x0690
    0068F C06E      RJMP	0x06FE
(0944) 			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
    00690 E041      LDI	R20,1
    00691 E050      LDI	R21,0
    00692 E060      LDI	R22,0
    00693 E070      LDI	R23,0
    00694 802E      LDD	R2,Y+6
    00695 803F      LDD	R3,Y+7
    00696 8448      LDD	R4,Y+8
    00697 8459      LDD	R5,Y+9
    00698 1624      CP	R2,R20
    00699 0635      CPC	R3,R21
    0069A 0646      CPC	R4,R22
    0069B 0657      CPC	R5,R23
    0069C F419      BNE	0x06A0
    0069D E082      LDI	R24,2
    0069E 2EA8      MOV	R10,R24
    0069F C05E      RJMP	0x06FE
(0945) 			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
    006A0 EF4F      LDI	R20,0xFF
    006A1 EF5F      LDI	R21,0xFF
    006A2 EF6F      LDI	R22,0xFF
    006A3 EF7F      LDI	R23,0xFF
    006A4 802E      LDD	R2,Y+6
    006A5 803F      LDD	R3,Y+7
    006A6 8448      LDD	R4,Y+8
    006A7 8459      LDD	R5,Y+9
    006A8 1624      CP	R2,R20
    006A9 0635      CPC	R3,R21
    006AA 0646      CPC	R4,R22
    006AB 0657      CPC	R5,R23
    006AC F419      BNE	0x06B0
    006AD 24AA      CLR	R10
    006AE 94A3      INC	R10
    006AF C04E      RJMP	0x06FE
(0946) 			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
    006B0 E080      LDI	R24,0
    006B1 838A      STD	Y+2,R24
    006B2 838B      STD	Y+3,R24
    006B3 838C      STD	Y+4,R24
    006B4 838D      STD	Y+5,R24
    006B5 882A      LDD	R2,Y+18
    006B6 883B      LDD	R3,Y+19
    006B7 884C      LDD	R4,Y+20
    006B8 885D      LDD	R5,Y+21
    006B9 8248      ST	Y,R4
    006BA 8259      STD	Y+1,R5
    006BB 0191      MOVW	R18,R2
    006BC 0186      MOVW	R16,R12
    006BD DDD4      RCALL	_put_fat
    006BE 2EA0      MOV	R10,R16
(0947) 			if (res != FR_OK) break;
    006BF 2300      TST	R16
    006C0 F009      BEQ	0x06C2
    006C1 C03C      RJMP	0x06FE
(0948) 			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSInfo */
    006C2 EF4F      LDI	R20,0xFF
    006C3 EF5F      LDI	R21,0xFF
    006C4 EF6F      LDI	R22,0xFF
    006C5 EF7F      LDI	R23,0xFF
    006C6 01F6      MOVW	R30,R12
    006C7 8426      LDD	R2,Z+14
    006C8 8437      LDD	R3,Z+15
    006C9 8840      LDD	R4,Z+16
    006CA 8851      LDD	R5,Z+17
    006CB 1624      CP	R2,R20
    006CC 0635      CPC	R3,R21
    006CD 0646      CPC	R4,R22
    006CE 0657      CPC	R5,R23
    006CF F0B1      BEQ	0x06E6
(0949) 				fs->free_clust++;
    006D0 01CF      MOVW	R24,R30
    006D1 960E      ADIW	R24,0xE
    006D2 E041      LDI	R20,1
    006D3 E050      LDI	R21,0
    006D4 E060      LDI	R22,0
    006D5 E070      LDI	R23,0
    006D6 01FC      MOVW	R30,R24
    006D7 8020      LD	R2,Z
    006D8 8031      LDD	R3,Z+1
    006D9 8042      LDD	R4,Z+2
    006DA 8053      LDD	R5,Z+3
    006DB 0E24      ADD	R2,R20
    006DC 1E35      ADC	R3,R21
    006DD 1E46      ADC	R4,R22
    006DE 1E57      ADC	R5,R23
    006DF 8220      ST	Z,R2
    006E0 8231      STD	Z+1,R3
    006E1 8242      STD	Z+2,R4
    006E2 8253      STD	Z+3,R5
(0950) 				fs->fsi_flag = 1;
    006E3 E081      LDI	R24,1
    006E4 01F6      MOVW	R30,R12
    006E5 8385      STD	Z+5,R24
(0951) 			}
(0952) #if _USE_ERASE
(0953) 			if (ecl + 1 == nxt) {	/* Next cluster is contiguous */
(0954) 				ecl = nxt;
(0955) 			} else {				/* End of contiguous clusters */ 
(0956) 				resion[0] = clust2sect(fs, scl);					/* Start sector */
(0957) 				resion[1] = clust2sect(fs, ecl) + fs->csize - 1;	/* End sector */
(0958) 				disk_ioctl(fs->drv, CTRL_ERASE_SECTOR, resion);		/* Erase the block */
(0959) 				scl = ecl = nxt;
(0960) 			}
(0961) #endif
(0962) 			clst = nxt;	/* Next cluster */
    006E6 802E      LDD	R2,Y+6
    006E7 803F      LDD	R3,Y+7
    006E8 8448      LDD	R4,Y+8
    006E9 8459      LDD	R5,Y+9
    006EA 8A2A      STD	Y+18,R2
    006EB 8A3B      STD	Y+19,R3
    006EC 8A4C      STD	Y+20,R4
    006ED 8A5D      STD	Y+21,R5
    006EE 01F6      MOVW	R30,R12
    006EF 9676      ADIW	R30,0x16
    006F0 8020      LD	R2,Z
    006F1 8031      LDD	R3,Z+1
    006F2 8042      LDD	R4,Z+2
    006F3 8053      LDD	R5,Z+3
    006F4 886A      LDD	R6,Y+18
    006F5 887B      LDD	R7,Y+19
    006F6 888C      LDD	R8,Y+20
    006F7 889D      LDD	R9,Y+21
    006F8 1462      CP	R6,R2
    006F9 0473      CPC	R7,R3
    006FA 0484      CPC	R8,R4
    006FB 0495      CPC	R9,R5
    006FC F408      BCC	0x06FE
    006FD CF7A      RJMP	0x0678
(0963) 		}
(0964) 	}
(0965) 
(0966) 	return res;
    006FE 2D0A      MOV	R16,R10
    006FF 962A      ADIW	R28,0xA
    00700 940E 27C0 CALL	pop_xgsetF03C
    00702 9622      ADIW	R28,2
    00703 9508      RET
ff.c:create_chain:
  res                  --> R10
  scl                  --> Y,+14
  cs                   --> Y,+10
  ncl                  --> Y,+6
  clst                 --> Y,+32
  fs                   --> R12
    00704 933A      ST	-Y,R19
    00705 932A      ST	-Y,R18
    00706 940E 277C CALL	push_xgsetF0FC
    00708 0168      MOVW	R12,R16
    00709 9766      SBIW	R28,0x16
(0967) }
(0968) #endif
(0969) 
(0970) 
(0971) 
(0972) 
(0973) /*-----------------------------------------------------------------------*/
(0974) /* FAT handling - Stretch or Create a cluster chain                      */
(0975) /*-----------------------------------------------------------------------*/
(0976) #if !_FS_READONLY
(0977) static
(0978) DWORD create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
(0979) 	FATFS *fs,			/* File system object */
(0980) 	DWORD clst			/* Cluster# to stretch. 0 means create a new chain. */
(0981) )
(0982) {
(0983) 	DWORD cs, ncl, scl;
(0984) 	FRESULT res;
(0985) 
(0986) 
(0987) 	if (clst == 0) {		/* Create a new chain */
    0070A A028      LDD	R2,Y+32
    0070B A039      LDD	R3,Y+33
    0070C A04A      LDD	R4,Y+34
    0070D A05B      LDD	R5,Y+35
    0070E 9488      BCLR	0
    0070F 2022      TST	R2
    00710 0432      CPC	R3,R2
    00711 0442      CPC	R4,R2
    00712 0452      CPC	R5,R2
    00713 F559      BNE	0x073F
(0988) 		scl = fs->last_clust;			/* Get suggested start point */
    00714 01F6      MOVW	R30,R12
    00715 963A      ADIW	R30,0xA
    00716 8020      LD	R2,Z
    00717 8031      LDD	R3,Z+1
    00718 8042      LDD	R4,Z+2
    00719 8053      LDD	R5,Z+3
    0071A 862E      STD	Y+14,R2
    0071B 863F      STD	Y+15,R3
    0071C 8A48      STD	Y+16,R4
    0071D 8A59      STD	Y+17,R5
(0989) 		if (!scl || scl >= fs->n_fatent) scl = 1;
    0071E 842E      LDD	R2,Y+14
    0071F 843F      LDD	R3,Y+15
    00720 8848      LDD	R4,Y+16
    00721 8859      LDD	R5,Y+17
    00722 9488      BCLR	0
    00723 2022      TST	R2
    00724 0432      CPC	R3,R2
    00725 0442      CPC	R4,R2
    00726 0452      CPC	R5,R2
    00727 F081      BEQ	0x0738
    00728 01F6      MOVW	R30,R12
    00729 9676      ADIW	R30,0x16
    0072A 8020      LD	R2,Z
    0072B 8031      LDD	R3,Z+1
    0072C 8042      LDD	R4,Z+2
    0072D 8053      LDD	R5,Z+3
    0072E 846E      LDD	R6,Y+14
    0072F 847F      LDD	R7,Y+15
    00730 8888      LDD	R8,Y+16
    00731 8899      LDD	R9,Y+17
    00732 1462      CP	R6,R2
    00733 0473      CPC	R7,R3
    00734 0484      CPC	R8,R4
    00735 0495      CPC	R9,R5
    00736 F408      BCC	0x0738
    00737 C040      RJMP	0x0778
    00738 E081      LDI	R24,1
    00739 878E      STD	Y+14,R24
    0073A E080      LDI	R24,0
    0073B 878F      STD	Y+15,R24
    0073C 8B88      STD	Y+16,R24
    0073D 8B89      STD	Y+17,R24
(0990) 	}
    0073E C039      RJMP	0x0778
(0991) 	else {					/* Stretch the current chain */
(0992) 		cs = get_fat(fs, clst);			/* Check the cluster status */
    0073F A028      LDD	R2,Y+32
    00740 A039      LDD	R3,Y+33
    00741 A04A      LDD	R4,Y+34
    00742 A05B      LDD	R5,Y+35
    00743 8248      ST	Y,R4
    00744 8259      STD	Y+1,R5
    00745 0191      MOVW	R18,R2
    00746 0186      MOVW	R16,R12
    00747 DBFA      RCALL	_get_fat
    00748 870A      STD	Y+10,R16
    00749 871B      STD	Y+11,R17
    0074A 872C      STD	Y+12,R18
    0074B 873D      STD	Y+13,R19
(0993) 		if (cs < 2) return 1;			/* It is an invalid cluster */
    0074C E042      LDI	R20,2
    0074D E050      LDI	R21,0
    0074E E060      LDI	R22,0
    0074F E070      LDI	R23,0
    00750 842A      LDD	R2,Y+10
    00751 843B      LDD	R3,Y+11
    00752 844C      LDD	R4,Y+12
    00753 845D      LDD	R5,Y+13
    00754 1624      CP	R2,R20
    00755 0635      CPC	R3,R21
    00756 0646      CPC	R4,R22
    00757 0657      CPC	R5,R23
    00758 F428      BCC	0x075E
    00759 E001      LDI	R16,1
    0075A E010      LDI	R17,0
    0075B E020      LDI	R18,0
    0075C E030      LDI	R19,0
    0075D C119      RJMP	0x0877
(0994) 		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
    0075E 01F6      MOVW	R30,R12
    0075F 9676      ADIW	R30,0x16
    00760 8020      LD	R2,Z
    00761 8031      LDD	R3,Z+1
    00762 8042      LDD	R4,Z+2
    00763 8053      LDD	R5,Z+3
    00764 846A      LDD	R6,Y+10
    00765 847B      LDD	R7,Y+11
    00766 848C      LDD	R8,Y+12
    00767 849D      LDD	R9,Y+13
    00768 1462      CP	R6,R2
    00769 0473      CPC	R7,R3
    0076A 0484      CPC	R8,R4
    0076B 0495      CPC	R9,R5
    0076C F418      BCC	0x0770
    0076D 0183      MOVW	R16,R6
    0076E 0194      MOVW	R18,R8
    0076F C107      RJMP	0x0877
(0995) 		scl = clst;
    00770 A028      LDD	R2,Y+32
    00771 A039      LDD	R3,Y+33
    00772 A04A      LDD	R4,Y+34
    00773 A05B      LDD	R5,Y+35
    00774 862E      STD	Y+14,R2
    00775 863F      STD	Y+15,R3
    00776 8A48      STD	Y+16,R4
    00777 8A59      STD	Y+17,R5
(0996) 	}
(0997) 
(0998) 	ncl = scl;				/* Start cluster */
    00778 842E      LDD	R2,Y+14
    00779 843F      LDD	R3,Y+15
    0077A 8848      LDD	R4,Y+16
    0077B 8859      LDD	R5,Y+17
    0077C 822E      STD	Y+6,R2
    0077D 823F      STD	Y+7,R3
    0077E 8648      STD	Y+8,R4
    0077F 8659      STD	Y+9,R5
(0999) 	for (;;) {
(1000) 		ncl++;							/* Next cluster */
    00780 E041      LDI	R20,1
    00781 E050      LDI	R21,0
    00782 E060      LDI	R22,0
    00783 E070      LDI	R23,0
    00784 802E      LDD	R2,Y+6
    00785 803F      LDD	R3,Y+7
    00786 8448      LDD	R4,Y+8
    00787 8459      LDD	R5,Y+9
    00788 0E24      ADD	R2,R20
    00789 1E35      ADC	R3,R21
    0078A 1E46      ADC	R4,R22
    0078B 1E57      ADC	R5,R23
    0078C 822E      STD	Y+6,R2
    0078D 823F      STD	Y+7,R3
    0078E 8648      STD	Y+8,R4
    0078F 8659      STD	Y+9,R5
(1001) 		if (ncl >= fs->n_fatent) {		/* Wrap around */
    00790 01F6      MOVW	R30,R12
    00791 9676      ADIW	R30,0x16
    00792 8020      LD	R2,Z
    00793 8031      LDD	R3,Z+1
    00794 8042      LDD	R4,Z+2
    00795 8053      LDD	R5,Z+3
    00796 806E      LDD	R6,Y+6
    00797 807F      LDD	R7,Y+7
    00798 8488      LDD	R8,Y+8
    00799 8499      LDD	R9,Y+9
    0079A 1462      CP	R6,R2
    0079B 0473      CPC	R7,R3
    0079C 0484      CPC	R8,R4
    0079D 0495      CPC	R9,R5
    0079E F0C0      BCS	0x07B7
(1002) 			ncl = 2;
    0079F E082      LDI	R24,2
    007A0 838E      STD	Y+6,R24
    007A1 E080      LDI	R24,0
    007A2 838F      STD	Y+7,R24
    007A3 8788      STD	Y+8,R24
    007A4 8789      STD	Y+9,R24
(1003) 			if (ncl > scl) return 0;	/* No free cluster */
    007A5 842E      LDD	R2,Y+14
    007A6 843F      LDD	R3,Y+15
    007A7 8848      LDD	R4,Y+16
    007A8 8859      LDD	R5,Y+17
    007A9 806E      LDD	R6,Y+6
    007AA 807F      LDD	R7,Y+7
    007AB 8488      LDD	R8,Y+8
    007AC 8499      LDD	R9,Y+9
    007AD 1426      CP	R2,R6
    007AE 0437      CPC	R3,R7
    007AF 0448      CPC	R4,R8
    007B0 0459      CPC	R5,R9
    007B1 F428      BCC	0x07B7
    007B2 E000      LDI	R16,0
    007B3 E010      LDI	R17,0
    007B4 E020      LDI	R18,0
    007B5 E030      LDI	R19,0
    007B6 C0C0      RJMP	0x0877
(1004) 		}
(1005) 		cs = get_fat(fs, ncl);			/* Get the cluster status */
    007B7 802E      LDD	R2,Y+6
    007B8 803F      LDD	R3,Y+7
    007B9 8448      LDD	R4,Y+8
    007BA 8459      LDD	R5,Y+9
    007BB 8248      ST	Y,R4
    007BC 8259      STD	Y+1,R5
    007BD 0191      MOVW	R18,R2
    007BE 0186      MOVW	R16,R12
    007BF DB82      RCALL	_get_fat
    007C0 870A      STD	Y+10,R16
    007C1 871B      STD	Y+11,R17
    007C2 872C      STD	Y+12,R18
    007C3 873D      STD	Y+13,R19
(1006) 		if (cs == 0) break;				/* Found a free cluster */
    007C4 842A      LDD	R2,Y+10
    007C5 843B      LDD	R3,Y+11
    007C6 844C      LDD	R4,Y+12
    007C7 845D      LDD	R5,Y+13
    007C8 9488      BCLR	0
    007C9 2022      TST	R2
    007CA 0432      CPC	R3,R2
    007CB 0442      CPC	R4,R2
    007CC 0452      CPC	R5,R2
    007CD F409      BNE	0x07CF
    007CE C02E      RJMP	0x07FD
(1007) 		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
    007CF EF4F      LDI	R20,0xFF
    007D0 EF5F      LDI	R21,0xFF
    007D1 EF6F      LDI	R22,0xFF
    007D2 EF7F      LDI	R23,0xFF
    007D3 842A      LDD	R2,Y+10
    007D4 843B      LDD	R3,Y+11
    007D5 844C      LDD	R4,Y+12
    007D6 845D      LDD	R5,Y+13
    007D7 1624      CP	R2,R20
    007D8 0635      CPC	R3,R21
    007D9 0646      CPC	R4,R22
    007DA 0657      CPC	R5,R23
    007DB F049      BEQ	0x07E5
    007DC E041      LDI	R20,1
    007DD E050      LDI	R21,0
    007DE E060      LDI	R22,0
    007DF E070      LDI	R23,0
    007E0 1624      CP	R2,R20
    007E1 0635      CPC	R3,R21
    007E2 0646      CPC	R4,R22
    007E3 0657      CPC	R5,R23
    007E4 F429      BNE	0x07EA
(1008) 			return cs;
    007E5 850A      LDD	R16,Y+10
    007E6 851B      LDD	R17,Y+11
    007E7 852C      LDD	R18,Y+12
    007E8 853D      LDD	R19,Y+13
    007E9 C08D      RJMP	0x0877
(1009) 		if (ncl == scl) return 0;		/* No free cluster */
    007EA 842E      LDD	R2,Y+14
    007EB 843F      LDD	R3,Y+15
    007EC 8848      LDD	R4,Y+16
    007ED 8859      LDD	R5,Y+17
    007EE 806E      LDD	R6,Y+6
    007EF 807F      LDD	R7,Y+7
    007F0 8488      LDD	R8,Y+8
    007F1 8499      LDD	R9,Y+9
    007F2 1462      CP	R6,R2
    007F3 0473      CPC	R7,R3
    007F4 0484      CPC	R8,R4
    007F5 0495      CPC	R9,R5
    007F6 F009      BEQ	0x07F8
    007F7 CF88      RJMP	0x0780
    007F8 E000      LDI	R16,0
    007F9 E010      LDI	R17,0
    007FA E020      LDI	R18,0
    007FB E030      LDI	R19,0
    007FC C07A      RJMP	0x0877
(1010) 	}
(1011) 
(1012) 	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
    007FD EF8F      LDI	R24,0xFF
    007FE 838A      STD	Y+2,R24
    007FF 838B      STD	Y+3,R24
    00800 838C      STD	Y+4,R24
    00801 E08F      LDI	R24,0xF
    00802 838D      STD	Y+5,R24
    00803 802E      LDD	R2,Y+6
    00804 803F      LDD	R3,Y+7
    00805 8448      LDD	R4,Y+8
    00806 8459      LDD	R5,Y+9
    00807 8248      ST	Y,R4
    00808 8259      STD	Y+1,R5
    00809 0191      MOVW	R18,R2
    0080A 0186      MOVW	R16,R12
    0080B DC86      RCALL	_put_fat
    0080C 2EA0      MOV	R10,R16
(1013) 	if (res == FR_OK && clst != 0) {
    0080D 2300      TST	R16
    0080E F4E1      BNE	0x082B
    0080F A028      LDD	R2,Y+32
    00810 A039      LDD	R3,Y+33
    00811 A04A      LDD	R4,Y+34
    00812 A05B      LDD	R5,Y+35
    00813 9488      BCLR	0
    00814 2022      TST	R2
    00815 0432      CPC	R3,R2
    00816 0442      CPC	R4,R2
    00817 0452      CPC	R5,R2
    00818 F091      BEQ	0x082B
(1014) 		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
    00819 802E      LDD	R2,Y+6
    0081A 803F      LDD	R3,Y+7
    0081B 8448      LDD	R4,Y+8
    0081C 8459      LDD	R5,Y+9
    0081D 822A      STD	Y+2,R2
    0081E 823B      STD	Y+3,R3
    0081F 824C      STD	Y+4,R4
    00820 825D      STD	Y+5,R5
    00821 A028      LDD	R2,Y+32
    00822 A039      LDD	R3,Y+33
    00823 A04A      LDD	R4,Y+34
    00824 A05B      LDD	R5,Y+35
    00825 8248      ST	Y,R4
    00826 8259      STD	Y+1,R5
    00827 0191      MOVW	R18,R2
    00828 0186      MOVW	R16,R12
    00829 DC68      RCALL	_put_fat
    0082A 2EA0      MOV	R10,R16
(1015) 	}
(1016) 	if (res == FR_OK) {
    0082B 20AA      TST	R10
    0082C F009      BEQ	0x082E
    0082D C02E      RJMP	0x085C
(1017) 		fs->last_clust = ncl;			/* Update FSINFO */
    0082E 802E      LDD	R2,Y+6
    0082F 803F      LDD	R3,Y+7
    00830 8448      LDD	R4,Y+8
    00831 8459      LDD	R5,Y+9
    00832 01F6      MOVW	R30,R12
    00833 8622      STD	Z+10,R2
    00834 8633      STD	Z+11,R3
    00835 8644      STD	Z+12,R4
    00836 8655      STD	Z+13,R5
(1018) 		if (fs->free_clust != 0xFFFFFFFF) {
    00837 EF4F      LDI	R20,0xFF
    00838 EF5F      LDI	R21,0xFF
    00839 EF6F      LDI	R22,0xFF
    0083A EF7F      LDI	R23,0xFF
    0083B 8426      LDD	R2,Z+14
    0083C 8437      LDD	R3,Z+15
    0083D 8840      LDD	R4,Z+16
    0083E 8851      LDD	R5,Z+17
    0083F 1624      CP	R2,R20
    00840 0635      CPC	R3,R21
    00841 0646      CPC	R4,R22
    00842 0657      CPC	R5,R23
    00843 F179      BEQ	0x0873
(1019) 			fs->free_clust--;
    00844 01CF      MOVW	R24,R30
    00845 960E      ADIW	R24,0xE
    00846 017C      MOVW	R14,R24
    00847 E041      LDI	R20,1
    00848 E050      LDI	R21,0
    00849 E060      LDI	R22,0
    0084A E070      LDI	R23,0
    0084B 01FC      MOVW	R30,R24
    0084C 8020      LD	R2,Z
    0084D 8031      LDD	R3,Z+1
    0084E 8042      LDD	R4,Z+2
    0084F 8053      LDD	R5,Z+3
    00850 1A24      SUB	R2,R20
    00851 0A35      SBC	R3,R21
    00852 0A46      SBC	R4,R22
    00853 0A57      SBC	R5,R23
    00854 8220      ST	Z,R2
    00855 8231      STD	Z+1,R3
    00856 8242      STD	Z+2,R4
    00857 8253      STD	Z+3,R5
(1020) 			fs->fsi_flag = 1;
    00858 E081      LDI	R24,1
    00859 01F6      MOVW	R30,R12
    0085A 8385      STD	Z+5,R24
(1021) 		}
(1022) 	} else {
    0085B C017      RJMP	0x0873
(1023) 		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
    0085C 2D8A      MOV	R24,R10
    0085D 3081      CPI	R24,1
    0085E F431      BNE	0x0865
    0085F EF8F      LDI	R24,0xFF
    00860 8B8A      STD	Y+18,R24
    00861 8B8B      STD	Y+19,R24
    00862 8B8C      STD	Y+20,R24
    00863 8B8D      STD	Y+21,R24
    00864 C006      RJMP	0x086B
    00865 E081      LDI	R24,1
    00866 8B8A      STD	Y+18,R24
    00867 E080      LDI	R24,0
    00868 8B8B      STD	Y+19,R24
    00869 8B8C      STD	Y+20,R24
    0086A 8B8D      STD	Y+21,R24
    0086B 882A      LDD	R2,Y+18
    0086C 883B      LDD	R3,Y+19
    0086D 884C      LDD	R4,Y+20
    0086E 885D      LDD	R5,Y+21
    0086F 822E      STD	Y+6,R2
    00870 823F      STD	Y+7,R3
    00871 8648      STD	Y+8,R4
    00872 8659      STD	Y+9,R5
(1024) 	}
(1025) 
(1026) 	return ncl;		/* Return new cluster number or error code */
    00873 810E      LDD	R16,Y+6
    00874 811F      LDD	R17,Y+7
    00875 8528      LDD	R18,Y+8
    00876 8539      LDD	R19,Y+9
    00877 9666      ADIW	R28,0x16
    00878 940E 2771 CALL	pop_xgsetF0FC
    0087A 9622      ADIW	R28,2
    0087B 9508      RET
ff.c:clmt_clust:
  tbl                  --> R10
  cl                   --> Y,+4
  ncl                  --> Y,+0
  ofs                  --> Y,+12
  fp                   --> R12
    0087C 933A      ST	-Y,R19
    0087D 932A      ST	-Y,R18
    0087E 940E 2782 CALL	push_xgset003C
    00880 0168      MOVW	R12,R16
    00881 9728      SBIW	R28,0x8
(1027) }
(1028) #endif /* !_FS_READONLY */
(1029) 
(1030) 
(1031) 
(1032) /*-----------------------------------------------------------------------*/
(1033) /* FAT handling - Convert offset into cluster with link map table        */
(1034) /*-----------------------------------------------------------------------*/
(1035) 
(1036) #if _USE_FASTSEEK
(1037) static
(1038) DWORD clmt_clust (	/* <2:Error, >=2:Cluster number */
(1039) 	FIL* fp,		/* Pointer to the file object */
(1040) 	DWORD ofs		/* File offset to be converted to cluster# */
(1041) )
(1042) {
(1043) 	DWORD cl, ncl, *tbl;
(1044) 
(1045) 
(1046) 	tbl = fp->cltbl + 1;	/* Top of CLMT */
    00882 01F6      MOVW	R30,R12
    00883 96B0      ADIW	R30,0x20
    00884 8180      LD	R24,Z
    00885 8191      LDD	R25,Z+1
    00886 9604      ADIW	R24,4
    00887 015C      MOVW	R10,R24
(1047) 	cl = ofs / SS(fp->fs) / fp->fs->csize;	/* Cluster order from top of the file */
    00888 E089      LDI	R24,0x9
    00889 E090      LDI	R25,0
    0088A 850C      LDD	R16,Y+12
    0088B 851D      LDD	R17,Y+13
    0088C 852E      LDD	R18,Y+14
    0088D 853F      LDD	R19,Y+15
    0088E 938A      ST	-Y,R24
    0088F 940E 280A CALL	lsr32
    00891 01F6      MOVW	R30,R12
    00892 93AF      PUSH	R26
    00893 93BF      PUSH	R27
    00894 81A0      LD	R26,Z
    00895 81B1      LDD	R27,Z+1
    00896 01FD      MOVW	R30,R26
    00897 91BF      POP	R27
    00898 91AF      POP	R26
    00899 9632      ADIW	R30,2
    0089A 8020      LD	R2,Z
    0089B 2433      CLR	R3
    0089C 2444      CLR	R4
    0089D 2455      CLR	R5
    0089E 925A      ST	-Y,R5
    0089F 924A      ST	-Y,R4
    008A0 923A      ST	-Y,R3
    008A1 922A      ST	-Y,R2
    008A2 940E 26AE CALL	div32u
    008A4 830C      STD	Y+4,R16
    008A5 831D      STD	Y+5,R17
    008A6 832E      STD	Y+6,R18
    008A7 833F      STD	Y+7,R19
(1048) 	for (;;) {
(1049) 		ncl = *tbl++;			/* Number of cluters in the fragment */
    008A8 01F5      MOVW	R30,R10
    008A9 9021      LD	R2,Z+
    008AA 9031      LD	R3,Z+
    008AB 9041      LD	R4,Z+
    008AC 9051      LD	R5,Z+
    008AD 015F      MOVW	R10,R30
    008AE 8228      ST	Y,R2
    008AF 8239      STD	Y+1,R3
    008B0 824A      STD	Y+2,R4
    008B1 825B      STD	Y+3,R5
(1050) 		if (!ncl) return 0;		/* End of table? (error) */
    008B2 8028      LD	R2,Y
    008B3 8039      LDD	R3,Y+1
    008B4 804A      LDD	R4,Y+2
    008B5 805B      LDD	R5,Y+3
    008B6 9488      BCLR	0
    008B7 2022      TST	R2
    008B8 0432      CPC	R3,R2
    008B9 0442      CPC	R4,R2
    008BA 0452      CPC	R5,R2
    008BB F429      BNE	0x08C1
    008BC E000      LDI	R16,0
    008BD E010      LDI	R17,0
    008BE E020      LDI	R18,0
    008BF E030      LDI	R19,0
    008C0 C02F      RJMP	0x08F0
(1051) 		if (cl < ncl) break;	/* In this fragment? */
    008C1 8028      LD	R2,Y
    008C2 8039      LDD	R3,Y+1
    008C3 804A      LDD	R4,Y+2
    008C4 805B      LDD	R5,Y+3
    008C5 806C      LDD	R6,Y+4
    008C6 807D      LDD	R7,Y+5
    008C7 808E      LDD	R8,Y+6
    008C8 809F      LDD	R9,Y+7
    008C9 1462      CP	R6,R2
    008CA 0473      CPC	R7,R3
    008CB 0484      CPC	R8,R4
    008CC 0495      CPC	R9,R5
    008CD F408      BCC	0x08CF
    008CE C014      RJMP	0x08E3
(1052) 		cl -= ncl; tbl++;		/* Next fragment */
    008CF 8028      LD	R2,Y
    008D0 8039      LDD	R3,Y+1
    008D1 804A      LDD	R4,Y+2
    008D2 805B      LDD	R5,Y+3
    008D3 806C      LDD	R6,Y+4
    008D4 807D      LDD	R7,Y+5
    008D5 808E      LDD	R8,Y+6
    008D6 809F      LDD	R9,Y+7
    008D7 1862      SUB	R6,R2
    008D8 0873      SBC	R7,R3
    008D9 0884      SBC	R8,R4
    008DA 0895      SBC	R9,R5
    008DB 826C      STD	Y+4,R6
    008DC 827D      STD	Y+5,R7
    008DD 828E      STD	Y+6,R8
    008DE 829F      STD	Y+7,R9
    008DF 01C5      MOVW	R24,R10
    008E0 9604      ADIW	R24,4
    008E1 015C      MOVW	R10,R24
    008E2 CFC5      RJMP	0x08A8
(1053) 	}
(1054) 	return cl + *tbl;	/* Return the cluster number */
    008E3 01F5      MOVW	R30,R10
    008E4 8020      LD	R2,Z
    008E5 8031      LDD	R3,Z+1
    008E6 8042      LDD	R4,Z+2
    008E7 8053      LDD	R5,Z+3
    008E8 810C      LDD	R16,Y+4
    008E9 811D      LDD	R17,Y+5
    008EA 812E      LDD	R18,Y+6
    008EB 813F      LDD	R19,Y+7
    008EC 0D02      ADD	R16,R2
    008ED 1D13      ADC	R17,R3
    008EE 1D24      ADC	R18,R4
    008EF 1D35      ADC	R19,R5
    008F0 9628      ADIW	R28,0x8
    008F1 940E 275C CALL	pop_xgset003C
    008F3 9622      ADIW	R28,2
    008F4 9508      RET
ff.c:dir_sdi:
  ic                   --> R14
  clst                 --> Y,+2
  idx                  --> R12
  dj                   --> R10
    008F5 940E 277C CALL	push_xgsetF0FC
    008F7 0169      MOVW	R12,R18
    008F8 0158      MOVW	R10,R16
    008F9 9726      SBIW	R28,6
(1055) }
(1056) #endif	/* _USE_FASTSEEK */
(1057) 
(1058) 
(1059) 
(1060) /*-----------------------------------------------------------------------*/
(1061) /* Directory handling - Set directory index                              */
(1062) /*-----------------------------------------------------------------------*/
(1063) 
(1064) static
(1065) FRESULT dir_sdi (
(1066) 	DIR *dj,		/* Pointer to directory object */
(1067) 	WORD idx		/* Directory index number */
(1068) )
(1069) {
(1070) 	DWORD clst;
(1071) 	WORD ic;
(1072) 
(1073) 
(1074) 	dj->index = idx;
    008FA 01F5      MOVW	R30,R10
    008FB 82D5      STD	Z+5,R13
    008FC 82C4      STD	Z+4,R12
(1075) 	clst = dj->sclust;
    008FD 9636      ADIW	R30,6
    008FE 8020      LD	R2,Z
    008FF 8031      LDD	R3,Z+1
    00900 8042      LDD	R4,Z+2
    00901 8053      LDD	R5,Z+3
    00902 822A      STD	Y+2,R2
    00903 823B      STD	Y+3,R3
    00904 824C      STD	Y+4,R4
    00905 825D      STD	Y+5,R5
(1076) 	if (clst == 1 || clst >= dj->fs->n_fatent)	/* Check start cluster range */
    00906 E041      LDI	R20,1
    00907 E050      LDI	R21,0
    00908 E060      LDI	R22,0
    00909 E070      LDI	R23,0
    0090A 802A      LDD	R2,Y+2
    0090B 803B      LDD	R3,Y+3
    0090C 804C      LDD	R4,Y+4
    0090D 805D      LDD	R5,Y+5
    0090E 1624      CP	R2,R20
    0090F 0635      CPC	R3,R21
    00910 0646      CPC	R4,R22
    00911 0657      CPC	R5,R23
    00912 F089      BEQ	0x0924
    00913 01F5      MOVW	R30,R10
    00914 81A0      LD	R26,Z
    00915 81B1      LDD	R27,Z+1
    00916 9656      ADIW	R26,0x16
    00917 902D      LD	R2,X+
    00918 903D      LD	R3,X+
    00919 904D      LD	R4,X+
    0091A 905C      LD	R5,X
    0091B 806A      LDD	R6,Y+2
    0091C 807B      LDD	R7,Y+3
    0091D 808C      LDD	R8,Y+4
    0091E 809D      LDD	R9,Y+5
    0091F 1462      CP	R6,R2
    00920 0473      CPC	R7,R3
    00921 0484      CPC	R8,R4
    00922 0495      CPC	R9,R5
    00923 F010      BCS	0x0926
(1077) 		return FR_INT_ERR;
    00924 E002      LDI	R16,2
    00925 C0D6      RJMP	0x09FC
(1078) 	if (!clst && dj->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
    00926 802A      LDD	R2,Y+2
    00927 803B      LDD	R3,Y+3
    00928 804C      LDD	R4,Y+4
    00929 805D      LDD	R5,Y+5
    0092A 9488      BCLR	0
    0092B 2022      TST	R2
    0092C 0432      CPC	R3,R2
    0092D 0442      CPC	R4,R2
    0092E 0452      CPC	R5,R2
    0092F F479      BNE	0x093F
    00930 01F5      MOVW	R30,R10
    00931 81A0      LD	R26,Z
    00932 81B1      LDD	R27,Z+1
    00933 918C      LD	R24,X
    00934 3083      CPI	R24,3
    00935 F449      BNE	0x093F
(1079) 		clst = dj->fs->dirbase;
    00936 9692      ADIW	R26,0x22
    00937 902D      LD	R2,X+
    00938 903D      LD	R3,X+
    00939 904D      LD	R4,X+
    0093A 905C      LD	R5,X
    0093B 822A      STD	Y+2,R2
    0093C 823B      STD	Y+3,R3
    0093D 824C      STD	Y+4,R4
    0093E 825D      STD	Y+5,R5
(1080) 
(1081) 	if (clst == 0) {	/* Static table (root-dir in FAT12/16) */
    0093F 802A      LDD	R2,Y+2
    00940 803B      LDD	R3,Y+3
    00941 804C      LDD	R4,Y+4
    00942 805D      LDD	R5,Y+5
    00943 9488      BCLR	0
    00944 2022      TST	R2
    00945 0432      CPC	R3,R2
    00946 0442      CPC	R4,R2
    00947 0452      CPC	R5,R2
    00948 F009      BEQ	0x094A
    00949 C02B      RJMP	0x0975
(1082) 		dj->clust = clst;
    0094A 01F5      MOVW	R30,R10
    0094B 8622      STD	Z+10,R2
    0094C 8633      STD	Z+11,R3
    0094D 8644      STD	Z+12,R4
    0094E 8655      STD	Z+13,R5
(1083) 		if (idx >= dj->fs->n_rootdir)		/* Index is out of range */
    0094F 81A0      LD	R26,Z
    00950 81B1      LDD	R27,Z+1
    00951 9618      ADIW	R26,0x8
    00952 902D      LD	R2,X+
    00953 903C      LD	R3,X
    00954 14C2      CP	R12,R2
    00955 04D3      CPC	R13,R3
    00956 F010      BCS	0x0959
(1084) 			return FR_INT_ERR;
    00957 E002      LDI	R16,2
    00958 C0A3      RJMP	0x09FC
(1085) 		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
    00959 0116      MOVW	R2,R12
    0095A 9436      LSR	R3
    0095B 9427      ROR	R2
    0095C 9436      LSR	R3
    0095D 9427      ROR	R2
    0095E 9436      LSR	R3
    0095F 9427      ROR	R2
    00960 9436      LSR	R3
    00961 9427      ROR	R2
    00962 2444      CLR	R4
    00963 2455      CLR	R5
    00964 01F5      MOVW	R30,R10
    00965 81A0      LD	R26,Z
    00966 81B1      LDD	R27,Z+1
    00967 9692      ADIW	R26,0x22
    00968 906D      LD	R6,X+
    00969 907D      LD	R7,X+
    0096A 908D      LD	R8,X+
    0096B 909C      LD	R9,X
    0096C 0C62      ADD	R6,R2
    0096D 1C73      ADC	R7,R3
    0096E 1C84      ADC	R8,R4
    0096F 1C95      ADC	R9,R5
    00970 8666      STD	Z+14,R6
    00971 8677      STD	Z+15,R7
    00972 8A80      STD	Z+16,R8
    00973 8A91      STD	Z+17,R9
(1086) 	}
    00974 C076      RJMP	0x09EB
(1087) 	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
(1088) 		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
    00975 01F5      MOVW	R30,R10
    00976 93AF      PUSH	R26
    00977 93BF      PUSH	R27
    00978 81A0      LD	R26,Z
    00979 81B1      LDD	R27,Z+1
    0097A 01FD      MOVW	R30,R26
    0097B 91BF      POP	R27
    0097C 91AF      POP	R26
    0097D 8022      LDD	R2,Z+2
    0097E E180      LDI	R24,0x10
    0097F 9D82      MUL	R24,R2
    00980 0170      MOVW	R14,R0
    00981 C040      RJMP	0x09C2
(1089) 		while (idx >= ic) {	/* Follow cluster chain */
(1090) 			clst = get_fat(dj->fs, clst);				/* Get next cluster */
    00982 802A      LDD	R2,Y+2
    00983 803B      LDD	R3,Y+3
    00984 804C      LDD	R4,Y+4
    00985 805D      LDD	R5,Y+5
    00986 8248      ST	Y,R4
    00987 8259      STD	Y+1,R5
    00988 0191      MOVW	R18,R2
    00989 01F5      MOVW	R30,R10
    0098A 8100      LD	R16,Z
    0098B 8111      LDD	R17,Z+1
    0098C D9B5      RCALL	_get_fat
    0098D 830A      STD	Y+2,R16
    0098E 831B      STD	Y+3,R17
    0098F 832C      STD	Y+4,R18
    00990 833D      STD	Y+5,R19
(1091) 			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
    00991 EF4F      LDI	R20,0xFF
    00992 EF5F      LDI	R21,0xFF
    00993 EF6F      LDI	R22,0xFF
    00994 EF7F      LDI	R23,0xFF
    00995 802A      LDD	R2,Y+2
    00996 803B      LDD	R3,Y+3
    00997 804C      LDD	R4,Y+4
    00998 805D      LDD	R5,Y+5
    00999 1624      CP	R2,R20
    0099A 0635      CPC	R3,R21
    0099B 0646      CPC	R4,R22
    0099C 0657      CPC	R5,R23
    0099D F411      BNE	0x09A0
    0099E E001      LDI	R16,1
    0099F C05C      RJMP	0x09FC
(1092) 			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
    009A0 E042      LDI	R20,2
    009A1 E050      LDI	R21,0
    009A2 E060      LDI	R22,0
    009A3 E070      LDI	R23,0
    009A4 802A      LDD	R2,Y+2
    009A5 803B      LDD	R3,Y+3
    009A6 804C      LDD	R4,Y+4
    009A7 805D      LDD	R5,Y+5
    009A8 1624      CP	R2,R20
    009A9 0635      CPC	R3,R21
    009AA 0646      CPC	R4,R22
    009AB 0657      CPC	R5,R23
    009AC F088      BCS	0x09BE
    009AD 01F5      MOVW	R30,R10
    009AE 81A0      LD	R26,Z
    009AF 81B1      LDD	R27,Z+1
    009B0 9656      ADIW	R26,0x16
    009B1 902D      LD	R2,X+
    009B2 903D      LD	R3,X+
    009B3 904D      LD	R4,X+
    009B4 905C      LD	R5,X
    009B5 806A      LDD	R6,Y+2
    009B6 807B      LDD	R7,Y+3
    009B7 808C      LDD	R8,Y+4
    009B8 809D      LDD	R9,Y+5
    009B9 1462      CP	R6,R2
    009BA 0473      CPC	R7,R3
    009BB 0484      CPC	R8,R4
    009BC 0495      CPC	R9,R5
    009BD F010      BCS	0x09C0
(1093) 				return FR_INT_ERR;
    009BE E002      LDI	R16,2
    009BF C03C      RJMP	0x09FC
(1094) 			idx -= ic;
    009C0 18CE      SUB	R12,R14
    009C1 08DF      SBC	R13,R15
    009C2 14CE      CP	R12,R14
    009C3 04DF      CPC	R13,R15
    009C4 F008      BCS	0x09C6
    009C5 CFBC      RJMP	0x0982
(1095) 		}
(1096) 		dj->clust = clst;
    009C6 802A      LDD	R2,Y+2
    009C7 803B      LDD	R3,Y+3
    009C8 804C      LDD	R4,Y+4
    009C9 805D      LDD	R5,Y+5
    009CA 01F5      MOVW	R30,R10
    009CB 8622      STD	Z+10,R2
    009CC 8633      STD	Z+11,R3
    009CD 8644      STD	Z+12,R4
    009CE 8655      STD	Z+13,R5
(1097) 		dj->sect = clust2sect(dj->fs, clst) + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
    009CF 8248      ST	Y,R4
    009D0 8259      STD	Y+1,R5
    009D1 0191      MOVW	R18,R2
    009D2 8100      LD	R16,Z
    009D3 8111      LDD	R17,Z+1
    009D4 D91B      RCALL	_clust2sect
    009D5 0116      MOVW	R2,R12
    009D6 9436      LSR	R3
    009D7 9427      ROR	R2
    009D8 9436      LSR	R3
    009D9 9427      ROR	R2
    009DA 9436      LSR	R3
    009DB 9427      ROR	R2
    009DC 9436      LSR	R3
    009DD 9427      ROR	R2
    009DE 2444      CLR	R4
    009DF 2455      CLR	R5
    009E0 0138      MOVW	R6,R16
    009E1 0149      MOVW	R8,R18
    009E2 0C62      ADD	R6,R2
    009E3 1C73      ADC	R7,R3
    009E4 1C84      ADC	R8,R4
    009E5 1C95      ADC	R9,R5
    009E6 01F5      MOVW	R30,R10
    009E7 8666      STD	Z+14,R6
    009E8 8677      STD	Z+15,R7
    009E9 8A80      STD	Z+16,R8
    009EA 8A91      STD	Z+17,R9
(1098) 	}
(1099) 
(1100) 	dj->dir = dj->fs->win + (idx % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;	/* Ptr to the entry in the sector */
    009EB 0196      MOVW	R18,R12
    009EC 702F      ANDI	R18,0xF
    009ED 7030      ANDI	R19,0
    009EE E200      LDI	R16,0x20
    009EF E010      LDI	R17,0
    009F0 940E 2718 CALL	empy16s
    009F2 0118      MOVW	R2,R16
    009F3 01F5      MOVW	R30,R10
    009F4 8180      LD	R24,Z
    009F5 8191      LDD	R25,Z+1
    009F6 968E      ADIW	R24,0x2E
    009F7 0E28      ADD	R2,R24
    009F8 1E39      ADC	R3,R25
    009F9 8A33      STD	Z+19,R3
    009FA 8A22      STD	Z+18,R2
(1101) 
(1102) 	return FR_OK;	/* Seek succeeded */
    009FB 2700      CLR	R16
    009FC 9626      ADIW	R28,6
    009FD 940C 2771 JMP	pop_xgsetF0FC
ff.c:dir_next:
  c                    --> R10
  clst                 --> Y,+2
  i                    --> R12
  stretch              --> R10
  dj                   --> Y,+16
    009FF 940E 26A9 CALL	push_arg4
    00A01 940E 277C CALL	push_xgsetF0FC
    00A03 0159      MOVW	R10,R18
    00A04 9726      SBIW	R28,6
(1103) }
(1104) 
(1105) 
(1106) 
(1107) 
(1108) /*-----------------------------------------------------------------------*/
(1109) /* Directory handling - Move directory index next                        */
(1110) /*-----------------------------------------------------------------------*/
(1111) 
(1112) static
(1113) FRESULT dir_next (	/* FR_OK:Succeeded, FR_NO_FILE:End of table, FR_DENIED:EOT and could not stretch */
(1114) 	DIR *dj,		/* Pointer to directory object */
(1115) 	int stretch		/* 0: Do not stretch table, 1: Stretch table if needed */
(1116) )
(1117) {
(1118) 	DWORD clst;
(1119) 	WORD i;
(1120) 
(1121) 
(1122) 	stretch = stretch;		/* To suppress warning on read-only cfg. */
(1123) 	i = dj->index + 1;
    00A05 89E8      LDD	R30,Y+16
    00A06 89F9      LDD	R31,Y+17
    00A07 8184      LDD	R24,Z+4
    00A08 8195      LDD	R25,Z+5
    00A09 9601      ADIW	R24,1
    00A0A 016C      MOVW	R12,R24
(1124) 	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
    00A0B 3080      CPI	R24,0
    00A0C 0789      CPC	R24,R25
    00A0D F059      BEQ	0x0A19
    00A0E 963E      ADIW	R30,0xE
    00A0F 8020      LD	R2,Z
    00A10 8031      LDD	R3,Z+1
    00A11 8042      LDD	R4,Z+2
    00A12 8053      LDD	R5,Z+3
    00A13 9488      BCLR	0
    00A14 2022      TST	R2
    00A15 0432      CPC	R3,R2
    00A16 0442      CPC	R4,R2
    00A17 0452      CPC	R5,R2
    00A18 F411      BNE	0x0A1B
(1125) 		return FR_NO_FILE;
    00A19 E004      LDI	R16,4
    00A1A C18D      RJMP	0x0BA8
(1126) 
(1127) 	if (!(i % (SS(dj->fs) / SZ_DIR))) {	/* Sector changed? */
    00A1B 01C6      MOVW	R24,R12
    00A1C 708F      ANDI	R24,0xF
    00A1D 7090      ANDI	R25,0
    00A1E 3080      CPI	R24,0
    00A1F 0789      CPC	R24,R25
    00A20 F009      BEQ	0x0A22
    00A21 C170      RJMP	0x0B92
(1128) 		dj->sect++;					/* Next sector */
    00A22 8988      LDD	R24,Y+16
    00A23 8999      LDD	R25,Y+17
    00A24 960E      ADIW	R24,0xE
    00A25 E041      LDI	R20,1
    00A26 E050      LDI	R21,0
    00A27 E060      LDI	R22,0
    00A28 E070      LDI	R23,0
    00A29 01FC      MOVW	R30,R24
    00A2A 8020      LD	R2,Z
    00A2B 8031      LDD	R3,Z+1
    00A2C 8042      LDD	R4,Z+2
    00A2D 8053      LDD	R5,Z+3
    00A2E 0E24      ADD	R2,R20
    00A2F 1E35      ADC	R3,R21
    00A30 1E46      ADC	R4,R22
    00A31 1E57      ADC	R5,R23
    00A32 8220      ST	Z,R2
    00A33 8231      STD	Z+1,R3
    00A34 8242      STD	Z+2,R4
    00A35 8253      STD	Z+3,R5
(1129) 
(1130) 		if (dj->clust == 0) {	/* Static table */
    00A36 89E8      LDD	R30,Y+16
    00A37 89F9      LDD	R31,Y+17
    00A38 963A      ADIW	R30,0xA
    00A39 8020      LD	R2,Z
    00A3A 8031      LDD	R3,Z+1
    00A3B 8042      LDD	R4,Z+2
    00A3C 8053      LDD	R5,Z+3
    00A3D 9488      BCLR	0
    00A3E 2022      TST	R2
    00A3F 0432      CPC	R3,R2
    00A40 0442      CPC	R4,R2
    00A41 0452      CPC	R5,R2
    00A42 F469      BNE	0x0A50
(1131) 			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
    00A43 89E8      LDD	R30,Y+16
    00A44 89F9      LDD	R31,Y+17
    00A45 81A0      LD	R26,Z
    00A46 81B1      LDD	R27,Z+1
    00A47 9618      ADIW	R26,0x8
    00A48 902D      LD	R2,X+
    00A49 903C      LD	R3,X
    00A4A 14C2      CP	R12,R2
    00A4B 04D3      CPC	R13,R3
    00A4C F408      BCC	0x0A4E
    00A4D C144      RJMP	0x0B92
(1132) 				return FR_NO_FILE;
    00A4E E004      LDI	R16,4
    00A4F C158      RJMP	0x0BA8
(1133) 		}
(1134) 		else {					/* Dynamic table */
(1135) 			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
    00A50 89E8      LDD	R30,Y+16
    00A51 89F9      LDD	R31,Y+17
    00A52 93AF      PUSH	R26
    00A53 93BF      PUSH	R27
    00A54 81A0      LD	R26,Z
    00A55 81B1      LDD	R27,Z+1
    00A56 01FD      MOVW	R30,R26
    00A57 91BF      POP	R27
    00A58 91AF      POP	R26
    00A59 8182      LDD	R24,Z+2
    00A5A 2799      CLR	R25
    00A5B 9701      SBIW	R24,1
    00A5C 0116      MOVW	R2,R12
    00A5D 9436      LSR	R3
    00A5E 9427      ROR	R2
    00A5F 9436      LSR	R3
    00A60 9427      ROR	R2
    00A61 9436      LSR	R3
    00A62 9427      ROR	R2
    00A63 9436      LSR	R3
    00A64 9427      ROR	R2
    00A65 2228      AND	R2,R24
    00A66 2239      AND	R3,R25
    00A67 2022      TST	R2
    00A68 F009      BEQ	0x0A6A
    00A69 C128      RJMP	0x0B92
    00A6A 2033      TST	R3
    00A6B F009      BEQ	0x0A6D
    00A6C C125      RJMP	0x0B92
(1136) 				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
    00A6D 89E8      LDD	R30,Y+16
    00A6E 89F9      LDD	R31,Y+17
    00A6F 8422      LDD	R2,Z+10
    00A70 8433      LDD	R3,Z+11
    00A71 8444      LDD	R4,Z+12
    00A72 8455      LDD	R5,Z+13
    00A73 8248      ST	Y,R4
    00A74 8259      STD	Y+1,R5
    00A75 0191      MOVW	R18,R2
    00A76 8100      LD	R16,Z
    00A77 8111      LDD	R17,Z+1
    00A78 D8C9      RCALL	_get_fat
    00A79 830A      STD	Y+2,R16
    00A7A 831B      STD	Y+3,R17
    00A7B 832C      STD	Y+4,R18
    00A7C 833D      STD	Y+5,R19
(1137) 				if (clst <= 1) return FR_INT_ERR;
    00A7D E041      LDI	R20,1
    00A7E E050      LDI	R21,0
    00A7F E060      LDI	R22,0
    00A80 E070      LDI	R23,0
    00A81 802A      LDD	R2,Y+2
    00A82 803B      LDD	R3,Y+3
    00A83 804C      LDD	R4,Y+4
    00A84 805D      LDD	R5,Y+5
    00A85 1542      CP	R20,R2
    00A86 0553      CPC	R21,R3
    00A87 0564      CPC	R22,R4
    00A88 0575      CPC	R23,R5
    00A89 F010      BCS	0x0A8C
    00A8A E002      LDI	R16,2
    00A8B C11C      RJMP	0x0BA8
(1138) 				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
    00A8C EF4F      LDI	R20,0xFF
    00A8D EF5F      LDI	R21,0xFF
    00A8E EF6F      LDI	R22,0xFF
    00A8F EF7F      LDI	R23,0xFF
    00A90 802A      LDD	R2,Y+2
    00A91 803B      LDD	R3,Y+3
    00A92 804C      LDD	R4,Y+4
    00A93 805D      LDD	R5,Y+5
    00A94 1624      CP	R2,R20
    00A95 0635      CPC	R3,R21
    00A96 0646      CPC	R4,R22
    00A97 0657      CPC	R5,R23
    00A98 F411      BNE	0x0A9B
    00A99 E001      LDI	R16,1
    00A9A C10D      RJMP	0x0BA8
(1139) 				if (clst >= dj->fs->n_fatent) {					/* When it reached end of dynamic table */
    00A9B 89E8      LDD	R30,Y+16
    00A9C 89F9      LDD	R31,Y+17
    00A9D 81A0      LD	R26,Z
    00A9E 81B1      LDD	R27,Z+1
    00A9F 9656      ADIW	R26,0x16
    00AA0 902D      LD	R2,X+
    00AA1 903D      LD	R3,X+
    00AA2 904D      LD	R4,X+
    00AA3 905C      LD	R5,X
    00AA4 806A      LDD	R6,Y+2
    00AA5 807B      LDD	R7,Y+3
    00AA6 808C      LDD	R8,Y+4
    00AA7 809D      LDD	R9,Y+5
    00AA8 1462      CP	R6,R2
    00AA9 0473      CPC	R7,R3
    00AAA 0484      CPC	R8,R4
    00AAB 0495      CPC	R9,R5
    00AAC F408      BCC	0x0AAE
    00AAD C0CD      RJMP	0x0B7B
(1140) #if !_FS_READONLY
(1141) 					BYTE c;
(1142) 					if (!stretch) return FR_NO_FILE;			/* When do not stretch, report EOT */
    00AAE 20AA      TST	R10
    00AAF F421      BNE	0x0AB4
    00AB0 20BB      TST	R11
    00AB1 F411      BNE	0x0AB4
    00AB2 E004      LDI	R16,4
    00AB3 C0F4      RJMP	0x0BA8
(1143) 					clst = create_chain(dj->fs, dj->clust);		/* Stretch cluster chain */
    00AB4 89E8      LDD	R30,Y+16
    00AB5 89F9      LDD	R31,Y+17
    00AB6 8422      LDD	R2,Z+10
    00AB7 8433      LDD	R3,Z+11
    00AB8 8444      LDD	R4,Z+12
    00AB9 8455      LDD	R5,Z+13
    00ABA 8248      ST	Y,R4
    00ABB 8259      STD	Y+1,R5
    00ABC 0191      MOVW	R18,R2
    00ABD 8100      LD	R16,Z
    00ABE 8111      LDD	R17,Z+1
    00ABF DC44      RCALL	ff.c:create_chain
    00AC0 830A      STD	Y+2,R16
    00AC1 831B      STD	Y+3,R17
    00AC2 832C      STD	Y+4,R18
    00AC3 833D      STD	Y+5,R19
(1144) 					if (clst == 0) return FR_DENIED;			/* No free cluster */
    00AC4 802A      LDD	R2,Y+2
    00AC5 803B      LDD	R3,Y+3
    00AC6 804C      LDD	R4,Y+4
    00AC7 805D      LDD	R5,Y+5
    00AC8 9488      BCLR	0
    00AC9 2022      TST	R2
    00ACA 0432      CPC	R3,R2
    00ACB 0442      CPC	R4,R2
    00ACC 0452      CPC	R5,R2
    00ACD F411      BNE	0x0AD0
    00ACE E007      LDI	R16,7
    00ACF C0D8      RJMP	0x0BA8
(1145) 					if (clst == 1) return FR_INT_ERR;
    00AD0 E041      LDI	R20,1
    00AD1 E050      LDI	R21,0
    00AD2 E060      LDI	R22,0
    00AD3 E070      LDI	R23,0
    00AD4 802A      LDD	R2,Y+2
    00AD5 803B      LDD	R3,Y+3
    00AD6 804C      LDD	R4,Y+4
    00AD7 805D      LDD	R5,Y+5
    00AD8 1624      CP	R2,R20
    00AD9 0635      CPC	R3,R21
    00ADA 0646      CPC	R4,R22
    00ADB 0657      CPC	R5,R23
    00ADC F411      BNE	0x0ADF
    00ADD E002      LDI	R16,2
    00ADE C0C9      RJMP	0x0BA8
(1146) 					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
    00ADF EF4F      LDI	R20,0xFF
    00AE0 EF5F      LDI	R21,0xFF
    00AE1 EF6F      LDI	R22,0xFF
    00AE2 EF7F      LDI	R23,0xFF
    00AE3 802A      LDD	R2,Y+2
    00AE4 803B      LDD	R3,Y+3
    00AE5 804C      LDD	R4,Y+4
    00AE6 805D      LDD	R5,Y+5
    00AE7 1624      CP	R2,R20
    00AE8 0635      CPC	R3,R21
    00AE9 0646      CPC	R4,R22
    00AEA 0657      CPC	R5,R23
    00AEB F411      BNE	0x0AEE
    00AEC E001      LDI	R16,1
    00AED C0BA      RJMP	0x0BA8
(1147) 					/* Clean-up stretched table */
(1148) 					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
    00AEE E040      LDI	R20,0
    00AEF E050      LDI	R21,0
    00AF0 E060      LDI	R22,0
    00AF1 E070      LDI	R23,0
    00AF2 8368      ST	Y,R22
    00AF3 8379      STD	Y+1,R23
    00AF4 019A      MOVW	R18,R20
    00AF5 89E8      LDD	R30,Y+16
    00AF6 89F9      LDD	R31,Y+17
    00AF7 8100      LD	R16,Z
    00AF8 8111      LDD	R17,Z+1
    00AF9 940E 0179 CALL	ff.c:move_window
    00AFB 2300      TST	R16
    00AFC F011      BEQ	0x0AFF
    00AFD E001      LDI	R16,1
    00AFE C0A9      RJMP	0x0BA8
(1149) 					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
    00AFF E080      LDI	R24,0
    00B00 E092      LDI	R25,2
    00B01 8399      STD	Y+1,R25
    00B02 8388      ST	Y,R24
    00B03 2722      CLR	R18
    00B04 2733      CLR	R19
    00B05 89E8      LDD	R30,Y+16
    00B06 89F9      LDD	R31,Y+17
    00B07 8100      LD	R16,Z
    00B08 8111      LDD	R17,Z+1
    00B09 5D02      SUBI	R16,0xD2
    00B0A 4F1F      SBCI	R17,0xFF
    00B0B 940E 0136 CALL	ff.c:mem_set
(1150) 					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
    00B0D 802A      LDD	R2,Y+2
    00B0E 803B      LDD	R3,Y+3
    00B0F 804C      LDD	R4,Y+4
    00B10 805D      LDD	R5,Y+5
    00B11 8248      ST	Y,R4
    00B12 8259      STD	Y+1,R5
    00B13 0191      MOVW	R18,R2
    00B14 89E8      LDD	R30,Y+16
    00B15 89F9      LDD	R31,Y+17
    00B16 80A0      LD	R10,Z
    00B17 80B1      LDD	R11,Z+1
    00B18 0185      MOVW	R16,R10
    00B19 940E 02F0 CALL	_clust2sect
    00B1B 01F5      MOVW	R30,R10
    00B1C A702      STD	Z+42,R16
    00B1D A713      STD	Z+43,R17
    00B1E A724      STD	Z+44,R18
    00B1F A735      STD	Z+45,R19
(1151) 					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
    00B20 24AA      CLR	R10
    00B21 C035      RJMP	0x0B57
(1152) 						dj->fs->wflag = 1;
    00B22 E081      LDI	R24,1
    00B23 89E8      LDD	R30,Y+16
    00B24 89F9      LDD	R31,Y+17
    00B25 93AF      PUSH	R26
    00B26 93BF      PUSH	R27
    00B27 81A0      LD	R26,Z
    00B28 81B1      LDD	R27,Z+1
    00B29 01FD      MOVW	R30,R26
    00B2A 91BF      POP	R27
    00B2B 91AF      POP	R26
    00B2C 8384      STD	Z+4,R24
(1153) 						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
    00B2D E040      LDI	R20,0
    00B2E E050      LDI	R21,0
    00B2F E060      LDI	R22,0
    00B30 E070      LDI	R23,0
    00B31 8368      ST	Y,R22
    00B32 8379      STD	Y+1,R23
    00B33 019A      MOVW	R18,R20
    00B34 89E8      LDD	R30,Y+16
    00B35 89F9      LDD	R31,Y+17
    00B36 8100      LD	R16,Z
    00B37 8111      LDD	R17,Z+1
    00B38 940E 0179 CALL	ff.c:move_window
    00B3A 2EE0      MOV	R14,R16
    00B3B 2300      TST	R16
    00B3C F011      BEQ	0x0B3F
    00B3D E001      LDI	R16,1
    00B3E C069      RJMP	0x0BA8
(1154) 						dj->fs->winsect++;
    00B3F 89E8      LDD	R30,Y+16
    00B40 89F9      LDD	R31,Y+17
    00B41 8180      LD	R24,Z
    00B42 8191      LDD	R25,Z+1
    00B43 968A      ADIW	R24,0x2A
    00B44 017C      MOVW	R14,R24
    00B45 E041      LDI	R20,1
    00B46 E050      LDI	R21,0
    00B47 E060      LDI	R22,0
    00B48 E070      LDI	R23,0
    00B49 01FC      MOVW	R30,R24
    00B4A 8020      LD	R2,Z
    00B4B 8031      LDD	R3,Z+1
    00B4C 8042      LDD	R4,Z+2
    00B4D 8053      LDD	R5,Z+3
    00B4E 0E24      ADD	R2,R20
    00B4F 1E35      ADC	R3,R21
    00B50 1E46      ADC	R4,R22
    00B51 1E57      ADC	R5,R23
    00B52 8220      ST	Z,R2
    00B53 8231      STD	Z+1,R3
    00B54 8242      STD	Z+2,R4
    00B55 8253      STD	Z+3,R5
    00B56 94A3      INC	R10
    00B57 89E8      LDD	R30,Y+16
    00B58 89F9      LDD	R31,Y+17
    00B59 93AF      PUSH	R26
    00B5A 93BF      PUSH	R27
    00B5B 81A0      LD	R26,Z
    00B5C 81B1      LDD	R27,Z+1
    00B5D 01FD      MOVW	R30,R26
    00B5E 91BF      POP	R27
    00B5F 91AF      POP	R26
    00B60 8022      LDD	R2,Z+2
    00B61 14A2      CP	R10,R2
    00B62 F408      BCC	0x0B64
    00B63 CFBE      RJMP	0x0B22
(1155) 					}
(1156) 					dj->fs->winsect -= c;						/* Rewind window address */
    00B64 89E8      LDD	R30,Y+16
    00B65 89F9      LDD	R31,Y+17
    00B66 8180      LD	R24,Z
    00B67 8191      LDD	R25,Z+1
    00B68 968A      ADIW	R24,0x2A
    00B69 017C      MOVW	R14,R24
    00B6A 2C2A      MOV	R2,R10
    00B6B 2433      CLR	R3
    00B6C 2444      CLR	R4
    00B6D 2455      CLR	R5
    00B6E 01FC      MOVW	R30,R24
    00B6F 8060      LD	R6,Z
    00B70 8071      LDD	R7,Z+1
    00B71 8082      LDD	R8,Z+2
    00B72 8093      LDD	R9,Z+3
    00B73 1862      SUB	R6,R2
    00B74 0873      SBC	R7,R3
    00B75 0884      SBC	R8,R4
    00B76 0895      SBC	R9,R5
    00B77 8260      ST	Z,R6
    00B78 8271      STD	Z+1,R7
    00B79 8282      STD	Z+2,R8
    00B7A 8293      STD	Z+3,R9
(1157) #else
(1158) 					return FR_NO_FILE;			/* Report EOT */
(1159) #endif
(1160) 				}
(1161) 				dj->clust = clst;				/* Initialize data for new cluster */
    00B7B 802A      LDD	R2,Y+2
    00B7C 803B      LDD	R3,Y+3
    00B7D 804C      LDD	R4,Y+4
    00B7E 805D      LDD	R5,Y+5
    00B7F 89E8      LDD	R30,Y+16
    00B80 89F9      LDD	R31,Y+17
    00B81 8622      STD	Z+10,R2
    00B82 8633      STD	Z+11,R3
    00B83 8644      STD	Z+12,R4
    00B84 8655      STD	Z+13,R5
(1162) 				dj->sect = clust2sect(dj->fs, clst);
    00B85 8248      ST	Y,R4
    00B86 8259      STD	Y+1,R5
    00B87 0191      MOVW	R18,R2
    00B88 8100      LD	R16,Z
    00B89 8111      LDD	R17,Z+1
    00B8A 940E 02F0 CALL	_clust2sect
    00B8C 89E8      LDD	R30,Y+16
    00B8D 89F9      LDD	R31,Y+17
    00B8E 8706      STD	Z+14,R16
    00B8F 8717      STD	Z+15,R17
    00B90 8B20      STD	Z+16,R18
    00B91 8B31      STD	Z+17,R19
(1163) 			}
(1164) 		}
(1165) 	}
(1166) 
(1167) 	dj->index = i;
    00B92 89E8      LDD	R30,Y+16
    00B93 89F9      LDD	R31,Y+17
    00B94 82D5      STD	Z+5,R13
    00B95 82C4      STD	Z+4,R12
(1168) 	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;
    00B96 0196      MOVW	R18,R12
    00B97 702F      ANDI	R18,0xF
    00B98 7030      ANDI	R19,0
    00B99 E200      LDI	R16,0x20
    00B9A E010      LDI	R17,0
    00B9B 940E 2718 CALL	empy16s
    00B9D 0118      MOVW	R2,R16
    00B9E 89E8      LDD	R30,Y+16
    00B9F 89F9      LDD	R31,Y+17
    00BA0 8180      LD	R24,Z
    00BA1 8191      LDD	R25,Z+1
    00BA2 968E      ADIW	R24,0x2E
    00BA3 0E28      ADD	R2,R24
    00BA4 1E39      ADC	R3,R25
    00BA5 8A33      STD	Z+19,R3
    00BA6 8A22      STD	Z+18,R2
(1169) 
(1170) 	return FR_OK;
    00BA7 2700      CLR	R16
    00BA8 9626      ADIW	R28,6
    00BA9 940E 2771 CALL	pop_xgsetF0FC
    00BAB 9624      ADIW	R28,4
    00BAC 9508      RET
ff.c:dir_find:
  c                    --> R12
  dir                  --> R10
  res                  --> R20
  dj                   --> R22
    00BAD 940E 27B7 CALL	push_xgsetF03C
    00BAF 01B8      MOVW	R22,R16
    00BB0 9722      SBIW	R28,2
(1171) }
(1172) 
(1173) 
(1174) 
(1175) 
(1176) /*-----------------------------------------------------------------------*/
(1177) /* LFN handling - Test/Pick/Fit an LFN segment from/to directory entry   */
(1178) /*-----------------------------------------------------------------------*/
(1179) #if _USE_LFN
(1180) static
(1181) const BYTE LfnOfs[] = {1,3,5,7,9,14,16,18,20,22,24,28,30};	/* Offset of LFN chars in the directory entry */
(1182) 
(1183) 
(1184) static
(1185) int cmp_lfn (			/* 1:Matched, 0:Not matched */
(1186) 	WCHAR *lfnbuf,		/* Pointer to the LFN to be compared */
(1187) 	BYTE *dir			/* Pointer to the directory entry containing a part of LFN */
(1188) )
(1189) {
(1190) 	UINT i, s;
(1191) 	WCHAR wc, uc;
(1192) 
(1193) 
(1194) 	i = ((dir[LDIR_Ord] & ~LLE) - 1) * 13;	/* Get offset in the LFN buffer */
(1195) 	s = 0; wc = 1;
(1196) 	do {
(1197) 		uc = LD_WORD(dir+LfnOfs[s]);	/* Pick an LFN character from the entry */
(1198) 		if (wc) {	/* Last char has not been processed */
(1199) 			wc = ff_wtoupper(uc);		/* Convert it to upper case */
(1200) 			if (i >= _MAX_LFN || wc != ff_wtoupper(lfnbuf[i++]))	/* Compare it */
(1201) 				return 0;				/* Not matched */
(1202) 		} else {
(1203) 			if (uc != 0xFFFF) return 0;	/* Check filler */
(1204) 		}
(1205) 	} while (++s < 13);				/* Repeat until all chars in the entry are checked */
(1206) 
(1207) 	if ((dir[LDIR_Ord] & LLE) && wc && lfnbuf[i])	/* Last segment matched but different length */
(1208) 		return 0;
(1209) 
(1210) 	return 1;						/* The part of LFN matched */
(1211) }
(1212) 
(1213) 
(1214) 
(1215) static
(1216) int pick_lfn (			/* 1:Succeeded, 0:Buffer overflow */
(1217) 	WCHAR *lfnbuf,		/* Pointer to the Unicode-LFN buffer */
(1218) 	BYTE *dir			/* Pointer to the directory entry */
(1219) )
(1220) {
(1221) 	UINT i, s;
(1222) 	WCHAR wc, uc;
(1223) 
(1224) 
(1225) 	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */
(1226) 
(1227) 	s = 0; wc = 1;
(1228) 	do {
(1229) 		uc = LD_WORD(dir+LfnOfs[s]);		/* Pick an LFN character from the entry */
(1230) 		if (wc) {	/* Last char has not been processed */
(1231) 			if (i >= _MAX_LFN) return 0;	/* Buffer overflow? */
(1232) 			lfnbuf[i++] = wc = uc;			/* Store it */
(1233) 		} else {
(1234) 			if (uc != 0xFFFF) return 0;		/* Check filler */
(1235) 		}
(1236) 	} while (++s < 13);						/* Read all character in the entry */
(1237) 
(1238) 	if (dir[LDIR_Ord] & LLE) {				/* Put terminator if it is the last LFN part */
(1239) 		if (i >= _MAX_LFN) return 0;		/* Buffer overflow? */
(1240) 		lfnbuf[i] = 0;
(1241) 	}
(1242) 
(1243) 	return 1;
(1244) }
(1245) 
(1246) 
(1247) #if !_FS_READONLY
(1248) static
(1249) void fit_lfn (
(1250) 	const WCHAR *lfnbuf,	/* Pointer to the LFN buffer */
(1251) 	BYTE *dir,				/* Pointer to the directory entry */
(1252) 	BYTE ord,				/* LFN order (1-20) */
(1253) 	BYTE sum				/* SFN sum */
(1254) )
(1255) {
(1256) 	UINT i, s;
(1257) 	WCHAR wc;
(1258) 
(1259) 
(1260) 	dir[LDIR_Chksum] = sum;			/* Set check sum */
(1261) 	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
(1262) 	dir[LDIR_Type] = 0;
(1263) 	ST_WORD(dir+LDIR_FstClusLO, 0);
(1264) 
(1265) 	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
(1266) 	s = wc = 0;
(1267) 	do {
(1268) 		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective char */
(1269) 		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
(1270) 		if (!wc) wc = 0xFFFF;		/* Padding chars following last char */
(1271) 	} while (++s < 13);
(1272) 	if (wc == 0xFFFF || !lfnbuf[i]) ord |= LLE;	/* Bottom LFN part is the start of LFN sequence */
(1273) 	dir[LDIR_Ord] = ord;			/* Set the LFN order */
(1274) }
(1275) 
(1276) #endif
(1277) #endif
(1278) 
(1279) 
(1280) 
(1281) /*-----------------------------------------------------------------------*/
(1282) /* Create numbered name                                                  */
(1283) /*-----------------------------------------------------------------------*/
(1284) #if _USE_LFN
(1285) void gen_numname (
(1286) 	BYTE *dst,			/* Pointer to generated SFN */
(1287) 	const BYTE *src,	/* Pointer to source SFN to be modified */
(1288) 	const WCHAR *lfn,	/* Pointer to LFN */
(1289) 	WORD seq			/* Sequence number */
(1290) )
(1291) {
(1292) 	BYTE ns[8], c;
(1293) 	UINT i, j;
(1294) 
(1295) 
(1296) 	mem_cpy(dst, src, 11);
(1297) 
(1298) 	if (seq > 5) {	/* On many collisions, generate a hash number instead of sequential number */
(1299) 		do seq = (seq >> 1) + (seq << 15) + (WORD)*lfn++; while (*lfn);
(1300) 	}
(1301) 
(1302) 	/* itoa (hexdecimal) */
(1303) 	i = 7;
(1304) 	do {
(1305) 		c = (seq % 16) + '0';
(1306) 		if (c > '9') c += 7;
(1307) 		ns[i--] = c;
(1308) 		seq /= 16;
(1309) 	} while (seq);
(1310) 	ns[i] = '~';
(1311) 
(1312) 	/* Append the number */
(1313) 	for (j = 0; j < i && dst[j] != ' '; j++) {
(1314) 		if (IsDBCS1(dst[j])) {
(1315) 			if (j == i - 1) break;
(1316) 			j++;
(1317) 		}
(1318) 	}
(1319) 	do {
(1320) 		dst[j++] = (i < 8) ? ns[i++] : ' ';
(1321) 	} while (j < 8);
(1322) }
(1323) #endif
(1324) 
(1325) 
(1326) 
(1327) 
(1328) /*-----------------------------------------------------------------------*/
(1329) /* Calculate sum of an SFN                                               */
(1330) /*-----------------------------------------------------------------------*/
(1331) #if _USE_LFN
(1332) static
(1333) BYTE sum_sfn (
(1334) 	const BYTE *dir		/* Ptr to directory entry */
(1335) )
(1336) {
(1337) 	BYTE sum = 0;
(1338) 	UINT n = 11;
(1339) 
(1340) 	do sum = (sum >> 1) + (sum << 7) + *dir++; while (--n);
(1341) 	return sum;
(1342) }
(1343) #endif
(1344) 
(1345) 
(1346) 
(1347) 
(1348) /*-----------------------------------------------------------------------*/
(1349) /* Directory handling - Find an object in the directory                  */
(1350) /*-----------------------------------------------------------------------*/
(1351) 
(1352) static
(1353) FRESULT dir_find (
(1354) 	DIR *dj			/* Pointer to the directory object linked to the file name */
(1355) )
(1356) {
(1357) 	FRESULT res;
(1358) 	BYTE c, *dir;
(1359) #if _USE_LFN
(1360) 	BYTE a, ord, sum;
(1361) #endif
(1362) 
(1363) 	res = dir_sdi(dj, 0);			/* Rewind directory object */
    00BB1 2722      CLR	R18
    00BB2 2733      CLR	R19
    00BB3 018B      MOVW	R16,R22
    00BB4 DD40      RCALL	ff.c:dir_sdi
    00BB5 2F40      MOV	R20,R16
(1364) 	if (res != FR_OK) return res;
    00BB6 2300      TST	R16
    00BB7 F009      BEQ	0x0BB9
    00BB8 C036      RJMP	0x0BEF
(1365) 
(1366) #if _USE_LFN
(1367) 	ord = sum = 0xFF;
(1368) #endif
(1369) 	do {
(1370) 		res = move_window(dj->fs, dj->sect);
    00BB9 01FB      MOVW	R30,R22
    00BBA 8426      LDD	R2,Z+14
    00BBB 8437      LDD	R3,Z+15
    00BBC 8840      LDD	R4,Z+16
    00BBD 8851      LDD	R5,Z+17
    00BBE 8248      ST	Y,R4
    00BBF 8259      STD	Y+1,R5
    00BC0 0191      MOVW	R18,R2
    00BC1 8100      LD	R16,Z
    00BC2 8111      LDD	R17,Z+1
    00BC3 940E 0179 CALL	ff.c:move_window
    00BC5 2F40      MOV	R20,R16
(1371) 		if (res != FR_OK) break;
    00BC6 2300      TST	R16
    00BC7 F009      BEQ	0x0BC9
    00BC8 C025      RJMP	0x0BEE
(1372) 		dir = dj->dir;					/* Ptr to the directory entry of current index */
    00BC9 01FB      MOVW	R30,R22
    00BCA 88A2      LDD	R10,Z+18
    00BCB 88B3      LDD	R11,Z+19
(1373) 		c = dir[DIR_Name];
    00BCC 01F5      MOVW	R30,R10
    00BCD 80C0      LD	R12,Z
(1374) 		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
    00BCE 20CC      TST	R12
    00BCF F411      BNE	0x0BD2
    00BD0 E044      LDI	R20,4
    00BD1 C01C      RJMP	0x0BEE
(1375) #if _USE_LFN	/* LFN configuration */
(1376) 		a = dir[DIR_Attr] & AM_MASK;
(1377) 		if (c == DDE || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
(1378) 			ord = 0xFF;
(1379) 		} else {
(1380) 			if (a == AM_LFN) {			/* An LFN entry is found */
(1381) 				if (dj->lfn) {
(1382) 					if (c & LLE) {		/* Is it start of LFN sequence? */
(1383) 						sum = dir[LDIR_Chksum];
(1384) 						c &= ~LLE; ord = c;	/* LFN start order */
(1385) 						dj->lfn_idx = dj->index;
(1386) 					}
(1387) 					/* Check validity of the LFN entry and compare it with given name */
(1388) 					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
(1389) 				}
(1390) 			} else {					/* An SFN entry is found */
(1391) 				if (!ord && sum == sum_sfn(dir)) break;	/* LFN matched? */
(1392) 				ord = 0xFF; dj->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
(1393) 				if (!(dj->fn[NS] & NS_LOSS) && !mem_cmp(dir, dj->fn, 11)) break;	/* SFN matched? */
(1394) 			}
(1395) 		}
(1396) #else		/* Non LFN configuration */
(1397) 		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
    00BD2 01F5      MOVW	R30,R10
    00BD3 8423      LDD	R2,Z+11
    00BD4 FC23      SBRC	R2,3
    00BD5 C00F      RJMP	0x0BE5
    00BD6 E08B      LDI	R24,0xB
    00BD7 E090      LDI	R25,0
    00BD8 8399      STD	Y+1,R25
    00BD9 8388      ST	Y,R24
    00BDA 01FB      MOVW	R30,R22
    00BDB 8924      LDD	R18,Z+20
    00BDC 8935      LDD	R19,Z+21
    00BDD 0185      MOVW	R16,R10
    00BDE 940E 0148 CALL	ff.c:mem_cmp
    00BE0 0158      MOVW	R10,R16
    00BE1 3000      CPI	R16,0
    00BE2 0701      CPC	R16,R17
    00BE3 F409      BNE	0x0BE5
(1398) 			break;
    00BE4 C009      RJMP	0x0BEE
(1399) #endif
(1400) 		res = dir_next(dj, 0);		/* Next entry */
    00BE5 2722      CLR	R18
    00BE6 2733      CLR	R19
    00BE7 018B      MOVW	R16,R22
    00BE8 DE16      RCALL	ff.c:dir_next
    00BE9 2EA0      MOV	R10,R16
    00BEA 2D4A      MOV	R20,R10
(1401) 	} while (res == FR_OK);
    00BEB 2344      TST	R20
    00BEC F409      BNE	0x0BEE
    00BED CFCB      RJMP	0x0BB9
(1402) 
(1403) 	return res;
    00BEE 2F04      MOV	R16,R20
    00BEF 9622      ADIW	R28,2
    00BF0 940C 27C0 JMP	pop_xgsetF03C
ff.c:dir_read:
  dir                  --> R10
  c                    --> R12
  res                  --> R20
  dj                   --> R22
    00BF2 940E 27B7 CALL	push_xgsetF03C
    00BF4 01B8      MOVW	R22,R16
    00BF5 9722      SBIW	R28,2
(1404) }
(1405) 
(1406) 
(1407) 
(1408) 
(1409) /*-----------------------------------------------------------------------*/
(1410) /* Read an object from the directory                                     */
(1411) /*-----------------------------------------------------------------------*/
(1412) #if _FS_MINIMIZE <= 1
(1413) static
(1414) FRESULT dir_read (
(1415) 	DIR *dj			/* Pointer to the directory object that pointing the entry to be read */
(1416) )
(1417) {
(1418) 	FRESULT res;
(1419) 	BYTE c, *dir;
(1420) #if _USE_LFN
(1421) 	BYTE a, ord = 0xFF, sum = 0xFF;
(1422) #endif
(1423) 
(1424) 	res = FR_NO_FILE;
    00BF6 E044      LDI	R20,4
    00BF7 C02B      RJMP	0x0C23
(1425) 	while (dj->sect) {
(1426) 		res = move_window(dj->fs, dj->sect);
    00BF8 01FB      MOVW	R30,R22
    00BF9 8426      LDD	R2,Z+14
    00BFA 8437      LDD	R3,Z+15
    00BFB 8840      LDD	R4,Z+16
    00BFC 8851      LDD	R5,Z+17
    00BFD 8248      ST	Y,R4
    00BFE 8259      STD	Y+1,R5
    00BFF 0191      MOVW	R18,R2
    00C00 8100      LD	R16,Z
    00C01 8111      LDD	R17,Z+1
    00C02 940E 0179 CALL	ff.c:move_window
    00C04 2F40      MOV	R20,R16
(1427) 		if (res != FR_OK) break;
    00C05 2300      TST	R16
    00C06 F009      BEQ	0x0C08
    00C07 C028      RJMP	0x0C30
(1428) 		dir = dj->dir;					/* Ptr to the directory entry of current index */
    00C08 01FB      MOVW	R30,R22
    00C09 88A2      LDD	R10,Z+18
    00C0A 88B3      LDD	R11,Z+19
(1429) 		c = dir[DIR_Name];
    00C0B 01F5      MOVW	R30,R10
    00C0C 80C0      LD	R12,Z
(1430) 		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
    00C0D 20CC      TST	R12
    00C0E F411      BNE	0x0C11
    00C0F E044      LDI	R20,4
    00C10 C01F      RJMP	0x0C30
(1431) #if _USE_LFN	/* LFN configuration */
(1432) 		a = dir[DIR_Attr] & AM_MASK;
(1433) 		if (c == DDE || (!_FS_RPATH && c == '.') || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
(1434) 			ord = 0xFF;
(1435) 		} else {
(1436) 			if (a == AM_LFN) {			/* An LFN entry is found */
(1437) 				if (c & LLE) {			/* Is it start of LFN sequence? */
(1438) 					sum = dir[LDIR_Chksum];
(1439) 					c &= ~LLE; ord = c;
(1440) 					dj->lfn_idx = dj->index;
(1441) 				}
(1442) 				/* Check LFN validity and capture it */
(1443) 				ord = (c == ord && sum == dir[LDIR_Chksum] && pick_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
(1444) 			} else {					/* An SFN entry is found */
(1445) 				if (ord || sum != sum_sfn(dir))	/* Is there a valid LFN? */
(1446) 					dj->lfn_idx = 0xFFFF;		/* It has no LFN. */
(1447) 				break;
(1448) 			}
(1449) 		}
(1450) #else		/* Non LFN configuration */
(1451) 		if (c != DDE && (_FS_RPATH || c != '.') && !(dir[DIR_Attr] & AM_VOL))	/* Is it a valid entry? */
    00C11 2D8C      MOV	R24,R12
    00C12 3E85      CPI	R24,0xE5
    00C13 F039      BEQ	0x0C1B
    00C14 328E      CPI	R24,0x2E
    00C15 F029      BEQ	0x0C1B
    00C16 01F5      MOVW	R30,R10
    00C17 8423      LDD	R2,Z+11
    00C18 FC23      SBRC	R2,3
    00C19 C001      RJMP	0x0C1B
(1452) 			break;
    00C1A C015      RJMP	0x0C30
(1453) #endif
(1454) 		res = dir_next(dj, 0);				/* Next entry */
    00C1B 2722      CLR	R18
    00C1C 2733      CLR	R19
    00C1D 018B      MOVW	R16,R22
    00C1E DDE0      RCALL	ff.c:dir_next
    00C1F 2F40      MOV	R20,R16
(1455) 		if (res != FR_OK) break;
    00C20 2300      TST	R16
    00C21 F009      BEQ	0x0C23
    00C22 C00D      RJMP	0x0C30
    00C23 01FB      MOVW	R30,R22
    00C24 963E      ADIW	R30,0xE
    00C25 8020      LD	R2,Z
    00C26 8031      LDD	R3,Z+1
    00C27 8042      LDD	R4,Z+2
    00C28 8053      LDD	R5,Z+3
    00C29 9488      BCLR	0
    00C2A 2022      TST	R2
    00C2B 0432      CPC	R3,R2
    00C2C 0442      CPC	R4,R2
    00C2D 0452      CPC	R5,R2
    00C2E F009      BEQ	0x0C30
    00C2F CFC8      RJMP	0x0BF8
(1456) 	}
(1457) 
(1458) 	if (res != FR_OK) dj->sect = 0;
    00C30 2344      TST	R20
    00C31 F039      BEQ	0x0C39
    00C32 01FB      MOVW	R30,R22
    00C33 963E      ADIW	R30,0xE
    00C34 E080      LDI	R24,0
    00C35 8380      ST	Z,R24
    00C36 8381      STD	Z+1,R24
    00C37 8382      STD	Z+2,R24
    00C38 8383      STD	Z+3,R24
(1459) 
(1460) 	return res;
    00C39 2F04      MOV	R16,R20
    00C3A 9622      ADIW	R28,2
    00C3B 940C 27C0 JMP	pop_xgsetF03C
ff.c:dir_register:
  dir                  --> R12
  c                    --> R22
  res                  --> R10
  dj                   --> R20
    00C3D 940E 27B7 CALL	push_xgsetF03C
    00C3F 01A8      MOVW	R20,R16
    00C40 9722      SBIW	R28,2
(1461) }
(1462) #endif
(1463) 
(1464) 
(1465) 
(1466) /*-----------------------------------------------------------------------*/
(1467) /* Register an object to the directory                                   */
(1468) /*-----------------------------------------------------------------------*/
(1469) #if !_FS_READONLY
(1470) static
(1471) FRESULT dir_register (	/* FR_OK:Successful, FR_DENIED:No free entry or too many SFN collision, FR_DISK_ERR:Disk error */
(1472) 	DIR *dj				/* Target directory with object name to be created */
(1473) )
(1474) {
(1475) 	FRESULT res;
(1476) 	BYTE c, *dir;
(1477) #if _USE_LFN	/* LFN configuration */
(1478) 	WORD n, ne, is;
(1479) 	BYTE sn[12], *fn, sum;
(1480) 	WCHAR *lfn;
(1481) 
(1482) 
(1483) 	fn = dj->fn; lfn = dj->lfn;
(1484) 	mem_cpy(sn, fn, 12);
(1485) 
(1486) 	if (_FS_RPATH && (sn[NS] & NS_DOT))		/* Cannot create dot entry */
(1487) 		return FR_INVALID_NAME;
(1488) 
(1489) 	if (sn[NS] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
(1490) 		fn[NS] = 0; dj->lfn = 0;			/* Find only SFN */
(1491) 		for (n = 1; n < 100; n++) {
(1492) 			gen_numname(fn, sn, lfn, n);	/* Generate a numbered name */
(1493) 			res = dir_find(dj);				/* Check if the name collides with existing SFN */
(1494) 			if (res != FR_OK) break;
(1495) 		}
(1496) 		if (n == 100) return FR_DENIED;		/* Abort if too many collisions */
(1497) 		if (res != FR_NO_FILE) return res;	/* Abort if the result is other than 'not collided' */
(1498) 		fn[NS] = sn[NS]; dj->lfn = lfn;
(1499) 	}
(1500) 
(1501) 	if (sn[NS] & NS_LFN) {			/* When LFN is to be created, reserve an SFN + LFN entries. */
(1502) 		for (ne = 0; lfn[ne]; ne++) ;
(1503) 		ne = (ne + 25) / 13;
(1504) 	} else {						/* Otherwise reserve only an SFN entry. */
(1505) 		ne = 1;
(1506) 	}
(1507) 
(1508) 	/* Reserve contiguous entries */
(1509) 	res = dir_sdi(dj, 0);
(1510) 	if (res != FR_OK) return res;
(1511) 	n = is = 0;
(1512) 	do {
(1513) 		res = move_window(dj->fs, dj->sect);
(1514) 		if (res != FR_OK) break;
(1515) 		c = *dj->dir;				/* Check the entry status */
(1516) 		if (c == DDE || c == 0) {	/* Is it a blank entry? */
(1517) 			if (n == 0) is = dj->index;	/* First index of the contiguous entry */
(1518) 			if (++n == ne) break;	/* A contiguous entry that required count is found */
(1519) 		} else {
(1520) 			n = 0;					/* Not a blank entry. Restart to search */
(1521) 		}
(1522) 		res = dir_next(dj, 1);		/* Next entry with table stretch */
(1523) 	} while (res == FR_OK);
(1524) 
(1525) 	if (res == FR_OK && ne > 1) {	/* Initialize LFN entry if needed */
(1526) 		res = dir_sdi(dj, is);
(1527) 		if (res == FR_OK) {
(1528) 			sum = sum_sfn(dj->fn);	/* Sum of the SFN tied to the LFN */
(1529) 			ne--;
(1530) 			do {					/* Store LFN entries in bottom first */
(1531) 				res = move_window(dj->fs, dj->sect);
(1532) 				if (res != FR_OK) break;
(1533) 				fit_lfn(dj->lfn, dj->dir, (BYTE)ne, sum);
(1534) 				dj->fs->wflag = 1;
(1535) 				res = dir_next(dj, 0);	/* Next entry */
(1536) 			} while (res == FR_OK && --ne);
(1537) 		}
(1538) 	}
(1539) 
(1540) #else	/* Non LFN configuration */
(1541) 	res = dir_sdi(dj, 0);
    00C41 2722      CLR	R18
    00C42 2733      CLR	R19
    00C43 018A      MOVW	R16,R20
    00C44 DCB0      RCALL	ff.c:dir_sdi
    00C45 2EA0      MOV	R10,R16
(1542) 	if (res == FR_OK) {
    00C46 2300      TST	R16
    00C47 F509      BNE	0x0C69
(1543) 		do {	/* Find a blank entry for the SFN */
(1544) 			res = move_window(dj->fs, dj->sect);
    00C48 01FA      MOVW	R30,R20
    00C49 8426      LDD	R2,Z+14
    00C4A 8437      LDD	R3,Z+15
    00C4B 8840      LDD	R4,Z+16
    00C4C 8851      LDD	R5,Z+17
    00C4D 8248      ST	Y,R4
    00C4E 8259      STD	Y+1,R5
    00C4F 0191      MOVW	R18,R2
    00C50 8100      LD	R16,Z
    00C51 8111      LDD	R17,Z+1
    00C52 940E 0179 CALL	ff.c:move_window
    00C54 2EA0      MOV	R10,R16
(1545) 			if (res != FR_OK) break;
    00C55 2300      TST	R16
    00C56 F009      BEQ	0x0C58
    00C57 C011      RJMP	0x0C69
(1546) 			c = *dj->dir;
    00C58 01FA      MOVW	R30,R20
    00C59 89A2      LDD	R26,Z+18
    00C5A 89B3      LDD	R27,Z+19
    00C5B 916C      LD	R22,X
(1547) 			if (c == DDE || c == 0) break;	/* Is it a blank entry? */
    00C5C 3E65      CPI	R22,0xE5
    00C5D F011      BEQ	0x0C60
    00C5E 2366      TST	R22
    00C5F F409      BNE	0x0C61
    00C60 C008      RJMP	0x0C69
(1548) 			res = dir_next(dj, 1);			/* Next entry with table stretch */
    00C61 E021      LDI	R18,1
    00C62 E030      LDI	R19,0
    00C63 018A      MOVW	R16,R20
    00C64 DD9A      RCALL	ff.c:dir_next
    00C65 2EC0      MOV	R12,R16
    00C66 2CAC      MOV	R10,R12
(1549) 		} while (res == FR_OK);
    00C67 20AA      TST	R10
    00C68 F2F9      BEQ	0x0C48
(1550) 	}
(1551) #endif
(1552) 
(1553) 	if (res == FR_OK) {		/* Initialize the SFN entry */
    00C69 20AA      TST	R10
    00C6A F009      BEQ	0x0C6C
    00C6B C030      RJMP	0x0C9C
(1554) 		res = move_window(dj->fs, dj->sect);
    00C6C 01FA      MOVW	R30,R20
    00C6D 8426      LDD	R2,Z+14
    00C6E 8437      LDD	R3,Z+15
    00C6F 8840      LDD	R4,Z+16
    00C70 8851      LDD	R5,Z+17
    00C71 8248      ST	Y,R4
    00C72 8259      STD	Y+1,R5
    00C73 0191      MOVW	R18,R2
    00C74 8100      LD	R16,Z
    00C75 8111      LDD	R17,Z+1
    00C76 940E 0179 CALL	ff.c:move_window
    00C78 2EC0      MOV	R12,R16
    00C79 2CAC      MOV	R10,R12
(1555) 		if (res == FR_OK) {
    00C7A 2300      TST	R16
    00C7B F501      BNE	0x0C9C
(1556) 			dir = dj->dir;
    00C7C 01FA      MOVW	R30,R20
    00C7D 88C2      LDD	R12,Z+18
    00C7E 88D3      LDD	R13,Z+19
(1557) 			mem_set(dir, 0, SZ_DIR);	/* Clean the entry */
    00C7F E280      LDI	R24,0x20
    00C80 E090      LDI	R25,0
    00C81 8399      STD	Y+1,R25
    00C82 8388      ST	Y,R24
    00C83 2722      CLR	R18
    00C84 2733      CLR	R19
    00C85 0186      MOVW	R16,R12
    00C86 940E 0136 CALL	ff.c:mem_set
(1558) 			mem_cpy(dir, dj->fn, 11);	/* Put SFN */
    00C88 E08B      LDI	R24,0xB
    00C89 E090      LDI	R25,0
    00C8A 8399      STD	Y+1,R25
    00C8B 8388      ST	Y,R24
    00C8C 01FA      MOVW	R30,R20
    00C8D 8924      LDD	R18,Z+20
    00C8E 8935      LDD	R19,Z+21
    00C8F 0186      MOVW	R16,R12
    00C90 940E 0120 CALL	ff.c:mem_cpy
(1559) #if _USE_LFN
(1560) 			dir[DIR_NTres] = *(dj->fn+NS) & (NS_BODY | NS_EXT);	/* Put NT flag */
(1561) #endif
(1562) 			dj->fs->wflag = 1;
    00C92 E081      LDI	R24,1
    00C93 01FA      MOVW	R30,R20
    00C94 93AF      PUSH	R26
    00C95 93BF      PUSH	R27
    00C96 81A0      LD	R26,Z
    00C97 81B1      LDD	R27,Z+1
    00C98 01FD      MOVW	R30,R26
    00C99 91BF      POP	R27
    00C9A 91AF      POP	R26
    00C9B 8384      STD	Z+4,R24
(1563) 		}
(1564) 	}
(1565) 
(1566) 	return res;
    00C9C 2D0A      MOV	R16,R10
    00C9D 9622      ADIW	R28,2
    00C9E 940C 27C0 JMP	pop_xgsetF03C
ff.c:create_name:
  si                   --> R22
  b                    --> Y,+8
  sfn                  --> Y,+6
  ni                   --> R12
  d                    --> R10
  i                    --> Y,+4
  p                    --> Y,+2
  c                    --> R20
  path                 --> Y,+19
  dj                   --> R20
    00CA0 933A      ST	-Y,R19
    00CA1 932A      ST	-Y,R18
    00CA2 940E 277C CALL	push_xgsetF0FC
    00CA4 01A8      MOVW	R20,R16
    00CA5 9729      SBIW	R28,0x9
(1567) }
(1568) #endif /* !_FS_READONLY */
(1569) 
(1570) 
(1571) 
(1572) 
(1573) /*-----------------------------------------------------------------------*/
(1574) /* Remove an object from the directory                                   */
(1575) /*-----------------------------------------------------------------------*/
(1576) #if !_FS_READONLY && !_FS_MINIMIZE
(1577) static
(1578) FRESULT dir_remove (	/* FR_OK: Successful, FR_DISK_ERR: A disk error */
(1579) 	DIR *dj				/* Directory object pointing the entry to be removed */
(1580) )
(1581) {
(1582) 	FRESULT res;
(1583) #if _USE_LFN	/* LFN configuration */
(1584) 	WORD i;
(1585) 
(1586) 	i = dj->index;	/* SFN index */
(1587) 	res = dir_sdi(dj, (WORD)((dj->lfn_idx == 0xFFFF) ? i : dj->lfn_idx));	/* Goto the SFN or top of the LFN entries */
(1588) 	if (res == FR_OK) {
(1589) 		do {
(1590) 			res = move_window(dj->fs, dj->sect);
(1591) 			if (res != FR_OK) break;
(1592) 			*dj->dir = DDE;			/* Mark the entry "deleted" */
(1593) 			dj->fs->wflag = 1;
(1594) 			if (dj->index >= i) break;	/* When reached SFN, all entries of the object has been deleted. */
(1595) 			res = dir_next(dj, 0);		/* Next entry */
(1596) 		} while (res == FR_OK);
(1597) 		if (res == FR_NO_FILE) res = FR_INT_ERR;
(1598) 	}
(1599) 
(1600) #else			/* Non LFN configuration */
(1601) 	res = dir_sdi(dj, dj->index);
(1602) 	if (res == FR_OK) {
(1603) 		res = move_window(dj->fs, dj->sect);
(1604) 		if (res == FR_OK) {
(1605) 			*dj->dir = DDE;			/* Mark the entry "deleted" */
(1606) 			dj->fs->wflag = 1;
(1607) 		}
(1608) 	}
(1609) #endif
(1610) 
(1611) 	return res;
(1612) }
(1613) #endif /* !_FS_READONLY */
(1614) 
(1615) 
(1616) 
(1617) 
(1618) /*-----------------------------------------------------------------------*/
(1619) /* Pick a segment and create the object name in directory form           */
(1620) /*-----------------------------------------------------------------------*/
(1621) 
(1622) static
(1623) FRESULT create_name (
(1624) 	DIR *dj,			/* Pointer to the directory object */
(1625) 	const TCHAR **path	/* Pointer to pointer to the segment in the path string */
(1626) )
(1627) {
(1628) #ifdef _EXCVT
(1629) 	static const BYTE excvt[] = _EXCVT;	/* Upper conversion table for extended chars */
(1630) #endif
(1631) 
(1632) #if _USE_LFN	/* LFN configuration */
(1633) 	BYTE b, cf;
(1634) 	WCHAR w, *lfn;
(1635) 	UINT i, ni, si, di;
(1636) 	const TCHAR *p;
(1637) 
(1638) 	/* Create LFN in Unicode */
(1639) 	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
(1640) 	lfn = dj->lfn;
(1641) 	si = di = 0;
(1642) 	for (;;) {
(1643) 		w = p[si++];					/* Get a character */
(1644) 		if (w < ' ' || w == '/' || w == '\\') break;	/* Break on end of segment */
(1645) 		if (di >= _MAX_LFN)				/* Reject too long name */
(1646) 			return FR_INVALID_NAME;
(1647) #if !_LFN_UNICODE
(1648) 		w &= 0xFF;
(1649) 		if (IsDBCS1(w)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
(1650) 			b = (BYTE)p[si++];			/* Get 2nd byte */
(1651) 			if (!IsDBCS2(b))
(1652) 				return FR_INVALID_NAME;	/* Reject invalid sequence */
(1653) 			w = (w << 8) + b;			/* Create a DBC */
(1654) 		}
(1655) 		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
(1656) 		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
(1657) #endif
(1658) 		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal chars for LFN */
(1659) 			return FR_INVALID_NAME;
(1660) 		lfn[di++] = w;					/* Store the Unicode char */
(1661) 	}
(1662) 	*path = &p[si];						/* Return pointer to the next segment */
(1663) 	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
(1664) #if _FS_RPATH
(1665) 	if ((di == 1 && lfn[di-1] == '.') || /* Is this a dot entry? */
(1666) 		(di == 2 && lfn[di-1] == '.' && lfn[di-2] == '.')) {
(1667) 		lfn[di] = 0;
(1668) 		for (i = 0; i < 11; i++)
(1669) 			dj->fn[i] = (i < di) ? '.' : ' ';
(1670) 		dj->fn[i] = cf | NS_DOT;		/* This is a dot entry */
(1671) 		return FR_OK;
(1672) 	}
(1673) #endif
(1674) 	while (di) {						/* Strip trailing spaces and dots */
(1675) 		w = lfn[di-1];
(1676) 		if (w != ' ' && w != '.') break;
(1677) 		di--;
(1678) 	}
(1679) 	if (!di) return FR_INVALID_NAME;	/* Reject nul string */
(1680) 
(1681) 	lfn[di] = 0;						/* LFN is created */
(1682) 
(1683) 	/* Create SFN in directory form */
(1684) 	mem_set(dj->fn, ' ', 11);
(1685) 	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;	/* Strip leading spaces and dots */
(1686) 	if (si) cf |= NS_LOSS | NS_LFN;
(1687) 	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */
(1688) 
(1689) 	b = i = 0; ni = 8;
(1690) 	for (;;) {
(1691) 		w = lfn[si++];					/* Get an LFN char */
(1692) 		if (!w) break;					/* Break on end of the LFN */
(1693) 		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
(1694) 			cf |= NS_LOSS | NS_LFN; continue;
(1695) 		}
(1696) 
(1697) 		if (i >= ni || si == di) {		/* Extension or end of SFN */
(1698) 			if (ni == 11) {				/* Long extension */
(1699) 				cf |= NS_LOSS | NS_LFN; break;
(1700) 			}
(1701) 			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
(1702) 			if (si > di) break;			/* No extension */
(1703) 			si = di; i = 8; ni = 11;	/* Enter extension section */
(1704) 			b <<= 2; continue;
(1705) 		}
(1706) 
(1707) 		if (w >= 0x80) {				/* Non ASCII char */
(1708) #ifdef _EXCVT
(1709) 			w = ff_convert(w, 0);		/* Unicode -> OEM code */
(1710) 			if (w) w = excvt[w - 0x80];	/* Convert extended char to upper (SBCS) */
(1711) #else
(1712) 			w = ff_convert(ff_wtoupper(w), 0);	/* Upper converted Unicode -> OEM code */
(1713) #endif
(1714) 			cf |= NS_LFN;				/* Force create LFN entry */
(1715) 		}
(1716) 
(1717) 		if (_DF1S && w >= 0x100) {		/* Double byte char (always false on SBCS cfg) */
(1718) 			if (i >= ni - 1) {
(1719) 				cf |= NS_LOSS | NS_LFN; i = ni; continue;
(1720) 			}
(1721) 			dj->fn[i++] = (BYTE)(w >> 8);
(1722) 		} else {						/* Single byte char */
(1723) 			if (!w || chk_chr("+,;=[]", w)) {	/* Replace illegal chars for SFN */
(1724) 				w = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
(1725) 			} else {
(1726) 				if (IsUpper(w)) {		/* ASCII large capital */
(1727) 					b |= 2;
(1728) 				} else {
(1729) 					if (IsLower(w)) {	/* ASCII small capital */
(1730) 						b |= 1; w -= 0x20;
(1731) 					}
(1732) 				}
(1733) 			}
(1734) 		}
(1735) 		dj->fn[i++] = (BYTE)w;
(1736) 	}
(1737) 
(1738) 	if (dj->fn[0] == DDE) dj->fn[0] = NDDE;	/* If the first char collides with deleted mark, replace it with 0x05 */
(1739) 
(1740) 	if (ni == 8) b <<= 2;
(1741) 	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03)	/* Create LFN entry when there are composite capitals */
(1742) 		cf |= NS_LFN;
(1743) 	if (!(cf & NS_LFN)) {						/* When LFN is in 8.3 format without extended char, NT flags are created */
(1744) 		if ((b & 0x03) == 0x01) cf |= NS_EXT;	/* NT flag (Extension has only small capital) */
(1745) 		if ((b & 0x0C) == 0x04) cf |= NS_BODY;	/* NT flag (Filename has only small capital) */
(1746) 	}
(1747) 
(1748) 	dj->fn[NS] = cf;	/* SFN is created */
(1749) 
(1750) 	return FR_OK;
(1751) 
(1752) 
(1753) #else	/* Non-LFN configuration */
(1754) 	BYTE b, c, d, *sfn;
(1755) 	UINT ni, si, i;
(1756) 	const char *p;
(1757) 
(1758) 	/* Create file name in directory form */
(1759) 	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
    00CA6 89EB      LDD	R30,Y+19
    00CA7 89FC      LDD	R31,Y+20
    00CA8 8020      LD	R2,Z
    00CA9 8031      LDD	R3,Z+1
    00CAA 823B      STD	Y+3,R3
    00CAB 822A      STD	Y+2,R2
    00CAC C005      RJMP	0x0CB2
    00CAD 818A      LDD	R24,Y+2
    00CAE 819B      LDD	R25,Y+3
    00CAF 9601      ADIW	R24,1
    00CB0 839B      STD	Y+3,R25
    00CB1 838A      STD	Y+2,R24
    00CB2 81EA      LDD	R30,Y+2
    00CB3 81FB      LDD	R31,Y+3
    00CB4 8020      LD	R2,Z
    00CB5 2433      CLR	R3
    00CB6 2D82      MOV	R24,R2
    00CB7 328F      CPI	R24,0x2F
    00CB8 F3A1      BEQ	0x0CAD
    00CB9 358C      CPI	R24,0x5C
    00CBA F391      BEQ	0x0CAD
(1760) 	sfn = dj->fn;
    00CBB 01FA      MOVW	R30,R20
    00CBC 8824      LDD	R2,Z+20
    00CBD 8835      LDD	R3,Z+21
    00CBE 823F      STD	Y+7,R3
    00CBF 822E      STD	Y+6,R2
(1761) 	mem_set(sfn, ' ', 11);
    00CC0 E08B      LDI	R24,0xB
    00CC1 E090      LDI	R25,0
    00CC2 8399      STD	Y+1,R25
    00CC3 8388      ST	Y,R24
    00CC4 E220      LDI	R18,0x20
    00CC5 E030      LDI	R19,0
    00CC6 0181      MOVW	R16,R2
    00CC7 940E 0136 CALL	ff.c:mem_set
(1762) 	si = i = b = 0; ni = 8;
    00CC9 2400      CLR	R0
    00CCA 8608      STD	Y+8,R0
    00CCB 2422      CLR	R2
    00CCC 2433      CLR	R3
    00CCD 823D      STD	Y+5,R3
    00CCE 822C      STD	Y+4,R2
    00CCF 01B1      MOVW	R22,R2
    00CD0 E088      LDI	R24,0x8
    00CD1 E090      LDI	R25,0
    00CD2 016C      MOVW	R12,R24
(1763) #if _FS_RPATH
(1764) 	if (p[si] == '.') { /* Is this a dot entry? */
(1765) 		for (;;) {
(1766) 			c = (BYTE)p[si++];
(1767) 			if (c != '.' || si >= 3) break;
(1768) 			sfn[i++] = c;
(1769) 		}
(1770) 		if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
(1771) 		*path = &p[si];									/* Return pointer to the next segment */
(1772) 		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
(1773) 		return FR_OK;
(1774) 	}
(1775) #endif
(1776) 	for (;;) {
(1777) 		c = (BYTE)p[si++];
    00CD3 01AB      MOVW	R20,R22
    00CD4 5F6F      SUBI	R22,0xFF
    00CD5 4F7F      SBCI	R23,0xFF
    00CD6 01FA      MOVW	R30,R20
    00CD7 800A      LDD	R0,Y+2
    00CD8 801B      LDD	R1,Y+3
    00CD9 0DE0      ADD	R30,R0
    00CDA 1DF1      ADC	R31,R1
    00CDB 8140      LD	R20,Z
(1778) 		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
    00CDC E280      LDI	R24,0x20
    00CDD 1784      CP	R24,R20
    00CDE F420      BCC	0x0CE3
    00CDF 324F      CPI	R20,0x2F
    00CE0 F011      BEQ	0x0CE3
    00CE1 354C      CPI	R20,0x5C
    00CE2 F409      BNE	0x0CE4
    00CE3 C087      RJMP	0x0D6B
(1779) 		if (c == '.' || i >= ni) {
    00CE4 324E      CPI	R20,0x2E
    00CE5 F029      BEQ	0x0CEB
    00CE6 800C      LDD	R0,Y+4
    00CE7 801D      LDD	R1,Y+5
    00CE8 140C      CP	R0,R12
    00CE9 041D      CPC	R1,R13
    00CEA F0A0      BCS	0x0CFF
(1780) 			if (ni != 8 || c != '.') return FR_INVALID_NAME;
    00CEB 01C6      MOVW	R24,R12
    00CEC 3088      CPI	R24,0x8
    00CED E0E0      LDI	R30,0
    00CEE 079E      CPC	R25,R30
    00CEF F411      BNE	0x0CF2
    00CF0 324E      CPI	R20,0x2E
    00CF1 F011      BEQ	0x0CF4
    00CF2 E006      LDI	R16,6
    00CF3 C0AF      RJMP	0x0DA3
(1781) 			i = 8; ni = 11;
    00CF4 E088      LDI	R24,0x8
    00CF5 E090      LDI	R25,0
    00CF6 839D      STD	Y+5,R25
    00CF7 838C      STD	Y+4,R24
    00CF8 E08B      LDI	R24,0xB
    00CF9 016C      MOVW	R12,R24
(1782) 			b <<= 2; continue;
    00CFA 8408      LDD	R0,Y+8
    00CFB 0C00      LSL	R0
    00CFC 0C00      LSL	R0
    00CFD 8608      STD	Y+8,R0
    00CFE CFD4      RJMP	0x0CD3
(1783) 		}
(1784) 		if (c >= 0x80) {				/* Extended char? */
    00CFF 3840      CPI	R20,0x80
    00D00 F018      BCS	0x0D04
(1785) 			b |= 3;						/* Eliminate NT flag */
    00D01 8588      LDD	R24,Y+8
    00D02 6083      ORI	R24,3
    00D03 8788      STD	Y+8,R24
(1786) #ifdef _EXCVT
(1787) 			c = excvt[c-0x80];			/* Upper conversion (SBCS) */
(1788) #else
(1789) #if !_DF1S	/* ASCII only cfg */
(1790) 			return FR_INVALID_NAME;
(1791) #endif
(1792) #endif
(1793) 		}
(1794) 		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
    00D04 3841      CPI	R20,0x81
    00D05 F408      BCC	0x0D07
    00D06 C039      RJMP	0x0D40
    00D07 EF8E      LDI	R24,0xFE
    00D08 1784      CP	R24,R20
    00D09 F408      BCC	0x0D0B
    00D0A C035      RJMP	0x0D40
(1795) 			d = (BYTE)p[si++];			/* Get 2nd byte */
    00D0B 015B      MOVW	R10,R22
    00D0C 5F6F      SUBI	R22,0xFF
    00D0D 4F7F      SBCI	R23,0xFF
    00D0E 01F5      MOVW	R30,R10
    00D0F 800A      LDD	R0,Y+2
    00D10 801B      LDD	R1,Y+3
    00D11 0DE0      ADD	R30,R0
    00D12 1DF1      ADC	R31,R1
    00D13 80A0      LD	R10,Z
(1796) 			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
    00D14 2D8A      MOV	R24,R10
    00D15 3480      CPI	R24,0x40
    00D16 F018      BCS	0x0D1A
    00D17 E78E      LDI	R24,0x7E
    00D18 158A      CP	R24,R10
    00D19 F430      BCC	0x0D20
    00D1A 2D8A      MOV	R24,R10
    00D1B 3880      CPI	R24,0x80
    00D1C F050      BCS	0x0D27
    00D1D EF8E      LDI	R24,0xFE
    00D1E 158A      CP	R24,R10
    00D1F F038      BCS	0x0D27
    00D20 01C6      MOVW	R24,R12
    00D21 9701      SBIW	R24,1
    00D22 800C      LDD	R0,Y+4
    00D23 801D      LDD	R1,Y+5
    00D24 1608      CP	R0,R24
    00D25 0619      CPC	R1,R25
    00D26 F010      BCS	0x0D29
(1797) 				return FR_INVALID_NAME;
    00D27 E006      LDI	R16,6
    00D28 C07A      RJMP	0x0DA3
(1798) 			sfn[i++] = c;
    00D29 80EC      LDD	R14,Y+4
    00D2A 80FD      LDD	R15,Y+5
    00D2B 01C7      MOVW	R24,R14
    00D2C 9601      ADIW	R24,1
    00D2D 839D      STD	Y+5,R25
    00D2E 838C      STD	Y+4,R24
    00D2F 01F7      MOVW	R30,R14
    00D30 800E      LDD	R0,Y+6
    00D31 801F      LDD	R1,Y+7
    00D32 0DE0      ADD	R30,R0
    00D33 1DF1      ADC	R31,R1
    00D34 8340      ST	Z,R20
(1799) 			sfn[i++] = d;
    00D35 017C      MOVW	R14,R24
    00D36 9601      ADIW	R24,1
    00D37 839D      STD	Y+5,R25
    00D38 838C      STD	Y+4,R24
    00D39 01F7      MOVW	R30,R14
    00D3A 800E      LDD	R0,Y+6
    00D3B 801F      LDD	R1,Y+7
    00D3C 0DE0      ADD	R30,R0
    00D3D 1DF1      ADC	R31,R1
    00D3E 82A0      ST	Z,R10
(1800) 		} else {						/* Single byte code */
    00D3F CF93      RJMP	0x0CD3
(1801) 			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c))	/* Reject illegal chrs for SFN */
    00D40 2F24      MOV	R18,R20
    00D41 2733      CLR	R19
    00D42 E000      LDI	R16,0
    00D43 E011      LDI	R17,1
    00D44 940E 0169 CALL	ff.c:chk_chr
    00D46 0158      MOVW	R10,R16
    00D47 3000      CPI	R16,0
    00D48 0701      CPC	R16,R17
    00D49 F011      BEQ	0x0D4C
(1802) 				return FR_INVALID_NAME;
    00D4A E006      LDI	R16,6
    00D4B C057      RJMP	0x0DA3
(1803) 			if (IsUpper(c)) {			/* ASCII large capital? */
    00D4C 3441      CPI	R20,0x41
    00D4D F038      BCS	0x0D55
    00D4E E58A      LDI	R24,0x5A
    00D4F 1784      CP	R24,R20
    00D50 F020      BCS	0x0D55
(1804) 				b |= 2;
    00D51 8588      LDD	R24,Y+8
    00D52 6082      ORI	R24,2
    00D53 8788      STD	Y+8,R24
(1805) 			} else {
    00D54 C009      RJMP	0x0D5E
(1806) 				if (IsLower(c)) {		/* ASCII small capital? */
    00D55 3641      CPI	R20,0x61
    00D56 F038      BCS	0x0D5E
    00D57 E78A      LDI	R24,0x7A
    00D58 1784      CP	R24,R20
    00D59 F020      BCS	0x0D5E
(1807) 					b |= 1; c -= 0x20;
    00D5A 8588      LDD	R24,Y+8
    00D5B 6081      ORI	R24,1
    00D5C 8788      STD	Y+8,R24
    00D5D 5240      SUBI	R20,0x20
(1808) 				}
(1809) 			}
(1810) 			sfn[i++] = c;
    00D5E 80AC      LDD	R10,Y+4
    00D5F 80BD      LDD	R11,Y+5
    00D60 01C5      MOVW	R24,R10
    00D61 9601      ADIW	R24,1
    00D62 839D      STD	Y+5,R25
    00D63 838C      STD	Y+4,R24
    00D64 01F5      MOVW	R30,R10
    00D65 800E      LDD	R0,Y+6
    00D66 801F      LDD	R1,Y+7
    00D67 0DE0      ADD	R30,R0
    00D68 1DF1      ADC	R31,R1
    00D69 8340      ST	Z,R20
    00D6A CF68      RJMP	0x0CD3
(1811) 		}
(1812) 	}
(1813) 	*path = &p[si];						/* Return pointer to the next segment */
    00D6B 011B      MOVW	R2,R22
    00D6C 800A      LDD	R0,Y+2
    00D6D 801B      LDD	R1,Y+3
    00D6E 0C20      ADD	R2,R0
    00D6F 1C31      ADC	R3,R1
    00D70 89EB      LDD	R30,Y+19
    00D71 89FC      LDD	R31,Y+20
    00D72 8231      STD	Z+1,R3
    00D73 8220      ST	Z,R2
(1814) 	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
    00D74 E280      LDI	R24,0x20
    00D75 1784      CP	R24,R20
    00D76 F018      BCS	0x0D7A
    00D77 E064      LDI	R22,4
    00D78 E070      LDI	R23,0
    00D79 C002      RJMP	0x0D7C
    00D7A 2766      CLR	R22
    00D7B 2777      CLR	R23
    00D7C 2F46      MOV	R20,R22
(1815) 
(1816) 	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
    00D7D 800C      LDD	R0,Y+4
    00D7E 801D      LDD	R1,Y+5
    00D7F 2000      TST	R0
    00D80 F421      BNE	0x0D85
    00D81 2011      TST	R1
    00D82 F411      BNE	0x0D85
    00D83 E006      LDI	R16,6
    00D84 C01E      RJMP	0x0DA3
(1817) 	if (sfn[0] == DDE) sfn[0] = NDDE;	/* When first char collides with DDE, replace it with 0x05 */
    00D85 81EE      LDD	R30,Y+6
    00D86 81FF      LDD	R31,Y+7
    00D87 8180      LD	R24,Z
    00D88 3E85      CPI	R24,0xE5
    00D89 F411      BNE	0x0D8C
    00D8A E085      LDI	R24,5
    00D8B 8380      ST	Z,R24
(1818) 
(1819) 	if (ni == 8) b <<= 2;
    00D8C 01C6      MOVW	R24,R12
    00D8D 3088      CPI	R24,0x8
    00D8E E0E0      LDI	R30,0
    00D8F 079E      CPC	R25,R30
    00D90 F421      BNE	0x0D95
    00D91 8408      LDD	R0,Y+8
    00D92 0C00      LSL	R0
    00D93 0C00      LSL	R0
    00D94 8608      STD	Y+8,R0
(1820) 	if ((b & 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Name extension has only small capital) */
    00D95 8588      LDD	R24,Y+8
    00D96 7083      ANDI	R24,3
    00D97 3081      CPI	R24,1
    00D98 F409      BNE	0x0D9A
    00D99 6140      ORI	R20,0x10
(1821) 	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Name body has only small capital) */
    00D9A 8588      LDD	R24,Y+8
    00D9B 708C      ANDI	R24,0xC
    00D9C 3084      CPI	R24,4
    00D9D F409      BNE	0x0D9F
    00D9E 6048      ORI	R20,0x8
(1822) 
(1823) 	sfn[NS] = c;		/* Store NT flag, File name is created */
    00D9F 81EE      LDD	R30,Y+6
    00DA0 81FF      LDD	R31,Y+7
    00DA1 8743      STD	Z+11,R20
(1824) 
(1825) 	return FR_OK;
    00DA2 2700      CLR	R16
    00DA3 9629      ADIW	R28,0x9
    00DA4 940E 2771 CALL	pop_xgsetF0FC
    00DA6 9622      ADIW	R28,2
    00DA7 9508      RET
ff.c:get_fileinfo:
  nt                   --> R12
  p                    --> R20
  dir                  --> R10
  i                    --> R12
  c                    --> R14
  fno                  --> R22
  dj                   --> R10
    00DA8 940E 277C CALL	push_xgsetF0FC
    00DAA 01B9      MOVW	R22,R18
    00DAB 0158      MOVW	R10,R16
(1826) #endif
(1827) }
(1828) 
(1829) 
(1830) 
(1831) 
(1832) /*-----------------------------------------------------------------------*/
(1833) /* Get file information from directory entry                             */
(1834) /*-----------------------------------------------------------------------*/
(1835) #if _FS_MINIMIZE <= 1
(1836) static
(1837) void get_fileinfo (		/* No return code */
(1838) 	DIR *dj,			/* Pointer to the directory object */
(1839) 	FILINFO *fno	 	/* Pointer to the file information to be filled */
(1840) )
(1841) {
(1842) 	UINT i;
(1843) 	BYTE nt, *dir;
(1844) 	TCHAR *p, c;
(1845) 
(1846) 
(1847) 	p = fno->fname;
    00DAC 01AB      MOVW	R20,R22
    00DAD 5F47      SUBI	R20,0xF7
    00DAE 4F5F      SBCI	R21,0xFF
(1848) 	if (dj->sect) {
    00DAF 01F5      MOVW	R30,R10
    00DB0 963E      ADIW	R30,0xE
    00DB1 8020      LD	R2,Z
    00DB2 8031      LDD	R3,Z+1
    00DB3 8042      LDD	R4,Z+2
    00DB4 8053      LDD	R5,Z+3
    00DB5 9488      BCLR	0
    00DB6 2022      TST	R2
    00DB7 0432      CPC	R3,R2
    00DB8 0442      CPC	R4,R2
    00DB9 0452      CPC	R5,R2
    00DBA F409      BNE	0x0DBC
    00DBB C08A      RJMP	0x0E46
(1849) 		dir = dj->dir;
    00DBC 01F5      MOVW	R30,R10
    00DBD 88A2      LDD	R10,Z+18
    00DBE 88B3      LDD	R11,Z+19
(1850) 		nt = dir[DIR_NTres];		/* NT flag */
(1851) 		for (i = 0; i < 8; i++) {	/* Copy name body */
    00DBF 24CC      CLR	R12
    00DC0 24DD      CLR	R13
    00DC1 C014      RJMP	0x0DD6
(1852) 			c = dir[i];
    00DC2 01F6      MOVW	R30,R12
    00DC3 0DEA      ADD	R30,R10
    00DC4 1DFB      ADC	R31,R11
    00DC5 80E0      LD	R14,Z
(1853) 			if (c == ' ') break;
    00DC6 2D8E      MOV	R24,R14
    00DC7 3280      CPI	R24,0x20
    00DC8 F409      BNE	0x0DCA
    00DC9 C011      RJMP	0x0DDB
(1854) 			if (c == NDDE) c = (TCHAR)DDE;
    00DCA 2D8E      MOV	R24,R14
    00DCB 3085      CPI	R24,5
    00DCC F411      BNE	0x0DCF
    00DCD EE85      LDI	R24,0xE5
    00DCE 2EE8      MOV	R14,R24
(1855) 			if (_USE_LFN && (nt & NS_BODY) && IsUpper(c)) c += 0x20;
    00DCF C000      RJMP	0x0DD0
(1856) #if _LFN_UNICODE
(1857) 			if (IsDBCS1(c) && i < 7 && IsDBCS2(dir[i+1]))
(1858) 				c = (c << 8) | dir[++i];
(1859) 			c = ff_convert(c, 1);
(1860) 			if (!c) c = '?';
(1861) #endif
(1862) 			*p++ = c;
    00DD0 01FA      MOVW	R30,R20
    00DD1 92E1      ST	Z+,R14
    00DD2 01AF      MOVW	R20,R30
    00DD3 01C6      MOVW	R24,R12
    00DD4 9601      ADIW	R24,1
    00DD5 016C      MOVW	R12,R24
    00DD6 01C6      MOVW	R24,R12
    00DD7 3088      CPI	R24,0x8
    00DD8 E0E0      LDI	R30,0
    00DD9 079E      CPC	R25,R30
    00DDA F338      BCS	0x0DC2
(1863) 		}
(1864) 		if (dir[8] != ' ') {		/* Copy name extension */
    00DDB 01F5      MOVW	R30,R10
    00DDC 8580      LDD	R24,Z+8
    00DDD 3280      CPI	R24,0x20
    00DDE F0E1      BEQ	0x0DFB
(1865) 			*p++ = '.';
    00DDF E28E      LDI	R24,0x2E
    00DE0 01FA      MOVW	R30,R20
    00DE1 9381      ST	Z+,R24
    00DE2 01AF      MOVW	R20,R30
(1866) 			for (i = 8; i < 11; i++) {
    00DE3 E088      LDI	R24,0x8
    00DE4 E090      LDI	R25,0
    00DE5 016C      MOVW	R12,R24
    00DE6 C00F      RJMP	0x0DF6
(1867) 				c = dir[i];
    00DE7 01F6      MOVW	R30,R12
    00DE8 0DEA      ADD	R30,R10
    00DE9 1DFB      ADC	R31,R11
    00DEA 80E0      LD	R14,Z
(1868) 				if (c == ' ') break;
    00DEB 2D8E      MOV	R24,R14
    00DEC 3280      CPI	R24,0x20
    00DED F409      BNE	0x0DEF
    00DEE C00C      RJMP	0x0DFB
(1869) 				if (_USE_LFN && (nt & NS_EXT) && IsUpper(c)) c += 0x20;
    00DEF C000      RJMP	0x0DF0
(1870) #if _LFN_UNICODE
(1871) 				if (IsDBCS1(c) && i < 10 && IsDBCS2(dir[i+1]))
(1872) 					c = (c << 8) | dir[++i];
(1873) 				c = ff_convert(c, 1);
(1874) 				if (!c) c = '?';
(1875) #endif
(1876) 				*p++ = c;
    00DF0 01FA      MOVW	R30,R20
    00DF1 92E1      ST	Z+,R14
    00DF2 01AF      MOVW	R20,R30
    00DF3 01C6      MOVW	R24,R12
    00DF4 9601      ADIW	R24,1
    00DF5 016C      MOVW	R12,R24
    00DF6 01C6      MOVW	R24,R12
    00DF7 308B      CPI	R24,0xB
    00DF8 E0E0      LDI	R30,0
    00DF9 079E      CPC	R25,R30
    00DFA F360      BCS	0x0DE7
(1877) 			}
(1878) 		}
(1879) 		fno->fattrib = dir[DIR_Attr];				/* Attribute */
    00DFB 01F5      MOVW	R30,R10
    00DFC 8423      LDD	R2,Z+11
    00DFD 01FB      MOVW	R30,R22
    00DFE 8620      STD	Z+8,R2
(1880) 		fno->fsize = LD_DWORD(dir+DIR_FileSize);	/* Size */
    00DFF E188      LDI	R24,0x18
    00E00 E090      LDI	R25,0
    00E01 01F5      MOVW	R30,R10
    00E02 8D07      LDD	R16,Z+31
    00E03 2711      CLR	R17
    00E04 2722      CLR	R18
    00E05 2733      CLR	R19
    00E06 938A      ST	-Y,R24
    00E07 940E 27F7 CALL	lsl32
    00E09 0118      MOVW	R2,R16
    00E0A 0129      MOVW	R4,R18
    00E0B 01F5      MOVW	R30,R10
    00E0C 8C66      LDD	R6,Z+30
    00E0D 2477      CLR	R7
    00E0E 2488      CLR	R8
    00E0F 2499      CLR	R9
    00E10 0143      MOVW	R8,R6
    00E11 2466      CLR	R6
    00E12 2477      CLR	R7
    00E13 2826      OR	R2,R6
    00E14 2837      OR	R3,R7
    00E15 2848      OR	R4,R8
    00E16 2859      OR	R5,R9
    00E17 8C65      LDD	R6,Z+29
    00E18 2477      CLR	R7
    00E19 2C76      MOV	R7,R6
    00E1A 2466      CLR	R6
    00E1B 2488      CLR	R8
    00E1C 2499      CLR	R9
    00E1D 2826      OR	R2,R6
    00E1E 2837      OR	R3,R7
    00E1F 2848      OR	R4,R8
    00E20 2859      OR	R5,R9
    00E21 8C64      LDD	R6,Z+28
    00E22 2477      CLR	R7
    00E23 2488      CLR	R8
    00E24 2499      CLR	R9
    00E25 2826      OR	R2,R6
    00E26 2837      OR	R3,R7
    00E27 2848      OR	R4,R8
    00E28 2859      OR	R5,R9
    00E29 01FB      MOVW	R30,R22
    00E2A 8220      ST	Z,R2
    00E2B 8231      STD	Z+1,R3
    00E2C 8242      STD	Z+2,R4
    00E2D 8253      STD	Z+3,R5
(1881) 		fno->fdate = LD_WORD(dir+DIR_WrtDate);		/* Date */
    00E2E 01F5      MOVW	R30,R10
    00E2F 8C20      LDD	R2,Z+24
    00E30 2433      CLR	R3
    00E31 8C41      LDD	R4,Z+25
    00E32 2455      CLR	R5
    00E33 2C54      MOV	R5,R4
    00E34 2444      CLR	R4
    00E35 2842      OR	R4,R2
    00E36 2853      OR	R5,R3
    00E37 01FB      MOVW	R30,R22
    00E38 8255      STD	Z+5,R5
    00E39 8244      STD	Z+4,R4
(1882) 		fno->ftime = LD_WORD(dir+DIR_WrtTime);		/* Time */
    00E3A 01F5      MOVW	R30,R10
    00E3B 8826      LDD	R2,Z+22
    00E3C 2433      CLR	R3
    00E3D 8847      LDD	R4,Z+23
    00E3E 2455      CLR	R5
    00E3F 2C54      MOV	R5,R4
    00E40 2444      CLR	R4
    00E41 2842      OR	R4,R2
    00E42 2853      OR	R5,R3
    00E43 01FB      MOVW	R30,R22
    00E44 8257      STD	Z+7,R5
    00E45 8246      STD	Z+6,R4
(1883) 	}
(1884) 	*p = 0;		/* Terminate SFN str by a \0 */
    00E46 2422      CLR	R2
    00E47 01FA      MOVW	R30,R20
    00E48 8220      ST	Z,R2
    00E49 940C 2771 JMP	pop_xgsetF0FC
ff.c:follow_path:
  ns                   --> R10
  res                  --> R20
  dir                  --> R10
  path                 --> Y,+6
  dj                   --> R22
    00E4B 933A      ST	-Y,R19
    00E4C 932A      ST	-Y,R18
    00E4D 940E 279B CALL	push_xgsetF00C
    00E4F 01B8      MOVW	R22,R16
(1885) 
(1886) #if _USE_LFN
(1887) 	if (fno->lfname && fno->lfsize) {
(1888) 		TCHAR *tp = fno->lfname;
(1889) 		WCHAR w, *lfn;
(1890) 
(1891) 		i = 0;
(1892) 		if (dj->sect && dj->lfn_idx != 0xFFFF) {/* Get LFN if available */
(1893) 			lfn = dj->lfn;
(1894) 			while ((w = *lfn++) != 0) {			/* Get an LFN char */
(1895) #if !_LFN_UNICODE
(1896) 				w = ff_convert(w, 0);			/* Unicode -> OEM conversion */
(1897) 				if (!w) { i = 0; break; }		/* Could not convert, no LFN */
(1898) 				if (_DF1S && w >= 0x100)		/* Put 1st byte if it is a DBC (always false on SBCS cfg) */
(1899) 					tp[i++] = (TCHAR)(w >> 8);
(1900) #endif
(1901) 				if (i >= fno->lfsize - 1) { i = 0; break; }	/* Buffer overflow, no LFN */
(1902) 				tp[i++] = (TCHAR)w;
(1903) 			}
(1904) 		}
(1905) 		tp[i] = 0;	/* Terminate the LFN str by a \0 */
(1906) 	}
(1907) #endif
(1908) }
(1909) #endif /* _FS_MINIMIZE <= 1 */
(1910) 
(1911) 
(1912) 
(1913) 
(1914) /*-----------------------------------------------------------------------*/
(1915) /* Follow a file path                                                    */
(1916) /*-----------------------------------------------------------------------*/
(1917) 
(1918) static
(1919) FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
(1920) 	DIR *dj,			/* Directory object to return last directory and found object */
(1921) 	const TCHAR *path	/* Full-path string to find a file or directory */
(1922) )
(1923) {
(1924) 	FRESULT res;
(1925) 	BYTE *dir, ns;
(1926) 
(1927) 
(1928) #if _FS_RPATH
(1929) 	if (*path == '/' || *path == '\\') { /* There is a heading separator */
(1930) 		path++;	dj->sclust = 0;		/* Strip it and start from the root dir */
(1931) 	} else {							/* No heading separator */
(1932) 		dj->sclust = dj->fs->cdir;	/* Start from the current dir */
(1933) 	}
(1934) #else
(1935) 	if (*path == '/' || *path == '\\')	/* Strip heading separator if exist */
    00E50 81EE      LDD	R30,Y+6
    00E51 81FF      LDD	R31,Y+7
    00E52 8020      LD	R2,Z
    00E53 2433      CLR	R3
    00E54 2D82      MOV	R24,R2
    00E55 328F      CPI	R24,0x2F
    00E56 F011      BEQ	0x0E59
    00E57 358C      CPI	R24,0x5C
    00E58 F429      BNE	0x0E5E
(1936) 		path++;
    00E59 818E      LDD	R24,Y+6
    00E5A 819F      LDD	R25,Y+7
    00E5B 9601      ADIW	R24,1
    00E5C 839F      STD	Y+7,R25
    00E5D 838E      STD	Y+6,R24
(1937) 	dj->sclust = 0;						/* Start from the root dir */
    00E5E 01FB      MOVW	R30,R22
    00E5F 9636      ADIW	R30,6
    00E60 E080      LDI	R24,0
    00E61 8380      ST	Z,R24
    00E62 8381      STD	Z+1,R24
    00E63 8382      STD	Z+2,R24
    00E64 8383      STD	Z+3,R24
(1938) #endif
(1939) 
(1940) 	if ((UINT)*path < ' ') {			/* Nul path means the start directory itself */
    00E65 81EE      LDD	R30,Y+6
    00E66 81FF      LDD	R31,Y+7
    00E67 8180      LD	R24,Z
    00E68 2799      CLR	R25
    00E69 3280      CPI	R24,0x20
    00E6A E0E0      LDI	R30,0
    00E6B 079E      CPC	R25,R30
    00E6C F458      BCC	0x0E78
(1941) 		res = dir_sdi(dj, 0);
    00E6D 2722      CLR	R18
    00E6E 2733      CLR	R19
    00E6F 018B      MOVW	R16,R22
    00E70 DA84      RCALL	ff.c:dir_sdi
    00E71 2F40      MOV	R20,R16
(1942) 		dj->dir = 0;
    00E72 2422      CLR	R2
    00E73 2433      CLR	R3
    00E74 01FB      MOVW	R30,R22
    00E75 8A33      STD	Z+19,R3
    00E76 8A22      STD	Z+18,R2
(1943) 
(1944) 	} else {							/* Follow path */
    00E77 C052      RJMP	0x0ECA
(1945) 		for (;;) {
(1946) 			res = create_name(dj, &path);	/* Get a segment */
    00E78 019E      MOVW	R18,R28
    00E79 5F2A      SUBI	R18,0xFA
    00E7A 4F3F      SBCI	R19,0xFF
    00E7B 018B      MOVW	R16,R22
    00E7C DE23      RCALL	ff.c:create_name
    00E7D 2EA0      MOV	R10,R16
    00E7E 2D4A      MOV	R20,R10
(1947) 			if (res != FR_OK) break;
    00E7F 2300      TST	R16
    00E80 F009      BEQ	0x0E82
    00E81 C048      RJMP	0x0ECA
(1948) 			res = dir_find(dj);				/* Find it */
    00E82 018B      MOVW	R16,R22
    00E83 DD29      RCALL	ff.c:dir_find
    00E84 2EA0      MOV	R10,R16
    00E85 2D4A      MOV	R20,R10
(1949) 			ns = *(dj->fn+NS);
    00E86 01FB      MOVW	R30,R22
    00E87 93AF      PUSH	R26
    00E88 93BF      PUSH	R27
    00E89 89A4      LDD	R26,Z+20
    00E8A 89B5      LDD	R27,Z+21
    00E8B 01FD      MOVW	R30,R26
    00E8C 91BF      POP	R27
    00E8D 91AF      POP	R26
    00E8E 84A3      LDD	R10,Z+11
(1950) 			if (res != FR_OK) {				/* Failed to find the object */
    00E8F 2300      TST	R16
    00E90 F049      BEQ	0x0E9A
(1951) 				if (res != FR_NO_FILE) break;	/* Abort if any hard error occured */
    00E91 3004      CPI	R16,4
    00E92 F009      BEQ	0x0E94
    00E93 C036      RJMP	0x0ECA
(1952) 				/* Object not found */
(1953) 				if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exit */
    00E94 C001      RJMP	0x0E96
(1954) 					dj->sclust = 0; dj->dir = 0;	/* It is the root dir */
(1955) 					res = FR_OK;
(1956) 					if (!(ns & NS_LAST)) continue;
    00E95 CFE2      RJMP	0x0E78
(1957) 				} else {							/* Could not find the object */
(1958) 					if (!(ns & NS_LAST)) res = FR_NO_PATH;
    00E96 FCA2      SBRC	R10,2
    00E97 C032      RJMP	0x0ECA
    00E98 E045      LDI	R20,5
(1959) 				}
(1960) 				break;
    00E99 C030      RJMP	0x0ECA
(1961) 			}
(1962) 			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
    00E9A FEA2      SBRS	R10,2
    00E9B C001      RJMP	0x0E9D
    00E9C C02D      RJMP	0x0ECA
(1963) 			dir = dj->dir;						/* There is next segment. Follow the sub directory */
    00E9D 01FB      MOVW	R30,R22
    00E9E 88A2      LDD	R10,Z+18
    00E9F 88B3      LDD	R11,Z+19
(1964) 			if (!(dir[DIR_Attr] & AM_DIR)) {	/* Cannot follow because it is a file */
    00EA0 01F5      MOVW	R30,R10
    00EA1 8423      LDD	R2,Z+11
    00EA2 FC24      SBRC	R2,4
    00EA3 C002      RJMP	0x0EA6
(1965) 				res = FR_NO_PATH; break;
    00EA4 E045      LDI	R20,5
    00EA5 C024      RJMP	0x0ECA
(1966) 			}
(1967) 			dj->sclust = LD_CLUST(dir);
    00EA6 01F5      MOVW	R30,R10
    00EA7 8C22      LDD	R2,Z+26
    00EA8 2433      CLR	R3
    00EA9 8C43      LDD	R4,Z+27
    00EAA 2455      CLR	R5
    00EAB 2C54      MOV	R5,R4
    00EAC 2444      CLR	R4
    00EAD 2842      OR	R4,R2
    00EAE 2853      OR	R5,R3
    00EAF 0112      MOVW	R2,R4
    00EB0 2444      CLR	R4
    00EB1 2455      CLR	R5
    00EB2 8864      LDD	R6,Z+20
    00EB3 2477      CLR	R7
    00EB4 8885      LDD	R8,Z+21
    00EB5 2499      CLR	R9
    00EB6 2C98      MOV	R9,R8
    00EB7 2488      CLR	R8
    00EB8 2886      OR	R8,R6
    00EB9 2897      OR	R9,R7
    00EBA 0134      MOVW	R6,R8
    00EBB 2488      CLR	R8
    00EBC 2499      CLR	R9
    00EBD 0143      MOVW	R8,R6
    00EBE 2466      CLR	R6
    00EBF 2477      CLR	R7
    00EC0 2862      OR	R6,R2
    00EC1 2873      OR	R7,R3
    00EC2 2884      OR	R8,R4
    00EC3 2895      OR	R9,R5
    00EC4 01FB      MOVW	R30,R22
    00EC5 8266      STD	Z+6,R6
    00EC6 8277      STD	Z+7,R7
    00EC7 8680      STD	Z+8,R8
    00EC8 8691      STD	Z+9,R9
    00EC9 CFAE      RJMP	0x0E78
(1968) 		}
(1969) 	}
(1970) 
(1971) 	return res;
    00ECA 2F04      MOV	R16,R20
    00ECB 940E 27A2 CALL	pop_xgsetF00C
    00ECD 9622      ADIW	R28,2
    00ECE 9508      RET
ff.c:check_fs:
  sect                 --> Y,+11
  fs                   --> R10
    00ECF 933A      ST	-Y,R19
    00ED0 932A      ST	-Y,R18
    00ED1 940E 279B CALL	push_xgsetF00C
    00ED3 0158      MOVW	R10,R16
    00ED4 9725      SBIW	R28,5
(1972) }
(1973) 
(1974) 
(1975) 
(1976) 
(1977) /*-----------------------------------------------------------------------*/
(1978) /* Load a sector and check if it is an FAT Volume Boot Record            */
(1979) /*-----------------------------------------------------------------------*/
(1980) 
(1981) static
(1982) BYTE check_fs (	/* 0:FAT-VBR, 1:Valid BR but not FAT, 2:Not a BR, 3:Disk error */
(1983) 	FATFS *fs,	/* File system object */
(1984) 	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
(1985) )
(1986) {
(1987) 	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
    00ED5 E081      LDI	R24,1
    00ED6 838C      STD	Y+4,R24
    00ED7 842B      LDD	R2,Y+11
    00ED8 843C      LDD	R3,Y+12
    00ED9 844D      LDD	R4,Y+13
    00EDA 845E      LDD	R5,Y+14
    00EDB 8228      ST	Y,R2
    00EDC 8239      STD	Y+1,R3
    00EDD 824A      STD	Y+2,R4
    00EDE 825B      STD	Y+3,R5
    00EDF 0195      MOVW	R18,R10
    00EE0 5D22      SUBI	R18,0xD2
    00EE1 4F3F      SBCI	R19,0xFF
    00EE2 01F5      MOVW	R30,R10
    00EE3 8101      LDD	R16,Z+1
    00EE4 940E 00DE CALL	_disk_read
    00EE6 2300      TST	R16
    00EE7 F011      BEQ	0x0EEA
(1988) 		return 3;
    00EE8 E003      LDI	R16,3
    00EE9 C0A8      RJMP	0x0F92
(1989) 	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
    00EEA 01F5      MOVW	R30,R10
    00EEB 5DE4      SUBI	R30,0xD4
    00EEC 4FFD      SBCI	R31,0xFD
    00EED 8020      LD	R2,Z
    00EEE 52EC      SUBI	R30,0x2C
    00EEF 40F2      SBCI	R31,2
    00EF0 2433      CLR	R3
    00EF1 5DE3      SUBI	R30,0xD3
    00EF2 4FFD      SBCI	R31,0xFD
    00EF3 8180      LD	R24,Z
    00EF4 2799      CLR	R25
    00EF5 2F98      MOV	R25,R24
    00EF6 2788      CLR	R24
    00EF7 2982      OR	R24,R2
    00EF8 2993      OR	R25,R3
    00EF9 3585      CPI	R24,0x55
    00EFA EAEA      LDI	R30,0xAA
    00EFB 079E      CPC	R25,R30
    00EFC F011      BEQ	0x0EFF
(1990) 		return 2;
    00EFD E002      LDI	R16,2
    00EFE C093      RJMP	0x0F92
(1991) 
(1992) 	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
    00EFF E188      LDI	R24,0x18
    00F00 E090      LDI	R25,0
    00F01 01F5      MOVW	R30,R10
    00F02 59E9      SUBI	R30,0x99
    00F03 4FFF      SBCI	R31,0xFF
    00F04 8100      LD	R16,Z
    00F05 2711      CLR	R17
    00F06 2722      CLR	R18
    00F07 2733      CLR	R19
    00F08 938A      ST	-Y,R24
    00F09 940E 27F7 CALL	lsl32
    00F0B 0118      MOVW	R2,R16
    00F0C 0129      MOVW	R4,R18
    00F0D 01F5      MOVW	R30,R10
    00F0E 59EA      SUBI	R30,0x9A
    00F0F 4FFF      SBCI	R31,0xFF
    00F10 8060      LD	R6,Z
    00F11 56E6      SUBI	R30,0x66
    00F12 40F0      SBCI	R31,0
    00F13 2477      CLR	R7
    00F14 2488      CLR	R8
    00F15 2499      CLR	R9
    00F16 0143      MOVW	R8,R6
    00F17 2466      CLR	R6
    00F18 2477      CLR	R7
    00F19 2826      OR	R2,R6
    00F1A 2837      OR	R3,R7
    00F1B 2848      OR	R4,R8
    00F1C 2859      OR	R5,R9
    00F1D 59EB      SUBI	R30,0x9B
    00F1E 4FFF      SBCI	R31,0xFF
    00F1F 8060      LD	R6,Z
    00F20 56E5      SUBI	R30,0x65
    00F21 40F0      SBCI	R31,0
    00F22 2477      CLR	R7
    00F23 2C76      MOV	R7,R6
    00F24 2466      CLR	R6
    00F25 2488      CLR	R8
    00F26 2499      CLR	R9
    00F27 2826      OR	R2,R6
    00F28 2837      OR	R3,R7
    00F29 2848      OR	R4,R8
    00F2A 2859      OR	R5,R9
    00F2B 59EC      SUBI	R30,0x9C
    00F2C 4FFF      SBCI	R31,0xFF
    00F2D 8060      LD	R6,Z
    00F2E 2477      CLR	R7
    00F2F 2488      CLR	R8
    00F30 2499      CLR	R9
    00F31 2826      OR	R2,R6
    00F32 2837      OR	R3,R7
    00F33 2848      OR	R4,R8
    00F34 2859      OR	R5,R9
    00F35 EF4F      LDI	R20,0xFF
    00F36 EF5F      LDI	R21,0xFF
    00F37 EF6F      LDI	R22,0xFF
    00F38 E070      LDI	R23,0
    00F39 2224      AND	R2,R20
    00F3A 2235      AND	R3,R21
    00F3B 2246      AND	R4,R22
    00F3C 2257      AND	R5,R23
    00F3D E446      LDI	R20,0x46
    00F3E E451      LDI	R21,0x41
    00F3F E564      LDI	R22,0x54
    00F40 E070      LDI	R23,0
    00F41 1624      CP	R2,R20
    00F42 0635      CPC	R3,R21
    00F43 0646      CPC	R4,R22
    00F44 0657      CPC	R5,R23
    00F45 F411      BNE	0x0F48
(1993) 		return 0;
    00F46 2700      CLR	R16
    00F47 C04A      RJMP	0x0F92
(1994) 	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
    00F48 E188      LDI	R24,0x18
    00F49 E090      LDI	R25,0
    00F4A 01F5      MOVW	R30,R10
    00F4B 57ED      SUBI	R30,0x7D
    00F4C 4FFF      SBCI	R31,0xFF
    00F4D 8100      LD	R16,Z
    00F4E 2711      CLR	R17
    00F4F 2722      CLR	R18
    00F50 2733      CLR	R19
    00F51 938A      ST	-Y,R24
    00F52 940E 27F7 CALL	lsl32
    00F54 0118      MOVW	R2,R16
    00F55 0129      MOVW	R4,R18
    00F56 01F5      MOVW	R30,R10
    00F57 57EE      SUBI	R30,0x7E
    00F58 4FFF      SBCI	R31,0xFF
    00F59 8060      LD	R6,Z
    00F5A 58E2      SUBI	R30,0x82
    00F5B 40F0      SBCI	R31,0
    00F5C 2477      CLR	R7
    00F5D 2488      CLR	R8
    00F5E 2499      CLR	R9
    00F5F 0143      MOVW	R8,R6
    00F60 2466      CLR	R6
    00F61 2477      CLR	R7
    00F62 2826      OR	R2,R6
    00F63 2837      OR	R3,R7
    00F64 2848      OR	R4,R8
    00F65 2859      OR	R5,R9
    00F66 57EF      SUBI	R30,0x7F
    00F67 4FFF      SBCI	R31,0xFF
    00F68 8060      LD	R6,Z
    00F69 58E1      SUBI	R30,0x81
    00F6A 40F0      SBCI	R31,0
    00F6B 2477      CLR	R7
    00F6C 2C76      MOV	R7,R6
    00F6D 2466      CLR	R6
    00F6E 2488      CLR	R8
    00F6F 2499      CLR	R9
    00F70 2826      OR	R2,R6
    00F71 2837      OR	R3,R7
    00F72 2848      OR	R4,R8
    00F73 2859      OR	R5,R9
    00F74 58E0      SUBI	R30,0x80
    00F75 4FFF      SBCI	R31,0xFF
    00F76 8060      LD	R6,Z
    00F77 2477      CLR	R7
    00F78 2488      CLR	R8
    00F79 2499      CLR	R9
    00F7A 2826      OR	R2,R6
    00F7B 2837      OR	R3,R7
    00F7C 2848      OR	R4,R8
    00F7D 2859      OR	R5,R9
    00F7E EF4F      LDI	R20,0xFF
    00F7F EF5F      LDI	R21,0xFF
    00F80 EF6F      LDI	R22,0xFF
    00F81 E070      LDI	R23,0
    00F82 2224      AND	R2,R20
    00F83 2235      AND	R3,R21
    00F84 2246      AND	R4,R22
    00F85 2257      AND	R5,R23
    00F86 E446      LDI	R20,0x46
    00F87 E451      LDI	R21,0x41
    00F88 E564      LDI	R22,0x54
    00F89 E070      LDI	R23,0
    00F8A 1624      CP	R2,R20
    00F8B 0635      CPC	R3,R21
    00F8C 0646      CPC	R4,R22
    00F8D 0657      CPC	R5,R23
    00F8E F411      BNE	0x0F91
(1995) 		return 0;
    00F8F 2700      CLR	R16
    00F90 C001      RJMP	0x0F92
(1996) 
(1997) 	return 1;
    00F91 E001      LDI	R16,1
    00F92 9625      ADIW	R28,5
    00F93 940E 27A2 CALL	pop_xgsetF00C
    00F95 9622      ADIW	R28,2
    00F96 9508      RET
ff.c:chk_mounted:
  pi                   --> R10
  szbfat               --> Y,+25
  tbl                  --> R10
  p                    --> R10
  nrsv                 --> R14
  sysect               --> Y,+21
  bsect                --> Y,+17
  stat                 --> R10
  tsect                --> Y,+13
  nclst                --> Y,+9
  vol                  --> R14
  fasize               --> Y,+5
  b                    --> R14
  fmt                  --> R12
  fs                   --> Y,+37
  chk_wp               --> Y,+51
  rfs                  --> Y,+49
  path                 --> R12
    00F97 933A      ST	-Y,R19
    00F98 932A      ST	-Y,R18
    00F99 940E 277C CALL	push_xgsetF0FC
    00F9B 0168      MOVW	R12,R16
    00F9C 97A7      SBIW	R28,0x27
(1998) }
(1999) 
(2000) 
(2001) 
(2002) 
(2003) /*-----------------------------------------------------------------------*/
(2004) /* Check if the file system object is valid or not                       */
(2005) /*-----------------------------------------------------------------------*/
(2006) 
(2007) static
(2008) FRESULT chk_mounted (	/* FR_OK(0): successful, !=0: any error occurred */
(2009) 	const TCHAR **path,	/* Pointer to pointer to the path name (drive number) */
(2010) 	FATFS **rfs,		/* Pointer to pointer to the found file system object */
(2011) 	BYTE chk_wp			/* !=0: Check media write protection for write access */
(2012) )
(2013) {
(2014) 	BYTE fmt, b, pi, *tbl;
(2015) 	UINT vol;
(2016) 	DSTATUS stat;
(2017) 	DWORD bsect, fasize, tsect, sysect, nclst, szbfat;
(2018) 	WORD nrsv;
(2019) 	const TCHAR *p = *path;
    00F9D 01F6      MOVW	R30,R12
    00F9E 80A0      LD	R10,Z
    00F9F 80B1      LDD	R11,Z+1
(2020) 	FATFS *fs;
(2021) 
(2022) 	/* Get logical drive number from the path name */
(2023) 	vol = p[0] - '0';					/* Is there a drive number? */
    00FA0 01F5      MOVW	R30,R10
    00FA1 8180      LD	R24,Z
    00FA2 2799      CLR	R25
    00FA3 97C0      SBIW	R24,0x30
    00FA4 017C      MOVW	R14,R24
(2024) 	if (vol <= 9 && p[1] == ':') {		/* Found a drive number, get and strip it */
    00FA5 E089      LDI	R24,0x9
    00FA6 E090      LDI	R25,0
    00FA7 158E      CP	R24,R14
    00FA8 059F      CPC	R25,R15
    00FA9 F050      BCS	0x0FB4
    00FAA 8181      LDD	R24,Z+1
    00FAB 338A      CPI	R24,0x3A
    00FAC F439      BNE	0x0FB4
(2025) 		p += 2; *path = p;				/* Return pointer to the path name */
    00FAD 01CF      MOVW	R24,R30
    00FAE 9602      ADIW	R24,2
    00FAF 015C      MOVW	R10,R24
    00FB0 01F6      MOVW	R30,R12
    00FB1 82B1      STD	Z+1,R11
    00FB2 82A0      ST	Z,R10
(2026) 	} else {							/* No drive number is given */
    00FB3 C002      RJMP	0x0FB6
(2027) #if _FS_RPATH
(2028) 		vol = CurrVol;					/* Use current drive */
(2029) #else
(2030) 		vol = 0;						/* Use drive 0 */
    00FB4 24EE      CLR	R14
    00FB5 24FF      CLR	R15
(2031) #endif
(2032) 	}
(2033) 
(2034) 	/* Check if the file system object is valid or not */
(2035) 	if (vol >= _VOLUMES) 				/* Is the drive number valid? */
    00FB6 01C7      MOVW	R24,R14
    00FB7 3081      CPI	R24,1
    00FB8 E0E0      LDI	R30,0
    00FB9 079E      CPC	R25,R30
    00FBA F010      BCS	0x0FBD
(2036) 		return FR_INVALID_DRIVE;
    00FBB E00B      LDI	R16,0xB
    00FBC C4CF      RJMP	0x148C
(2037) 	*rfs = fs = FatFs[vol];				/* Return pointer to the corresponding file system object */
    00FBD EB83      LDI	R24,0xB3
    00FBE E091      LDI	R25,1
    00FBF 01F7      MOVW	R30,R14
    00FC0 0FEE      LSL	R30
    00FC1 1FFF      ROL	R31
    00FC2 0FE8      ADD	R30,R24
    00FC3 1FF9      ADC	R31,R25
    00FC4 8020      LD	R2,Z
    00FC5 8031      LDD	R3,Z+1
    00FC6 A23E      STD	Y+38,R3
    00FC7 A22D      STD	Y+37,R2
    00FC8 A9E9      LDD	R30,Y+49
    00FC9 A9FA      LDD	R31,Y+50
    00FCA 8231      STD	Z+1,R3
    00FCB 8220      ST	Z,R2
(2038) 	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
    00FCC 0101      MOVW	R0,R2
    00FCD 2022      TST	R2
    00FCE F421      BNE	0x0FD3
    00FCF 2033      TST	R3
    00FD0 F411      BNE	0x0FD3
    00FD1 E00C      LDI	R16,0xC
    00FD2 C4B9      RJMP	0x148C
(2039) 
(2040) 	ENTER_FF(fs);						/* Lock file system */
(2041) 
(2042) 	if (fs->fs_type) {					/* If the logical drive has been mounted */
    00FD3 A1ED      LDD	R30,Y+37
    00FD4 A1FE      LDD	R31,Y+38
    00FD5 8020      LD	R2,Z
    00FD6 2022      TST	R2
    00FD7 F079      BEQ	0x0FE7
(2043) 		stat = disk_status(fs->drv);
    00FD8 8101      LDD	R16,Z+1
    00FD9 940E 00D8 CALL	_disk_status
    00FDB 2EA0      MOV	R10,R16
(2044) 		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized (has not been changed), */
    00FDC FD00      SBRC	R16,0
    00FDD C009      RJMP	0x0FE7
(2045) 			if (!_FS_READONLY && chk_wp && (stat & STA_PROTECT))	/* Check write protection if needed */
    00FDE A80B      LDD	R0,Y+51
    00FDF 2000      TST	R0
    00FE0 F021      BEQ	0x0FE5
    00FE1 FF02      SBRS	R16,2
    00FE2 C002      RJMP	0x0FE5
(2046) 				return FR_WRITE_PROTECTED;
    00FE3 E00A      LDI	R16,0xA
    00FE4 C4A7      RJMP	0x148C
(2047) 			return FR_OK;				/* The file system object is valid */
    00FE5 2700      CLR	R16
    00FE6 C4A5      RJMP	0x148C
(2048) 		}
(2049) 	}
(2050) 
(2051) 	/* The file system object is not valid. */
(2052) 	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */
(2053) 
(2054) 	fs->fs_type = 0;					/* Clear the file system object */
    00FE7 2422      CLR	R2
    00FE8 A1ED      LDD	R30,Y+37
    00FE9 A1FE      LDD	R31,Y+38
    00FEA 8220      ST	Z,R2
(2055) 	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
    00FEB 82E1      STD	Z+1,R14
(2056) 	stat = disk_initialize(fs->drv);	/* Initialize low level disk I/O layer */
    00FEC 8101      LDD	R16,Z+1
    00FED 940E 00C2 CALL	_disk_initialize
    00FEF 2EE0      MOV	R14,R16
    00FF0 2CAE      MOV	R10,R14
(2057) 	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
    00FF1 FF00      SBRS	R16,0
    00FF2 C002      RJMP	0x0FF5
(2058) 		return FR_NOT_READY;			/* Failed to initialize due to no media or hard error */
    00FF3 E003      LDI	R16,3
    00FF4 C497      RJMP	0x148C
(2059) 	if (!_FS_READONLY && chk_wp && (stat & STA_PROTECT))	/* Check disk write protection if needed */
    00FF5 A80B      LDD	R0,Y+51
    00FF6 2000      TST	R0
    00FF7 F021      BEQ	0x0FFC
    00FF8 FEA2      SBRS	R10,2
    00FF9 C002      RJMP	0x0FFC
(2060) 		return FR_WRITE_PROTECTED;
    00FFA E00A      LDI	R16,0xA
    00FFB C490      RJMP	0x148C
(2061) #if _MAX_SS != 512						/* Get disk sector size (variable sector size cfg only) */
(2062) 	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &fs->ssize) != RES_OK)
(2063) 		return FR_DISK_ERR;
(2064) #endif
(2065) 	/* Search FAT partition on the drive. Supports only generic partitionings, FDISK and SFD. */
(2066) 	fmt = check_fs(fs, bsect = 0);		/* Load sector 0 and check if it is an FAT-VBR (in SFD) */
    00FFC E080      LDI	R24,0
    00FFD 8B89      STD	Y+17,R24
    00FFE 8B8A      STD	Y+18,R24
    00FFF 8B8B      STD	Y+19,R24
    01000 8B8C      STD	Y+20,R24
    01001 E040      LDI	R20,0
    01002 E050      LDI	R21,0
    01003 E060      LDI	R22,0
    01004 E070      LDI	R23,0
    01005 8368      ST	Y,R22
    01006 8379      STD	Y+1,R23
    01007 019A      MOVW	R18,R20
    01008 A10D      LDD	R16,Y+37
    01009 A11E      LDD	R17,Y+38
    0100A DEC4      RCALL	ff.c:check_fs
    0100B 2EA0      MOV	R10,R16
    0100C 2CCA      MOV	R12,R10
(2067) 	if (LD2PT(vol) && !fmt) fmt = 1;	/* Force non-SFD if the volume is forced partition */
    0100D C000      RJMP	0x100E
(2068) 	if (fmt == 1) {						/* Not an FAT-VBR, the physical drive can be partitioned */
    0100E 2D8C      MOV	R24,R12
    0100F 3081      CPI	R24,1
    01010 F009      BEQ	0x1012
    01011 C04C      RJMP	0x105E
(2069) 		/* Check the partition listed in the partition table */
(2070) 		pi = LD2PT(vol);
    01012 24AA      CLR	R10
(2071) 		if (pi) pi--;
    01013 F009      BEQ	0x1015
    01014 94AA      DEC	R10
(2072) 		tbl = &fs->win[MBR_Table + pi * SZ_PTE];/* Partition table */
    01015 E100      LDI	R16,0x10
    01016 2D1A      MOV	R17,R10
    01017 0301      MULSU	R16,R17
    01018 0150      MOVW	R10,R0
    01019 A18D      LDD	R24,Y+37
    0101A A19E      LDD	R25,Y+38
    0101B 5184      SUBI	R24,0x14
    0101C 4F9E      SBCI	R25,0xFE
    0101D 0EA8      ADD	R10,R24
    0101E 1EB9      ADC	R11,R25
(2073) 		if (tbl[4]) {						/* Is the partition existing? */
    0101F 01F5      MOVW	R30,R10
    01020 8024      LDD	R2,Z+4
    01021 2022      TST	R2
    01022 F409      BNE	0x1024
    01023 C03A      RJMP	0x105E
(2074) 			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
    01024 E188      LDI	R24,0x18
    01025 E090      LDI	R25,0
    01026 8503      LDD	R16,Z+11
    01027 2711      CLR	R17
    01028 2722      CLR	R18
    01029 2733      CLR	R19
    0102A 938A      ST	-Y,R24
    0102B 940E 27F7 CALL	lsl32
    0102D 0118      MOVW	R2,R16
    0102E 0129      MOVW	R4,R18
    0102F 01F5      MOVW	R30,R10
    01030 8462      LDD	R6,Z+10
    01031 2477      CLR	R7
    01032 2488      CLR	R8
    01033 2499      CLR	R9
    01034 0143      MOVW	R8,R6
    01035 2466      CLR	R6
    01036 2477      CLR	R7
    01037 2826      OR	R2,R6
    01038 2837      OR	R3,R7
    01039 2848      OR	R4,R8
    0103A 2859      OR	R5,R9
    0103B 8461      LDD	R6,Z+9
    0103C 2477      CLR	R7
    0103D 2C76      MOV	R7,R6
    0103E 2466      CLR	R6
    0103F 2488      CLR	R8
    01040 2499      CLR	R9
    01041 2826      OR	R2,R6
    01042 2837      OR	R3,R7
    01043 2848      OR	R4,R8
    01044 2859      OR	R5,R9
    01045 9638      ADIW	R30,0x8
    01046 8060      LD	R6,Z
    01047 2477      CLR	R7
    01048 2488      CLR	R8
    01049 2499      CLR	R9
    0104A 2826      OR	R2,R6
    0104B 2837      OR	R3,R7
    0104C 2848      OR	R4,R8
    0104D 2859      OR	R5,R9
    0104E 8A29      STD	Y+17,R2
    0104F 8A3A      STD	Y+18,R3
    01050 8A4B      STD	Y+19,R4
    01051 8A5C      STD	Y+20,R5
(2075) 			fmt = check_fs(fs, bsect);		/* Check the partition */
    01052 8829      LDD	R2,Y+17
    01053 883A      LDD	R3,Y+18
    01054 884B      LDD	R4,Y+19
    01055 885C      LDD	R5,Y+20
    01056 8248      ST	Y,R4
    01057 8259      STD	Y+1,R5
    01058 0191      MOVW	R18,R2
    01059 A10D      LDD	R16,Y+37
    0105A A11E      LDD	R17,Y+38
    0105B DE73      RCALL	ff.c:check_fs
    0105C 2EA0      MOV	R10,R16
    0105D 2CCA      MOV	R12,R10
(2076) 		}
(2077) 	}
(2078) 	if (fmt == 3) return FR_DISK_ERR;
    0105E 2D8C      MOV	R24,R12
    0105F 3083      CPI	R24,3
    01060 F411      BNE	0x1063
    01061 E001      LDI	R16,1
    01062 C429      RJMP	0x148C
(2079) 	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
    01063 20CC      TST	R12
    01064 F011      BEQ	0x1067
    01065 E00D      LDI	R16,0xD
    01066 C425      RJMP	0x148C
(2080) 
(2081) 	/* An FAT volume is found. Following code initializes the file system object */
(2082) 
(2083) 	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
    01067 A1ED      LDD	R30,Y+37
    01068 A1FE      LDD	R31,Y+38
    01069 AC21      LDD	R2,Z+57
    0106A 2433      CLR	R3
    0106B AD82      LDD	R24,Z+58
    0106C 2799      CLR	R25
    0106D 2F98      MOV	R25,R24
    0106E 2788      CLR	R24
    0106F 2982      OR	R24,R2
    01070 2993      OR	R25,R3
    01071 3080      CPI	R24,0
    01072 E0E2      LDI	R30,2
    01073 079E      CPC	R25,R30
    01074 F011      BEQ	0x1077
(2084) 		return FR_NO_FILESYSTEM;
    01075 E00D      LDI	R16,0xD
    01076 C415      RJMP	0x148C
(2085) 
(2086) 	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
    01077 A1ED      LDD	R30,Y+37
    01078 A1FE      LDD	R31,Y+38
    01079 5BEC      SUBI	R30,0xBC
    0107A 4FFF      SBCI	R31,0xFF
    0107B 8020      LD	R2,Z
    0107C 54E4      SUBI	R30,0x44
    0107D 40F0      SBCI	R31,0
    0107E 2433      CLR	R3
    0107F 5BEB      SUBI	R30,0xBB
    01080 4FFF      SBCI	R31,0xFF
    01081 8040      LD	R4,Z
    01082 2455      CLR	R5
    01083 2C54      MOV	R5,R4
    01084 2444      CLR	R4
    01085 2842      OR	R4,R2
    01086 2853      OR	R5,R3
    01087 0112      MOVW	R2,R4
    01088 2444      CLR	R4
    01089 2455      CLR	R5
    0108A 822D      STD	Y+5,R2
    0108B 823E      STD	Y+6,R3
    0108C 824F      STD	Y+7,R4
    0108D 8658      STD	Y+8,R5
(2087) 	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
    0108E 802D      LDD	R2,Y+5
    0108F 803E      LDD	R3,Y+6
    01090 804F      LDD	R4,Y+7
    01091 8458      LDD	R5,Y+8
    01092 9488      BCLR	0
    01093 2022      TST	R2
    01094 0432      CPC	R3,R2
    01095 0442      CPC	R4,R2
    01096 0452      CPC	R5,R2
    01097 F009      BEQ	0x1099
    01098 C03C      RJMP	0x10D5
    01099 E188      LDI	R24,0x18
    0109A E090      LDI	R25,0
    0109B A1ED      LDD	R30,Y+37
    0109C A1FE      LDD	R31,Y+38
    0109D 5AEB      SUBI	R30,0xAB
    0109E 4FFF      SBCI	R31,0xFF
    0109F 8100      LD	R16,Z
    010A0 2711      CLR	R17
    010A1 2722      CLR	R18
    010A2 2733      CLR	R19
    010A3 938A      ST	-Y,R24
    010A4 940E 27F7 CALL	lsl32
    010A6 0118      MOVW	R2,R16
    010A7 0129      MOVW	R4,R18
    010A8 A1ED      LDD	R30,Y+37
    010A9 A1FE      LDD	R31,Y+38
    010AA 5AEC      SUBI	R30,0xAC
    010AB 4FFF      SBCI	R31,0xFF
    010AC 8060      LD	R6,Z
    010AD 55E4      SUBI	R30,0x54
    010AE 40F0      SBCI	R31,0
    010AF 2477      CLR	R7
    010B0 2488      CLR	R8
    010B1 2499      CLR	R9
    010B2 0143      MOVW	R8,R6
    010B3 2466      CLR	R6
    010B4 2477      CLR	R7
    010B5 2826      OR	R2,R6
    010B6 2837      OR	R3,R7
    010B7 2848      OR	R4,R8
    010B8 2859      OR	R5,R9
    010B9 5AED      SUBI	R30,0xAD
    010BA 4FFF      SBCI	R31,0xFF
    010BB 8060      LD	R6,Z
    010BC 55E3      SUBI	R30,0x53
    010BD 40F0      SBCI	R31,0
    010BE 2477      CLR	R7
    010BF 2C76      MOV	R7,R6
    010C0 2466      CLR	R6
    010C1 2488      CLR	R8
    010C2 2499      CLR	R9
    010C3 2826      OR	R2,R6
    010C4 2837      OR	R3,R7
    010C5 2848      OR	R4,R8
    010C6 2859      OR	R5,R9
    010C7 5AEE      SUBI	R30,0xAE
    010C8 4FFF      SBCI	R31,0xFF
    010C9 8060      LD	R6,Z
    010CA 2477      CLR	R7
    010CB 2488      CLR	R8
    010CC 2499      CLR	R9
    010CD 2826      OR	R2,R6
    010CE 2837      OR	R3,R7
    010CF 2848      OR	R4,R8
    010D0 2859      OR	R5,R9
    010D1 822D      STD	Y+5,R2
    010D2 823E      STD	Y+6,R3
    010D3 824F      STD	Y+7,R4
    010D4 8658      STD	Y+8,R5
(2088) 	fs->fsize = fasize;
    010D5 802D      LDD	R2,Y+5
    010D6 803E      LDD	R3,Y+6
    010D7 804F      LDD	R4,Y+7
    010D8 8458      LDD	R5,Y+8
    010D9 A1ED      LDD	R30,Y+37
    010DA A1FE      LDD	R31,Y+38
    010DB 8E22      STD	Z+26,R2
    010DC 8E33      STD	Z+27,R3
    010DD 8E44      STD	Z+28,R4
    010DE 8E55      STD	Z+29,R5
(2089) 
(2090) 	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
    010DF ACA6      LDD	R10,Z+62
    010E0 2CEA      MOV	R14,R10
    010E1 82A3      STD	Z+3,R10
(2091) 	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
    010E2 2D8E      MOV	R24,R14
    010E3 3081      CPI	R24,1
    010E4 F021      BEQ	0x10E9
    010E5 3082      CPI	R24,2
    010E6 F011      BEQ	0x10E9
    010E7 E00D      LDI	R16,0xD
    010E8 C3A3      RJMP	0x148C
(2092) 	fasize *= b;										/* Number of sectors for FAT area */
    010E9 2C2E      MOV	R2,R14
    010EA 2433      CLR	R3
    010EB 2444      CLR	R4
    010EC 2455      CLR	R5
    010ED 810D      LDD	R16,Y+5
    010EE 811E      LDD	R17,Y+6
    010EF 812F      LDD	R18,Y+7
    010F0 8538      LDD	R19,Y+8
    010F1 925A      ST	-Y,R5
    010F2 924A      ST	-Y,R4
    010F3 923A      ST	-Y,R3
    010F4 922A      ST	-Y,R2
    010F5 940E 2728 CALL	empy32s|empy32u
    010F7 830D      STD	Y+5,R16
    010F8 831E      STD	Y+6,R17
    010F9 832F      STD	Y+7,R18
    010FA 8738      STD	Y+8,R19
(2093) 
(2094) 	fs->csize = b = fs->win[BPB_SecPerClus];			/* Number of sectors per cluster */
    010FB A1ED      LDD	R30,Y+37
    010FC A1FE      LDD	R31,Y+38
    010FD ACA3      LDD	R10,Z+59
    010FE 2CEA      MOV	R14,R10
    010FF 82A2      STD	Z+2,R10
(2095) 	if (!b || (b & (b - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
    01100 20AA      TST	R10
    01101 F029      BEQ	0x1107
    01102 2D8E      MOV	R24,R14
    01103 5081      SUBI	R24,1
    01104 2C2E      MOV	R2,R14
    01105 2228      AND	R2,R24
    01106 F011      BEQ	0x1109
    01107 E00D      LDI	R16,0xD
    01108 C383      RJMP	0x148C
(2096) 
(2097) 	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
    01109 A1ED      LDD	R30,Y+37
    0110A A1FE      LDD	R31,Y+38
    0110B AC27      LDD	R2,Z+63
    0110C 2433      CLR	R3
    0110D 5CE0      SUBI	R30,0xC0
    0110E 4FFF      SBCI	R31,0xFF
    0110F 8040      LD	R4,Z
    01110 54E0      SUBI	R30,0x40
    01111 40F0      SBCI	R31,0
    01112 2455      CLR	R5
    01113 2C54      MOV	R5,R4
    01114 2444      CLR	R4
    01115 2842      OR	R4,R2
    01116 2853      OR	R5,R3
    01117 8651      STD	Z+9,R5
    01118 8640      STD	Z+8,R4
(2098) 	if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be sector aligned) */
    01119 8580      LDD	R24,Z+8
    0111A 8591      LDD	R25,Z+9
    0111B 708F      ANDI	R24,0xF
    0111C 7090      ANDI	R25,0
    0111D 3080      CPI	R24,0
    0111E 0789      CPC	R24,R25
    0111F F011      BEQ	0x1122
    01120 E00D      LDI	R16,0xD
    01121 C36A      RJMP	0x148C
(2099) 
(2100) 	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the volume */
    01122 A1ED      LDD	R30,Y+37
    01123 A1FE      LDD	R31,Y+38
    01124 5BEF      SUBI	R30,0xBF
    01125 4FFF      SBCI	R31,0xFF
    01126 8020      LD	R2,Z
    01127 54E1      SUBI	R30,0x41
    01128 40F0      SBCI	R31,0
    01129 2433      CLR	R3
    0112A 5BEE      SUBI	R30,0xBE
    0112B 4FFF      SBCI	R31,0xFF
    0112C 8040      LD	R4,Z
    0112D 2455      CLR	R5
    0112E 2C54      MOV	R5,R4
    0112F 2444      CLR	R4
    01130 2842      OR	R4,R2
    01131 2853      OR	R5,R3
    01132 0112      MOVW	R2,R4
    01133 2444      CLR	R4
    01134 2455      CLR	R5
    01135 862D      STD	Y+13,R2
    01136 863E      STD	Y+14,R3
    01137 864F      STD	Y+15,R4
    01138 8A58      STD	Y+16,R5
(2101) 	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
    01139 842D      LDD	R2,Y+13
    0113A 843E      LDD	R3,Y+14
    0113B 844F      LDD	R4,Y+15
    0113C 8858      LDD	R5,Y+16
    0113D 9488      BCLR	0
    0113E 2022      TST	R2
    0113F 0432      CPC	R3,R2
    01140 0442      CPC	R4,R2
    01141 0452      CPC	R5,R2
    01142 F009      BEQ	0x1144
    01143 C03C      RJMP	0x1180
    01144 E188      LDI	R24,0x18
    01145 E090      LDI	R25,0
    01146 A1ED      LDD	R30,Y+37
    01147 A1FE      LDD	R31,Y+38
    01148 5AEF      SUBI	R30,0xAF
    01149 4FFF      SBCI	R31,0xFF
    0114A 8100      LD	R16,Z
    0114B 2711      CLR	R17
    0114C 2722      CLR	R18
    0114D 2733      CLR	R19
    0114E 938A      ST	-Y,R24
    0114F 940E 27F7 CALL	lsl32
    01151 0118      MOVW	R2,R16
    01152 0129      MOVW	R4,R18
    01153 A1ED      LDD	R30,Y+37
    01154 A1FE      LDD	R31,Y+38
    01155 5BE0      SUBI	R30,0xB0
    01156 4FFF      SBCI	R31,0xFF
    01157 8060      LD	R6,Z
    01158 55E0      SUBI	R30,0x50
    01159 40F0      SBCI	R31,0
    0115A 2477      CLR	R7
    0115B 2488      CLR	R8
    0115C 2499      CLR	R9
    0115D 0143      MOVW	R8,R6
    0115E 2466      CLR	R6
    0115F 2477      CLR	R7
    01160 2826      OR	R2,R6
    01161 2837      OR	R3,R7
    01162 2848      OR	R4,R8
    01163 2859      OR	R5,R9
    01164 5BE1      SUBI	R30,0xB1
    01165 4FFF      SBCI	R31,0xFF
    01166 8060      LD	R6,Z
    01167 54EF      SUBI	R30,0x4F
    01168 40F0      SBCI	R31,0
    01169 2477      CLR	R7
    0116A 2C76      MOV	R7,R6
    0116B 2466      CLR	R6
    0116C 2488      CLR	R8
    0116D 2499      CLR	R9
    0116E 2826      OR	R2,R6
    0116F 2837      OR	R3,R7
    01170 2848      OR	R4,R8
    01171 2859      OR	R5,R9
    01172 5BE2      SUBI	R30,0xB2
    01173 4FFF      SBCI	R31,0xFF
    01174 8060      LD	R6,Z
    01175 2477      CLR	R7
    01176 2488      CLR	R8
    01177 2499      CLR	R9
    01178 2826      OR	R2,R6
    01179 2837      OR	R3,R7
    0117A 2848      OR	R4,R8
    0117B 2859      OR	R5,R9
    0117C 862D      STD	Y+13,R2
    0117D 863E      STD	Y+14,R3
    0117E 864F      STD	Y+15,R4
    0117F 8A58      STD	Y+16,R5
(2102) 
(2103) 	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
    01180 A1ED      LDD	R30,Y+37
    01181 A1FE      LDD	R31,Y+38
    01182 AC24      LDD	R2,Z+60
    01183 2433      CLR	R3
    01184 ACE5      LDD	R14,Z+61
    01185 24FF      CLR	R15
    01186 2CFE      MOV	R15,R14
    01187 24EE      CLR	R14
    01188 28E2      OR	R14,R2
    01189 28F3      OR	R15,R3
(2104) 	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */
    0118A 20EE      TST	R14
    0118B F421      BNE	0x1190
    0118C 20FF      TST	R15
    0118D F411      BNE	0x1190
    0118E E00D      LDI	R16,0xD
    0118F C2FC      RJMP	0x148C
(2105) 
(2106) 	/* Determine the FAT sub type */
(2107) 	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
    01190 802D      LDD	R2,Y+5
    01191 803E      LDD	R3,Y+6
    01192 804F      LDD	R4,Y+7
    01193 8458      LDD	R5,Y+8
    01194 0137      MOVW	R6,R14
    01195 2488      CLR	R8
    01196 2499      CLR	R9
    01197 0C62      ADD	R6,R2
    01198 1C73      ADC	R7,R3
    01199 1C84      ADC	R8,R4
    0119A 1C95      ADC	R9,R5
    0119B A1ED      LDD	R30,Y+37
    0119C A1FE      LDD	R31,Y+38
    0119D 9638      ADIW	R30,0x8
    0119E 8020      LD	R2,Z
    0119F 8031      LDD	R3,Z+1
    011A0 9436      LSR	R3
    011A1 9427      ROR	R2
    011A2 9436      LSR	R3
    011A3 9427      ROR	R2
    011A4 9436      LSR	R3
    011A5 9427      ROR	R2
    011A6 9436      LSR	R3
    011A7 9427      ROR	R2
    011A8 2444      CLR	R4
    011A9 2455      CLR	R5
    011AA 0C62      ADD	R6,R2
    011AB 1C73      ADC	R7,R3
    011AC 1C84      ADC	R8,R4
    011AD 1C95      ADC	R9,R5
    011AE 8A6D      STD	Y+21,R6
    011AF 8A7E      STD	Y+22,R7
    011B0 8A8F      STD	Y+23,R8
    011B1 8E98      STD	Y+24,R9
(2108) 	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
    011B2 882D      LDD	R2,Y+21
    011B3 883E      LDD	R3,Y+22
    011B4 884F      LDD	R4,Y+23
    011B5 8C58      LDD	R5,Y+24
    011B6 846D      LDD	R6,Y+13
    011B7 847E      LDD	R7,Y+14
    011B8 848F      LDD	R8,Y+15
    011B9 8898      LDD	R9,Y+16
    011BA 1462      CP	R6,R2
    011BB 0473      CPC	R7,R3
    011BC 0484      CPC	R8,R4
    011BD 0495      CPC	R9,R5
    011BE F410      BCC	0x11C1
    011BF E00D      LDI	R16,0xD
    011C0 C2CB      RJMP	0x148C
(2109) 	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
    011C1 882D      LDD	R2,Y+21
    011C2 883E      LDD	R3,Y+22
    011C3 884F      LDD	R4,Y+23
    011C4 8C58      LDD	R5,Y+24
    011C5 850D      LDD	R16,Y+13
    011C6 851E      LDD	R17,Y+14
    011C7 852F      LDD	R18,Y+15
    011C8 8938      LDD	R19,Y+16
    011C9 1902      SUB	R16,R2
    011CA 0913      SBC	R17,R3
    011CB 0924      SBC	R18,R4
    011CC 0935      SBC	R19,R5
    011CD A1ED      LDD	R30,Y+37
    011CE A1FE      LDD	R31,Y+38
    011CF 9632      ADIW	R30,2
    011D0 8020      LD	R2,Z
    011D1 2433      CLR	R3
    011D2 2444      CLR	R4
    011D3 2455      CLR	R5
    011D4 925A      ST	-Y,R5
    011D5 924A      ST	-Y,R4
    011D6 923A      ST	-Y,R3
    011D7 922A      ST	-Y,R2
    011D8 940E 26AE CALL	div32u
    011DA 8709      STD	Y+9,R16
    011DB 871A      STD	Y+10,R17
    011DC 872B      STD	Y+11,R18
    011DD 873C      STD	Y+12,R19
(2110) 	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
    011DE 8429      LDD	R2,Y+9
    011DF 843A      LDD	R3,Y+10
    011E0 844B      LDD	R4,Y+11
    011E1 845C      LDD	R5,Y+12
    011E2 9488      BCLR	0
    011E3 2022      TST	R2
    011E4 0432      CPC	R3,R2
    011E5 0442      CPC	R4,R2
    011E6 0452      CPC	R5,R2
    011E7 F411      BNE	0x11EA
    011E8 E00D      LDI	R16,0xD
    011E9 C2A2      RJMP	0x148C
(2111) 	fmt = FS_FAT12;
    011EA 24CC      CLR	R12
    011EB 94C3      INC	R12
(2112) 	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
    011EC EF46      LDI	R20,0xF6
    011ED E05F      LDI	R21,0xF
    011EE E060      LDI	R22,0
    011EF E070      LDI	R23,0
    011F0 8429      LDD	R2,Y+9
    011F1 843A      LDD	R3,Y+10
    011F2 844B      LDD	R4,Y+11
    011F3 845C      LDD	R5,Y+12
    011F4 1624      CP	R2,R20
    011F5 0635      CPC	R3,R21
    011F6 0646      CPC	R4,R22
    011F7 0657      CPC	R5,R23
    011F8 F010      BCS	0x11FB
    011F9 E082      LDI	R24,2
    011FA 2EC8      MOV	R12,R24
(2113) 	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
    011FB EF46      LDI	R20,0xF6
    011FC EF5F      LDI	R21,0xFF
    011FD E060      LDI	R22,0
    011FE E070      LDI	R23,0
    011FF 8429      LDD	R2,Y+9
    01200 843A      LDD	R3,Y+10
    01201 844B      LDD	R4,Y+11
    01202 845C      LDD	R5,Y+12
    01203 1624      CP	R2,R20
    01204 0635      CPC	R3,R21
    01205 0646      CPC	R4,R22
    01206 0657      CPC	R5,R23
    01207 F010      BCS	0x120A
    01208 E083      LDI	R24,3
    01209 2EC8      MOV	R12,R24
(2114) 
(2115) 	/* Boundaries and Limits */
(2116) 	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
    0120A E042      LDI	R20,2
    0120B E050      LDI	R21,0
    0120C E060      LDI	R22,0
    0120D E070      LDI	R23,0
    0120E 8429      LDD	R2,Y+9
    0120F 843A      LDD	R3,Y+10
    01210 844B      LDD	R4,Y+11
    01211 845C      LDD	R5,Y+12
    01212 0E24      ADD	R2,R20
    01213 1E35      ADC	R3,R21
    01214 1E46      ADC	R4,R22
    01215 1E57      ADC	R5,R23
    01216 A1ED      LDD	R30,Y+37
    01217 A1FE      LDD	R31,Y+38
    01218 9676      ADIW	R30,0x16
    01219 8220      ST	Z,R2
    0121A 8231      STD	Z+1,R3
    0121B 8242      STD	Z+2,R4
    0121C 8253      STD	Z+3,R5
(2117) 	fs->database = bsect + sysect;						/* Data start sector */
    0121D 882D      LDD	R2,Y+21
    0121E 883E      LDD	R3,Y+22
    0121F 884F      LDD	R4,Y+23
    01220 8C58      LDD	R5,Y+24
    01221 8869      LDD	R6,Y+17
    01222 887A      LDD	R7,Y+18
    01223 888B      LDD	R8,Y+19
    01224 889C      LDD	R9,Y+20
    01225 0C62      ADD	R6,R2
    01226 1C73      ADC	R7,R3
    01227 1C84      ADC	R8,R4
    01228 1C95      ADC	R9,R5
    01229 A1ED      LDD	R30,Y+37
    0122A A1FE      LDD	R31,Y+38
    0122B 96B6      ADIW	R30,0x26
    0122C 8260      ST	Z,R6
    0122D 8271      STD	Z+1,R7
    0122E 8282      STD	Z+2,R8
    0122F 8293      STD	Z+3,R9
(2118) 	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
    01230 0117      MOVW	R2,R14
    01231 2444      CLR	R4
    01232 2455      CLR	R5
    01233 8869      LDD	R6,Y+17
    01234 887A      LDD	R7,Y+18
    01235 888B      LDD	R8,Y+19
    01236 889C      LDD	R9,Y+20
    01237 0C62      ADD	R6,R2
    01238 1C73      ADC	R7,R3
    01239 1C84      ADC	R8,R4
    0123A 1C95      ADC	R9,R5
    0123B A1ED      LDD	R30,Y+37
    0123C A1FE      LDD	R31,Y+38
    0123D 8E66      STD	Z+30,R6
    0123E 8E77      STD	Z+31,R7
    0123F A280      STD	Z+32,R8
    01240 A291      STD	Z+33,R9
(2119) 	if (fmt == FS_FAT32) {
    01241 2D8C      MOV	R24,R12
    01242 3083      CPI	R24,3
    01243 F009      BEQ	0x1245
    01244 C055      RJMP	0x129A
(2120) 		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
    01245 8420      LDD	R2,Z+8
    01246 8431      LDD	R3,Z+9
    01247 2022      TST	R2
    01248 F411      BNE	0x124B
    01249 2033      TST	R3
    0124A F011      BEQ	0x124D
    0124B E00D      LDI	R16,0xD
    0124C C23F      RJMP	0x148C
(2121) 		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
    0124D E188      LDI	R24,0x18
    0124E E090      LDI	R25,0
    0124F A1ED      LDD	R30,Y+37
    01250 A1FE      LDD	R31,Y+38
    01251 5AE3      SUBI	R30,0xA3
    01252 4FFF      SBCI	R31,0xFF
    01253 8100      LD	R16,Z
    01254 2711      CLR	R17
    01255 2722      CLR	R18
    01256 2733      CLR	R19
    01257 938A      ST	-Y,R24
    01258 940E 27F7 CALL	lsl32
    0125A 0118      MOVW	R2,R16
    0125B 0129      MOVW	R4,R18
    0125C A1ED      LDD	R30,Y+37
    0125D A1FE      LDD	R31,Y+38
    0125E 5AE4      SUBI	R30,0xA4
    0125F 4FFF      SBCI	R31,0xFF
    01260 8060      LD	R6,Z
    01261 55EC      SUBI	R30,0x5C
    01262 40F0      SBCI	R31,0
    01263 2477      CLR	R7
    01264 2488      CLR	R8
    01265 2499      CLR	R9
    01266 0143      MOVW	R8,R6
    01267 2466      CLR	R6
    01268 2477      CLR	R7
    01269 2826      OR	R2,R6
    0126A 2837      OR	R3,R7
    0126B 2848      OR	R4,R8
    0126C 2859      OR	R5,R9
    0126D 5AE5      SUBI	R30,0xA5
    0126E 4FFF      SBCI	R31,0xFF
    0126F 8060      LD	R6,Z
    01270 55EB      SUBI	R30,0x5B
    01271 40F0      SBCI	R31,0
    01272 2477      CLR	R7
    01273 2C76      MOV	R7,R6
    01274 2466      CLR	R6
    01275 2488      CLR	R8
    01276 2499      CLR	R9
    01277 2826      OR	R2,R6
    01278 2837      OR	R3,R7
    01279 2848      OR	R4,R8
    0127A 2859      OR	R5,R9
    0127B 5AE6      SUBI	R30,0xA6
    0127C 4FFF      SBCI	R31,0xFF
    0127D 8060      LD	R6,Z
    0127E 55EA      SUBI	R30,0x5A
    0127F 40F0      SBCI	R31,0
    01280 2477      CLR	R7
    01281 2488      CLR	R8
    01282 2499      CLR	R9
    01283 2826      OR	R2,R6
    01284 2837      OR	R3,R7
    01285 2848      OR	R4,R8
    01286 2859      OR	R5,R9
    01287 A222      STD	Z+34,R2
    01288 A233      STD	Z+35,R3
    01289 A244      STD	Z+36,R4
    0128A A255      STD	Z+37,R5
(2122) 		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
    0128B E082      LDI	R24,2
    0128C E090      LDI	R25,0
    0128D 9676      ADIW	R30,0x16
    0128E 8100      LD	R16,Z
    0128F 8111      LDD	R17,Z+1
    01290 8122      LDD	R18,Z+2
    01291 8133      LDD	R19,Z+3
    01292 938A      ST	-Y,R24
    01293 940E 27F7 CALL	lsl32
    01295 8F09      STD	Y+25,R16
    01296 8F1A      STD	Y+26,R17
    01297 8F2B      STD	Y+27,R18
    01298 8F3C      STD	Y+28,R19
(2123) 	} else {
    01299 C06A      RJMP	0x1304
(2124) 		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
    0129A A1ED      LDD	R30,Y+37
    0129B A1FE      LDD	R31,Y+38
    0129C 8420      LDD	R2,Z+8
    0129D 8431      LDD	R3,Z+9
    0129E 2022      TST	R2
    0129F F421      BNE	0x12A4
    012A0 2033      TST	R3
    012A1 F411      BNE	0x12A4
    012A2 E00D      LDI	R16,0xD
    012A3 C1E8      RJMP	0x148C
(2125) 		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
    012A4 802D      LDD	R2,Y+5
    012A5 803E      LDD	R3,Y+6
    012A6 804F      LDD	R4,Y+7
    012A7 8458      LDD	R5,Y+8
    012A8 A1ED      LDD	R30,Y+37
    012A9 A1FE      LDD	R31,Y+38
    012AA 8C66      LDD	R6,Z+30
    012AB 8C77      LDD	R7,Z+31
    012AC A080      LDD	R8,Z+32
    012AD A091      LDD	R9,Z+33
    012AE 0C62      ADD	R6,R2
    012AF 1C73      ADC	R7,R3
    012B0 1C84      ADC	R8,R4
    012B1 1C95      ADC	R9,R5
    012B2 A262      STD	Z+34,R6
    012B3 A273      STD	Z+35,R7
    012B4 A284      STD	Z+36,R8
    012B5 A295      STD	Z+37,R9
(2126) 		szbfat = (fmt == FS_FAT16) ?					/* (Required FAT size) */
    012B6 2D8C      MOV	R24,R12
    012B7 3082      CPI	R24,2
    012B8 F471      BNE	0x12C7
    012B9 9676      ADIW	R30,0x16
    012BA 8020      LD	R2,Z
    012BB 8031      LDD	R3,Z+1
    012BC 8042      LDD	R4,Z+2
    012BD 8053      LDD	R5,Z+3
    012BE 0C22      LSL	R2
    012BF 1C33      ROL	R3
    012C0 1C44      ROL	R4
    012C1 1C55      ROL	R5
    012C2 8E2D      STD	Y+29,R2
    012C3 8E3E      STD	Y+30,R3
    012C4 8E4F      STD	Y+31,R4
    012C5 A258      STD	Y+32,R5
    012C6 C035      RJMP	0x12FC
    012C7 A1ED      LDD	R30,Y+37
    012C8 A1FE      LDD	R31,Y+38
    012C9 9676      ADIW	R30,0x16
    012CA 8020      LD	R2,Z
    012CB 8031      LDD	R3,Z+1
    012CC 8042      LDD	R4,Z+2
    012CD 8053      LDD	R5,Z+3
    012CE A229      STD	Y+33,R2
    012CF A23A      STD	Y+34,R3
    012D0 A24B      STD	Y+35,R4
    012D1 A25C      STD	Y+36,R5
    012D2 E041      LDI	R20,1
    012D3 E050      LDI	R21,0
    012D4 E060      LDI	R22,0
    012D5 E070      LDI	R23,0
    012D6 A029      LDD	R2,Y+33
    012D7 A03A      LDD	R3,Y+34
    012D8 A04B      LDD	R4,Y+35
    012D9 A05C      LDD	R5,Y+36
    012DA 2224      AND	R2,R20
    012DB 2235      AND	R3,R21
    012DC 2246      AND	R4,R22
    012DD 2257      AND	R5,R23
    012DE A069      LDD	R6,Y+33
    012DF A07A      LDD	R7,Y+34
    012E0 A08B      LDD	R8,Y+35
    012E1 A09C      LDD	R9,Y+36
    012E2 E043      LDI	R20,3
    012E3 E050      LDI	R21,0
    012E4 E060      LDI	R22,0
    012E5 E070      LDI	R23,0
    012E6 929A      ST	-Y,R9
    012E7 928A      ST	-Y,R8
    012E8 927A      ST	-Y,R7
    012E9 926A      ST	-Y,R6
    012EA 018A      MOVW	R16,R20
    012EB 019B      MOVW	R18,R22
    012EC 940E 2728 CALL	empy32s|empy32u
    012EE 0138      MOVW	R6,R16
    012EF 0149      MOVW	R8,R18
    012F0 9496      LSR	R9
    012F1 9487      ROR	R8
    012F2 9477      ROR	R7
    012F3 9467      ROR	R6
    012F4 0C62      ADD	R6,R2
    012F5 1C73      ADC	R7,R3
    012F6 1C84      ADC	R8,R4
    012F7 1C95      ADC	R9,R5
    012F8 8E6D      STD	Y+29,R6
    012F9 8E7E      STD	Y+30,R7
    012FA 8E8F      STD	Y+31,R8
    012FB A298      STD	Y+32,R9
    012FC 8C2D      LDD	R2,Y+29
    012FD 8C3E      LDD	R3,Y+30
    012FE 8C4F      LDD	R4,Y+31
    012FF A058      LDD	R5,Y+32
    01300 8E29      STD	Y+25,R2
    01301 8E3A      STD	Y+26,R3
    01302 8E4B      STD	Y+27,R4
    01303 8E5C      STD	Y+28,R5
(2127) 			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
(2128) 	}
(2129) 	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
    01304 EF4F      LDI	R20,0xFF
    01305 E051      LDI	R21,1
    01306 E060      LDI	R22,0
    01307 E070      LDI	R23,0
    01308 8D09      LDD	R16,Y+25
    01309 8D1A      LDD	R17,Y+26
    0130A 8D2B      LDD	R18,Y+27
    0130B 8D3C      LDD	R19,Y+28
    0130C 0F04      ADD	R16,R20
    0130D 1F15      ADC	R17,R21
    0130E 1F26      ADC	R18,R22
    0130F 1F37      ADC	R19,R23
    01310 E089      LDI	R24,0x9
    01311 E090      LDI	R25,0
    01312 938A      ST	-Y,R24
    01313 940E 280A CALL	lsr32
    01315 A1ED      LDD	R30,Y+37
    01316 A1FE      LDD	R31,Y+38
    01317 8C22      LDD	R2,Z+26
    01318 8C33      LDD	R3,Z+27
    01319 8C44      LDD	R4,Z+28
    0131A 8C55      LDD	R5,Z+29
    0131B 1620      CP	R2,R16
    0131C 0631      CPC	R3,R17
    0131D 0642      CPC	R4,R18
    0131E 0653      CPC	R5,R19
    0131F F410      BCC	0x1322
(2130) 		return FR_NO_FILESYSTEM;
    01320 E00D      LDI	R16,0xD
    01321 C16A      RJMP	0x148C
(2131) 
(2132) #if !_FS_READONLY
(2133) 	/* Initialize cluster allocation information */
(2134) 	fs->free_clust = 0xFFFFFFFF;
    01322 A1ED      LDD	R30,Y+37
    01323 A1FE      LDD	R31,Y+38
    01324 963E      ADIW	R30,0xE
    01325 EF8F      LDI	R24,0xFF
    01326 8380      ST	Z,R24
    01327 8381      STD	Z+1,R24
    01328 8382      STD	Z+2,R24
    01329 8383      STD	Z+3,R24
(2135) 	fs->last_clust = 0;
    0132A A1ED      LDD	R30,Y+37
    0132B A1FE      LDD	R31,Y+38
    0132C 963A      ADIW	R30,0xA
    0132D E080      LDI	R24,0
    0132E 8380      ST	Z,R24
    0132F 8381      STD	Z+1,R24
    01330 8382      STD	Z+2,R24
    01331 8383      STD	Z+3,R24
(2136) 
(2137) 	/* Get fsinfo if available */
(2138) 	if (fmt == FS_FAT32) {
    01332 2D8C      MOV	R24,R12
    01333 3083      CPI	R24,3
    01334 F009      BEQ	0x1336
    01335 C13C      RJMP	0x1472
(2139) 	 	fs->fsi_flag = 0;
    01336 2422      CLR	R2
    01337 A1ED      LDD	R30,Y+37
    01338 A1FE      LDD	R31,Y+38
    01339 8225      STD	Z+5,R2
(2140) 		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
    0133A 5AE2      SUBI	R30,0xA2
    0133B 4FFF      SBCI	R31,0xFF
    0133C 8020      LD	R2,Z
    0133D 55EE      SUBI	R30,0x5E
    0133E 40F0      SBCI	R31,0
    0133F 2433      CLR	R3
    01340 5AE1      SUBI	R30,0xA1
    01341 4FFF      SBCI	R31,0xFF
    01342 8040      LD	R4,Z
    01343 2455      CLR	R5
    01344 2C54      MOV	R5,R4
    01345 2444      CLR	R4
    01346 2842      OR	R4,R2
    01347 2853      OR	R5,R3
    01348 0112      MOVW	R2,R4
    01349 2444      CLR	R4
    0134A 2455      CLR	R5
    0134B 8869      LDD	R6,Y+17
    0134C 887A      LDD	R7,Y+18
    0134D 888B      LDD	R8,Y+19
    0134E 889C      LDD	R9,Y+20
    0134F 0C62      ADD	R6,R2
    01350 1C73      ADC	R7,R3
    01351 1C84      ADC	R8,R4
    01352 1C95      ADC	R9,R5
    01353 A1ED      LDD	R30,Y+37
    01354 A1FE      LDD	R31,Y+38
    01355 8A62      STD	Z+18,R6
    01356 8A73      STD	Z+19,R7
    01357 8A84      STD	Z+20,R8
    01358 8A95      STD	Z+21,R9
(2141) 		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
    01359 E081      LDI	R24,1
    0135A 838C      STD	Y+4,R24
    0135B 8822      LDD	R2,Z+18
    0135C 8833      LDD	R3,Z+19
    0135D 8844      LDD	R4,Z+20
    0135E 8855      LDD	R5,Z+21
    0135F 8228      ST	Y,R2
    01360 8239      STD	Y+1,R3
    01361 824A      STD	Y+2,R4
    01362 825B      STD	Y+3,R5
    01363 019F      MOVW	R18,R30
    01364 5D22      SUBI	R18,0xD2
    01365 4F3F      SBCI	R19,0xFF
    01366 8101      LDD	R16,Z+1
    01367 940E 00DE CALL	_disk_read
    01369 2EE0      MOV	R14,R16
    0136A 2300      TST	R16
    0136B F009      BEQ	0x136D
    0136C C105      RJMP	0x1472
    0136D A1ED      LDD	R30,Y+37
    0136E A1FE      LDD	R31,Y+38
    0136F 5DE4      SUBI	R30,0xD4
    01370 4FFD      SBCI	R31,0xFD
    01371 8020      LD	R2,Z
    01372 52EC      SUBI	R30,0x2C
    01373 40F2      SBCI	R31,2
    01374 2433      CLR	R3
    01375 5DE3      SUBI	R30,0xD3
    01376 4FFD      SBCI	R31,0xFD
    01377 8180      LD	R24,Z
    01378 52ED      SUBI	R30,0x2D
    01379 40F2      SBCI	R31,2
    0137A 2799      CLR	R25
    0137B 2F98      MOV	R25,R24
    0137C 2788      CLR	R24
    0137D 2982      OR	R24,R2
    0137E 2993      OR	R25,R3
    0137F 3585      CPI	R24,0x55
    01380 EAAA      LDI	R26,0xAA
    01381 079A      CPC	R25,R26
    01382 F009      BEQ	0x1384
    01383 C0EE      RJMP	0x1472
    01384 E188      LDI	R24,0x18
    01385 E090      LDI	R25,0
    01386 A901      LDD	R16,Z+49
    01387 2711      CLR	R17
    01388 2722      CLR	R18
    01389 2733      CLR	R19
    0138A 938A      ST	-Y,R24
    0138B 940E 27F7 CALL	lsl32
    0138D 0118      MOVW	R2,R16
    0138E 0129      MOVW	R4,R18
    0138F A1ED      LDD	R30,Y+37
    01390 A1FE      LDD	R31,Y+38
    01391 A860      LDD	R6,Z+48
    01392 2477      CLR	R7
    01393 2488      CLR	R8
    01394 2499      CLR	R9
    01395 0143      MOVW	R8,R6
    01396 2466      CLR	R6
    01397 2477      CLR	R7
    01398 2826      OR	R2,R6
    01399 2837      OR	R3,R7
    0139A 2848      OR	R4,R8
    0139B 2859      OR	R5,R9
    0139C A467      LDD	R6,Z+47
    0139D 2477      CLR	R7
    0139E 2C76      MOV	R7,R6
    0139F 2466      CLR	R6
    013A0 2488      CLR	R8
    013A1 2499      CLR	R9
    013A2 2826      OR	R2,R6
    013A3 2837      OR	R3,R7
    013A4 2848      OR	R4,R8
    013A5 2859      OR	R5,R9
    013A6 A466      LDD	R6,Z+46
    013A7 2477      CLR	R7
    013A8 2488      CLR	R8
    013A9 2499      CLR	R9
    013AA 2826      OR	R2,R6
    013AB 2837      OR	R3,R7
    013AC 2848      OR	R4,R8
    013AD 2859      OR	R5,R9
    013AE E542      LDI	R20,0x52
    013AF E552      LDI	R21,0x52
    013B0 E661      LDI	R22,0x61
    013B1 E471      LDI	R23,0x41
    013B2 1624      CP	R2,R20
    013B3 0635      CPC	R3,R21
    013B4 0646      CPC	R4,R22
    013B5 0657      CPC	R5,R23
    013B6 F009      BEQ	0x13B8
    013B7 C0BA      RJMP	0x1472
    013B8 E188      LDI	R24,0x18
    013B9 E090      LDI	R25,0
    013BA 5EEB      SUBI	R30,0xEB
    013BB 4FFD      SBCI	R31,0xFD
    013BC 8100      LD	R16,Z
    013BD 2711      CLR	R17
    013BE 2722      CLR	R18
    013BF 2733      CLR	R19
    013C0 938A      ST	-Y,R24
    013C1 940E 27F7 CALL	lsl32
    013C3 0118      MOVW	R2,R16
    013C4 0129      MOVW	R4,R18
    013C5 A1ED      LDD	R30,Y+37
    013C6 A1FE      LDD	R31,Y+38
    013C7 5EEC      SUBI	R30,0xEC
    013C8 4FFD      SBCI	R31,0xFD
    013C9 8060      LD	R6,Z
    013CA 51E4      SUBI	R30,0x14
    013CB 40F2      SBCI	R31,2
    013CC 2477      CLR	R7
    013CD 2488      CLR	R8
    013CE 2499      CLR	R9
    013CF 0143      MOVW	R8,R6
    013D0 2466      CLR	R6
    013D1 2477      CLR	R7
    013D2 2826      OR	R2,R6
    013D3 2837      OR	R3,R7
    013D4 2848      OR	R4,R8
    013D5 2859      OR	R5,R9
    013D6 5EED      SUBI	R30,0xED
    013D7 4FFD      SBCI	R31,0xFD
    013D8 8060      LD	R6,Z
    013D9 51E3      SUBI	R30,0x13
    013DA 40F2      SBCI	R31,2
    013DB 2477      CLR	R7
    013DC 2C76      MOV	R7,R6
    013DD 2466      CLR	R6
    013DE 2488      CLR	R8
    013DF 2499      CLR	R9
    013E0 2826      OR	R2,R6
    013E1 2837      OR	R3,R7
    013E2 2848      OR	R4,R8
    013E3 2859      OR	R5,R9
    013E4 5EEE      SUBI	R30,0xEE
    013E5 4FFD      SBCI	R31,0xFD
    013E6 8060      LD	R6,Z
    013E7 51E2      SUBI	R30,0x12
    013E8 40F2      SBCI	R31,2
    013E9 2477      CLR	R7
    013EA 2488      CLR	R8
    013EB 2499      CLR	R9
    013EC 2826      OR	R2,R6
    013ED 2837      OR	R3,R7
    013EE 2848      OR	R4,R8
    013EF 2859      OR	R5,R9
    013F0 E742      LDI	R20,0x72
    013F1 E752      LDI	R21,0x72
    013F2 E461      LDI	R22,0x41
    013F3 E671      LDI	R23,0x61
    013F4 1624      CP	R2,R20
    013F5 0635      CPC	R3,R21
    013F6 0646      CPC	R4,R22
    013F7 0657      CPC	R5,R23
    013F8 F009      BEQ	0x13FA
    013F9 C078      RJMP	0x1472
(2142) 			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
(2143) 			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
(2144) 			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
(2145) 				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
    013FA E188      LDI	R24,0x18
    013FB E090      LDI	R25,0
    013FC 5EE3      SUBI	R30,0xE3
    013FD 4FFD      SBCI	R31,0xFD
    013FE 8100      LD	R16,Z
    013FF 2711      CLR	R17
    01400 2722      CLR	R18
    01401 2733      CLR	R19
    01402 938A      ST	-Y,R24
    01403 940E 27F7 CALL	lsl32
    01405 0118      MOVW	R2,R16
    01406 0129      MOVW	R4,R18
    01407 A1ED      LDD	R30,Y+37
    01408 A1FE      LDD	R31,Y+38
    01409 5EE4      SUBI	R30,0xE4
    0140A 4FFD      SBCI	R31,0xFD
    0140B 8060      LD	R6,Z
    0140C 51EC      SUBI	R30,0x1C
    0140D 40F2      SBCI	R31,2
    0140E 2477      CLR	R7
    0140F 2488      CLR	R8
    01410 2499      CLR	R9
    01411 0143      MOVW	R8,R6
    01412 2466      CLR	R6
    01413 2477      CLR	R7
    01414 2826      OR	R2,R6
    01415 2837      OR	R3,R7
    01416 2848      OR	R4,R8
    01417 2859      OR	R5,R9
    01418 5EE5      SUBI	R30,0xE5
    01419 4FFD      SBCI	R31,0xFD
    0141A 8060      LD	R6,Z
    0141B 51EB      SUBI	R30,0x1B
    0141C 40F2      SBCI	R31,2
    0141D 2477      CLR	R7
    0141E 2C76      MOV	R7,R6
    0141F 2466      CLR	R6
    01420 2488      CLR	R8
    01421 2499      CLR	R9
    01422 2826      OR	R2,R6
    01423 2837      OR	R3,R7
    01424 2848      OR	R4,R8
    01425 2859      OR	R5,R9
    01426 5EE6      SUBI	R30,0xE6
    01427 4FFD      SBCI	R31,0xFD
    01428 8060      LD	R6,Z
    01429 51EA      SUBI	R30,0x1A
    0142A 40F2      SBCI	R31,2
    0142B 2477      CLR	R7
    0142C 2488      CLR	R8
    0142D 2499      CLR	R9
    0142E 2826      OR	R2,R6
    0142F 2837      OR	R3,R7
    01430 2848      OR	R4,R8
    01431 2859      OR	R5,R9
    01432 8622      STD	Z+10,R2
    01433 8633      STD	Z+11,R3
    01434 8644      STD	Z+12,R4
    01435 8655      STD	Z+13,R5
(2146) 				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
    01436 E188      LDI	R24,0x18
    01437 E090      LDI	R25,0
    01438 5EE7      SUBI	R30,0xE7
    01439 4FFD      SBCI	R31,0xFD
    0143A 8100      LD	R16,Z
    0143B 2711      CLR	R17
    0143C 2722      CLR	R18
    0143D 2733      CLR	R19
    0143E 938A      ST	-Y,R24
    0143F 940E 27F7 CALL	lsl32
    01441 0118      MOVW	R2,R16
    01442 0129      MOVW	R4,R18
    01443 A1ED      LDD	R30,Y+37
    01444 A1FE      LDD	R31,Y+38
    01445 5EE8      SUBI	R30,0xE8
    01446 4FFD      SBCI	R31,0xFD
    01447 8060      LD	R6,Z
    01448 51E8      SUBI	R30,0x18
    01449 40F2      SBCI	R31,2
    0144A 2477      CLR	R7
    0144B 2488      CLR	R8
    0144C 2499      CLR	R9
    0144D 0143      MOVW	R8,R6
    0144E 2466      CLR	R6
    0144F 2477      CLR	R7
    01450 2826      OR	R2,R6
    01451 2837      OR	R3,R7
    01452 2848      OR	R4,R8
    01453 2859      OR	R5,R9
    01454 5EE9      SUBI	R30,0xE9
    01455 4FFD      SBCI	R31,0xFD
    01456 8060      LD	R6,Z
    01457 51E7      SUBI	R30,0x17
    01458 40F2      SBCI	R31,2
    01459 2477      CLR	R7
    0145A 2C76      MOV	R7,R6
    0145B 2466      CLR	R6
    0145C 2488      CLR	R8
    0145D 2499      CLR	R9
    0145E 2826      OR	R2,R6
    0145F 2837      OR	R3,R7
    01460 2848      OR	R4,R8
    01461 2859      OR	R5,R9
    01462 5EEA      SUBI	R30,0xEA
    01463 4FFD      SBCI	R31,0xFD
    01464 8060      LD	R6,Z
    01465 51E6      SUBI	R30,0x16
    01466 40F2      SBCI	R31,2
    01467 2477      CLR	R7
    01468 2488      CLR	R8
    01469 2499      CLR	R9
    0146A 2826      OR	R2,R6
    0146B 2837      OR	R3,R7
    0146C 2848      OR	R4,R8
    0146D 2859      OR	R5,R9
    0146E 8626      STD	Z+14,R2
    0146F 8637      STD	Z+15,R3
    01470 8A40      STD	Z+16,R4
    01471 8A51      STD	Z+17,R5
(2147) 		}
(2148) 	}
(2149) #endif
(2150) 	fs->fs_type = fmt;		/* FAT sub-type */
    01472 A1ED      LDD	R30,Y+37
    01473 A1FE      LDD	R31,Y+38
    01474 82C0      ST	Z,R12
(2151) 	fs->id = ++Fsid;		/* File system mount ID */
    01475 9180 01B1 LDS	R24,ff.c:Fsid
    01477 9190 01B2 LDS	R25,ff.c:Fsid+1
    01479 9601      ADIW	R24,1
    0147A 016C      MOVW	R12,R24
    0147B 92D0 01B2 STS	ff.c:Fsid+1,R13
    0147D 92C0 01B1 STS	ff.c:Fsid,R12
    0147F 82D7      STD	Z+7,R13
    01480 82C6      STD	Z+6,R12
(2152) 	fs->winsect = 0;		/* Invalidate sector cache */
    01481 96BA      ADIW	R30,0x2A
    01482 E080      LDI	R24,0
    01483 8380      ST	Z,R24
    01484 8381      STD	Z+1,R24
    01485 8382      STD	Z+2,R24
    01486 8383      STD	Z+3,R24
(2153) 	fs->wflag = 0;
    01487 2422      CLR	R2
    01488 A1ED      LDD	R30,Y+37
    01489 A1FE      LDD	R31,Y+38
    0148A 8224      STD	Z+4,R2
(2154) #if _FS_RPATH
(2155) 	fs->cdir = 0;			/* Current directory (root dir) */
(2156) #endif
(2157) #if _FS_SHARE				/* Clear file lock semaphores */
(2158) 	clear_lock(fs);
(2159) #endif
(2160) 
(2161) 	return FR_OK;
    0148B 2700      CLR	R16
    0148C 96A7      ADIW	R28,0x27
    0148D 940E 2771 CALL	pop_xgsetF0FC
    0148F 9622      ADIW	R28,2
    01490 9508      RET
ff.c:validate:
  id                   --> R10
  fs                   --> R20
    01491 940E 2787 CALL	push_xgset300C
    01493 0159      MOVW	R10,R18
    01494 01A8      MOVW	R20,R16
(2162) }
(2163) 
(2164) 
(2165) 
(2166) 
(2167) /*-----------------------------------------------------------------------*/
(2168) /* Check if the file/dir object is valid or not                          */
(2169) /*-----------------------------------------------------------------------*/
(2170) 
(2171) static
(2172) FRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
(2173) 	FATFS *fs,		/* Pointer to the file system object */
(2174) 	WORD id			/* Member id of the target object to be checked */
(2175) )
(2176) {
(2177) 	if (!fs || !fs->fs_type || fs->id != id)
    01495 3040      CPI	R20,0
    01496 0745      CPC	R20,R21
    01497 F049      BEQ	0x14A1
    01498 01FA      MOVW	R30,R20
    01499 8020      LD	R2,Z
    0149A 2022      TST	R2
    0149B F029      BEQ	0x14A1
    0149C 8026      LDD	R2,Z+6
    0149D 8037      LDD	R3,Z+7
    0149E 142A      CP	R2,R10
    0149F 043B      CPC	R3,R11
    014A0 F011      BEQ	0x14A3
(2178) 		return FR_INVALID_OBJECT;
    014A1 E009      LDI	R16,0x9
    014A2 C009      RJMP	0x14AC
(2179) 
(2180) 	ENTER_FF(fs);		/* Lock file system */
(2181) 
(2182) 	if (disk_status(fs->drv) & STA_NOINIT)
    014A3 01FA      MOVW	R30,R20
    014A4 8101      LDD	R16,Z+1
    014A5 940E 00D8 CALL	_disk_status
    014A7 FF00      SBRS	R16,0
    014A8 C002      RJMP	0x14AB
(2183) 		return FR_NOT_READY;
    014A9 E003      LDI	R16,3
    014AA C001      RJMP	0x14AC
(2184) 
(2185) 	return FR_OK;
    014AB 2700      CLR	R16
    014AC 940C 278C JMP	pop_xgset300C
_f_mount:
  rfs                  --> R10
  fs                   --> R18
  vol                  --> R16
    014AE 92AA      ST	-Y,R10
    014AF 92BA      ST	-Y,R11
(2186) }
(2187) 
(2188) 
(2189) 
(2190) 
(2191) /*--------------------------------------------------------------------------
(2192) 
(2193)    Public Functions
(2194) 
(2195) --------------------------------------------------------------------------*/
(2196) 
(2197) 
(2198) 
(2199) /*-----------------------------------------------------------------------*/
(2200) /* Mount/Unmount a Logical Drive                                         */
(2201) /*-----------------------------------------------------------------------*/
(2202) 
(2203) FRESULT f_mount (
(2204) 	BYTE vol,		/* Logical drive number to be mounted/unmounted */
(2205) 	FATFS *fs		/* Pointer to new file system object (NULL for unmount)*/
(2206) )
(2207) {
(2208) 	FATFS *rfs;
(2209) 
(2210) 
(2211) 	if (vol >= _VOLUMES)		/* Check if the drive number is valid */
    014B0 3001      CPI	R16,1
    014B1 F010      BCS	0x14B4
(2212) 		return FR_INVALID_DRIVE;
    014B2 E00B      LDI	R16,0xB
    014B3 C022      RJMP	0x14D6
(2213) 	rfs = FatFs[vol];			/* Get current fs object */
    014B4 EB83      LDI	R24,0xB3
    014B5 E091      LDI	R25,1
    014B6 2FE0      MOV	R30,R16
    014B7 27FF      CLR	R31
    014B8 0FEE      LSL	R30
    014B9 1FFF      ROL	R31
    014BA 0FE8      ADD	R30,R24
    014BB 1FF9      ADC	R31,R25
    014BC 80A0      LD	R10,Z
    014BD 80B1      LDD	R11,Z+1
(2214) 
(2215) 	if (rfs) {
    014BE 20AA      TST	R10
    014BF F411      BNE	0x14C2
    014C0 20BB      TST	R11
    014C1 F019      BEQ	0x14C5
(2216) #if _FS_SHARE
(2217) 		clear_lock(rfs);
(2218) #endif
(2219) #if _FS_REENTRANT				/* Discard sync object of the current volume */
(2220) 		if (!ff_del_syncobj(rfs->sobj)) return FR_INT_ERR;
(2221) #endif
(2222) 		rfs->fs_type = 0;		/* Clear old fs object */
    014C2 2422      CLR	R2
    014C3 01F5      MOVW	R30,R10
    014C4 8220      ST	Z,R2
(2223) 	}
(2224) 
(2225) 	if (fs) {
    014C5 3020      CPI	R18,0
    014C6 0723      CPC	R18,R19
    014C7 F019      BEQ	0x14CB
(2226) 		fs->fs_type = 0;		/* Clear new fs object */
    014C8 2422      CLR	R2
    014C9 01F9      MOVW	R30,R18
    014CA 8220      ST	Z,R2
(2227) #if _FS_REENTRANT				/* Create sync object for the new volume */
(2228) 		if (!ff_cre_syncobj(vol, &fs->sobj)) return FR_INT_ERR;
(2229) #endif
(2230) 	}
(2231) 	FatFs[vol] = fs;			/* Register new fs object */
    014CB EB83      LDI	R24,0xB3
    014CC E091      LDI	R25,1
    014CD 2FE0      MOV	R30,R16
    014CE 27FF      CLR	R31
    014CF 0FEE      LSL	R30
    014D0 1FFF      ROL	R31
    014D1 0FE8      ADD	R30,R24
    014D2 1FF9      ADC	R31,R25
    014D3 8331      STD	Z+1,R19
    014D4 8320      ST	Z,R18
(2232) 
(2233) 	return FR_OK;
    014D5 2700      CLR	R16
    014D6 90B9      LD	R11,Y+
    014D7 90A9      LD	R10,Y+
    014D8 9508      RET
_f_open:
  cl                   --> Y,+40
  dw                   --> Y,+36
  sfn                  --> Y,+24
  dj                   --> Y,+2
  res                  --> R10
  dir                  --> R14
  mode                 --> Y,+58
  path                 --> Y,+56
  fp                   --> Y,+54
    014D9 940E 26A9 CALL	push_arg4
    014DB 940E 277C CALL	push_xgsetF0FC
    014DD 97AC      SBIW	R28,0x2C
(2234) }
(2235) 
(2236) 
(2237) 
(2238) 
(2239) /*-----------------------------------------------------------------------*/
(2240) /* Open or Create a File                                                 */
(2241) /*-----------------------------------------------------------------------*/
(2242) 
(2243) FRESULT f_open (
(2244) 	FIL *fp,			/* Pointer to the blank file object */
(2245) 	const TCHAR *path,	/* Pointer to the file name */
(2246) 	BYTE mode			/* Access mode and file open mode flags */
(2247) )
(2248) {
(2249) 	FRESULT res;
(2250) 	DIR dj;
(2251) 	BYTE *dir;
(2252) 	DEF_NAMEBUF;
(2253) 
(2254) 
(2255) 	fp->fs = 0;			/* Clear file object */
    014DE 2422      CLR	R2
    014DF 2433      CLR	R3
    014E0 A9EE      LDD	R30,Y+54
    014E1 A9FF      LDD	R31,Y+55
    014E2 8231      STD	Z+1,R3
    014E3 8220      ST	Z,R2
(2256) 
(2257) #if !_FS_READONLY
(2258) 	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
    014E4 AD8A      LDD	R24,Y+58
    014E5 718F      ANDI	R24,0x1F
    014E6 AF8A      STD	Y+58,R24
(2259) 	res = chk_mounted(&path, &dj.fs, (BYTE)(mode & ~FA_READ));
    014E7 2799      CLR	R25
    014E8 7F8E      ANDI	R24,0xFE
    014E9 8388      ST	Y,R24
    014EA 019E      MOVW	R18,R28
    014EB 5F2E      SUBI	R18,0xFE
    014EC 4F3F      SBCI	R19,0xFF
    014ED 018E      MOVW	R16,R28
    014EE 5C08      SUBI	R16,0xC8
    014EF 4F1F      SBCI	R17,0xFF
    014F0 DAA6      RCALL	ff.c:chk_mounted
    014F1 2EA0      MOV	R10,R16
(2260) #else
(2261) 	mode &= FA_READ;
(2262) 	res = chk_mounted(&path, &dj.fs, 0);
(2263) #endif
(2264) 	INIT_BUF(dj);
    014F2 01CE      MOVW	R24,R28
    014F3 9648      ADIW	R24,0x18
    014F4 8B9F      STD	Y+23,R25
    014F5 8B8E      STD	Y+22,R24
(2265) 	if (res == FR_OK)
    014F6 2300      TST	R16
    014F7 F439      BNE	0x14FF
(2266) 		res = follow_path(&dj, path);	/* Follow the file path */
    014F8 AD28      LDD	R18,Y+56
    014F9 AD39      LDD	R19,Y+57
    014FA 018E      MOVW	R16,R28
    014FB 5F0E      SUBI	R16,0xFE
    014FC 4F1F      SBCI	R17,0xFF
    014FD D94D      RCALL	ff.c:follow_path
    014FE 2EA0      MOV	R10,R16
(2267) 	dir = dj.dir;
    014FF 88EC      LDD	R14,Y+20
    01500 88FD      LDD	R15,Y+21
(2268) 
(2269) #if !_FS_READONLY	/* R/W configuration */
(2270) 	if (res == FR_OK) {
    01501 20AA      TST	R10
    01502 F431      BNE	0x1509
(2271) 		if (!dir)	/* Current dir itself */
    01503 20EE      TST	R14
    01504 F421      BNE	0x1509
    01505 20FF      TST	R15
    01506 F411      BNE	0x1509
(2272) 			res = FR_INVALID_NAME;
    01507 E086      LDI	R24,6
    01508 2EA8      MOV	R10,R24
(2273) #if _FS_SHARE
(2274) 		else
(2275) 			res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
(2276) #endif
(2277) 	}
(2278) 	/* Create or Open a file */
(2279) 	if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
    01509 AD8A      LDD	R24,Y+58
    0150A 718C      ANDI	R24,0x1C
    0150B F409      BNE	0x150D
    0150C C0C0      RJMP	0x15CD
(2280) 		DWORD dw, cl;
(2281) 
(2282) 		if (res != FR_OK) {					/* No file, create new */
    0150D 20AA      TST	R10
    0150E F081      BEQ	0x151F
(2283) 			if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
    0150F 2D8A      MOV	R24,R10
    01510 3084      CPI	R24,4
    01511 F439      BNE	0x1519
(2284) #if _FS_SHARE
(2285) 				res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
(2286) #else
(2287) 				res = dir_register(&dj);
    01512 018E      MOVW	R16,R28
    01513 5F0E      SUBI	R16,0xFE
    01514 4F1F      SBCI	R17,0xFF
    01515 940E 0C3D CALL	ff.c:dir_register
    01517 2EC0      MOV	R12,R16
    01518 2CAC      MOV	R10,R12
(2288) #endif
(2289) 			mode |= FA_CREATE_ALWAYS;		/* File is created */
    01519 AD8A      LDD	R24,Y+58
    0151A 6088      ORI	R24,0x8
    0151B AF8A      STD	Y+58,R24
(2290) 			dir = dj.dir;					/* New entry */
    0151C 88EC      LDD	R14,Y+20
    0151D 88FD      LDD	R15,Y+21
(2291) 		}
    0151E C00C      RJMP	0x152B
(2292) 		else {								/* Any object is already existing */
(2293) 			if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
    0151F 01F7      MOVW	R30,R14
    01520 8583      LDD	R24,Z+11
    01521 7181      ANDI	R24,0x11
    01522 F019      BEQ	0x1526
(2294) 				res = FR_DENIED;
    01523 E087      LDI	R24,7
    01524 2EA8      MOV	R10,R24
(2295) 			} else {
    01525 C005      RJMP	0x152B
(2296) 				if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
    01526 AC0A      LDD	R0,Y+58
    01527 FE02      SBRS	R0,2
    01528 C002      RJMP	0x152B
(2297) 					res = FR_EXIST;
    01529 E088      LDI	R24,0x8
    0152A 2EA8      MOV	R10,R24
(2298) 			}
(2299) 		}
(2300) 		if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
    0152B 20AA      TST	R10
    0152C F009      BEQ	0x152E
    0152D C0B1      RJMP	0x15DF
    0152E AC0A      LDD	R0,Y+58
    0152F FE03      SBRS	R0,3
    01530 C0AE      RJMP	0x15DF
(2301) 			dw = get_fattime();					/* Created time */
    01531 940E 011B CALL	_get_fattime
    01533 A30C      STD	Y+36,R16
    01534 A31D      STD	Y+37,R17
    01535 A32E      STD	Y+38,R18
    01536 A33F      STD	Y+39,R19
(2302) 			ST_DWORD(dir+DIR_CrtTime, dw);
    01537 A02C      LDD	R2,Y+36
    01538 A03D      LDD	R3,Y+37
    01539 A04E      LDD	R4,Y+38
    0153A A05F      LDD	R5,Y+39
    0153B 01F7      MOVW	R30,R14
    0153C 8626      STD	Z+14,R2
    0153D 2C23      MOV	R2,R3
    0153E 2433      CLR	R3
    0153F 963F      ADIW	R30,0xF
    01540 8220      ST	Z,R2
    01541 A02C      LDD	R2,Y+36
    01542 A03D      LDD	R3,Y+37
    01543 A04E      LDD	R4,Y+38
    01544 A05F      LDD	R5,Y+39
    01545 0112      MOVW	R2,R4
    01546 2444      CLR	R4
    01547 2455      CLR	R5
    01548 01F7      MOVW	R30,R14
    01549 9670      ADIW	R30,0x10
    0154A 8220      ST	Z,R2
    0154B E188      LDI	R24,0x18
    0154C E090      LDI	R25,0
    0154D A10C      LDD	R16,Y+36
    0154E A11D      LDD	R17,Y+37
    0154F A12E      LDD	R18,Y+38
    01550 A13F      LDD	R19,Y+39
    01551 938A      ST	-Y,R24
    01552 940E 280A CALL	lsr32
    01554 01F7      MOVW	R30,R14
    01555 8B01      STD	Z+17,R16
(2303) 			dir[DIR_Attr] = 0;					/* Reset attribute */
    01556 2422      CLR	R2
    01557 8623      STD	Z+11,R2
(2304) 			ST_DWORD(dir+DIR_FileSize, 0);		/* size = 0 */
    01558 8E24      STD	Z+28,R2
    01559 8E25      STD	Z+29,R2
    0155A 8E26      STD	Z+30,R2
    0155B 8E27      STD	Z+31,R2
(2305) 			cl = LD_CLUST(dir);					/* Get start cluster */
    0155C 8C22      LDD	R2,Z+26
    0155D 2433      CLR	R3
    0155E 8C43      LDD	R4,Z+27
    0155F 2455      CLR	R5
    01560 2C54      MOV	R5,R4
    01561 2444      CLR	R4
    01562 2842      OR	R4,R2
    01563 2853      OR	R5,R3
    01564 0112      MOVW	R2,R4
    01565 2444      CLR	R4
    01566 2455      CLR	R5
    01567 8864      LDD	R6,Z+20
    01568 2477      CLR	R7
    01569 9675      ADIW	R30,0x15
    0156A 8080      LD	R8,Z
    0156B 2499      CLR	R9
    0156C 2C98      MOV	R9,R8
    0156D 2488      CLR	R8
    0156E 2886      OR	R8,R6
    0156F 2897      OR	R9,R7
    01570 0134      MOVW	R6,R8
    01571 2488      CLR	R8
    01572 2499      CLR	R9
    01573 0143      MOVW	R8,R6
    01574 2466      CLR	R6
    01575 2477      CLR	R7
    01576 2862      OR	R6,R2
    01577 2873      OR	R7,R3
    01578 2884      OR	R8,R4
    01579 2895      OR	R9,R5
    0157A A668      STD	Y+40,R6
    0157B A679      STD	Y+41,R7
    0157C A68A      STD	Y+42,R8
    0157D A69B      STD	Y+43,R9
(2306) 			ST_CLUST(dir, 0);					/* cluster = 0 */
    0157E 2422      CLR	R2
    0157F 01F7      MOVW	R30,R14
    01580 8E22      STD	Z+26,R2
    01581 8E23      STD	Z+27,R2
    01582 8A24      STD	Z+20,R2
    01583 8A25      STD	Z+21,R2
(2307) 			dj.fs->wflag = 1;
    01584 E081      LDI	R24,1
    01585 81EA      LDD	R30,Y+2
    01586 81FB      LDD	R31,Y+3
    01587 9634      ADIW	R30,4
    01588 8380      ST	Z,R24
(2308) 			if (cl) {							/* Remove the cluster chain if exist */
    01589 A428      LDD	R2,Y+40
    0158A A439      LDD	R3,Y+41
    0158B A44A      LDD	R4,Y+42
    0158C A45B      LDD	R5,Y+43
    0158D 9488      BCLR	0
    0158E 2022      TST	R2
    0158F 0432      CPC	R3,R2
    01590 0442      CPC	R4,R2
    01591 0452      CPC	R5,R2
    01592 F409      BNE	0x1594
    01593 C04B      RJMP	0x15DF
(2309) 				dw = dj.fs->winsect;
    01594 81EA      LDD	R30,Y+2
    01595 81FB      LDD	R31,Y+3
    01596 A422      LDD	R2,Z+42
    01597 A433      LDD	R3,Z+43
    01598 A444      LDD	R4,Z+44
    01599 A455      LDD	R5,Z+45
    0159A A22C      STD	Y+36,R2
    0159B A23D      STD	Y+37,R3
    0159C A24E      STD	Y+38,R4
    0159D A25F      STD	Y+39,R5
(2310) 				res = remove_chain(dj.fs, cl);
    0159E A428      LDD	R2,Y+40
    0159F A439      LDD	R3,Y+41
    015A0 A44A      LDD	R4,Y+42
    015A1 A45B      LDD	R5,Y+43
    015A2 8248      ST	Y,R4
    015A3 8259      STD	Y+1,R5
    015A4 0191      MOVW	R18,R2
    015A5 810A      LDD	R16,Y+2
    015A6 811B      LDD	R17,Y+3
    015A7 940E 0651 CALL	ff.c:remove_chain
    015A9 2EC0      MOV	R12,R16
    015AA 2CAC      MOV	R10,R12
(2311) 				if (res == FR_OK) {
    015AB 2300      TST	R16
    015AC F591      BNE	0x15DF
(2312) 					dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
    015AD E041      LDI	R20,1
    015AE E050      LDI	R21,0
    015AF E060      LDI	R22,0
    015B0 E070      LDI	R23,0
    015B1 A428      LDD	R2,Y+40
    015B2 A439      LDD	R3,Y+41
    015B3 A44A      LDD	R4,Y+42
    015B4 A45B      LDD	R5,Y+43
    015B5 1A24      SUB	R2,R20
    015B6 0A35      SBC	R3,R21
    015B7 0A46      SBC	R4,R22
    015B8 0A57      SBC	R5,R23
    015B9 81EA      LDD	R30,Y+2
    015BA 81FB      LDD	R31,Y+3
    015BB 8622      STD	Z+10,R2
    015BC 8633      STD	Z+11,R3
    015BD 8644      STD	Z+12,R4
    015BE 8655      STD	Z+13,R5
(2313) 					res = move_window(dj.fs, dw);
    015BF A02C      LDD	R2,Y+36
    015C0 A03D      LDD	R3,Y+37
    015C1 A04E      LDD	R4,Y+38
    015C2 A05F      LDD	R5,Y+39
    015C3 8248      ST	Y,R4
    015C4 8259      STD	Y+1,R5
    015C5 0191      MOVW	R18,R2
    015C6 810A      LDD	R16,Y+2
    015C7 811B      LDD	R17,Y+3
    015C8 940E 0179 CALL	ff.c:move_window
    015CA 2EC0      MOV	R12,R16
    015CB 2CAC      MOV	R10,R12
(2314) 				}
(2315) 			}
(2316) 		}
(2317) 	}
    015CC C012      RJMP	0x15DF
(2318) 	else {	/* Open an existing file */
(2319) 		if (res == FR_OK) {						/* Follow succeeded */
    015CD 20AA      TST	R10
    015CE F481      BNE	0x15DF
(2320) 			if (dir[DIR_Attr] & AM_DIR) {		/* It is a directory */
    015CF 01F7      MOVW	R30,R14
    015D0 8423      LDD	R2,Z+11
    015D1 FE24      SBRS	R2,4
    015D2 C003      RJMP	0x15D6
(2321) 				res = FR_NO_FILE;
    015D3 E084      LDI	R24,4
    015D4 2EA8      MOV	R10,R24
(2322) 			} else {
    015D5 C009      RJMP	0x15DF
(2323) 				if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
    015D6 AC0A      LDD	R0,Y+58
    015D7 FE01      SBRS	R0,1
    015D8 C006      RJMP	0x15DF
    015D9 01F7      MOVW	R30,R14
    015DA 8423      LDD	R2,Z+11
    015DB FE20      SBRS	R2,0
    015DC C002      RJMP	0x15DF
(2324) 					res = FR_DENIED;
    015DD E087      LDI	R24,7
    015DE 2EA8      MOV	R10,R24
(2325) 			}
(2326) 		}
(2327) 	}
(2328) 	if (res == FR_OK) {
    015DF 20AA      TST	R10
    015E0 F4A1      BNE	0x15F5
(2329) 		if (mode & FA_CREATE_ALWAYS)			/* Set file change flag if created or overwritten */
    015E1 AC0A      LDD	R0,Y+58
    015E2 FE03      SBRS	R0,3
    015E3 C003      RJMP	0x15E7
(2330) 			mode |= FA__WRITTEN;
    015E4 2D80      MOV	R24,R0
    015E5 6280      ORI	R24,0x20
    015E6 AF8A      STD	Y+58,R24
(2331) 		fp->dir_sect = dj.fs->winsect;			/* Pointer to the directory entry */
    015E7 81EA      LDD	R30,Y+2
    015E8 81FB      LDD	R31,Y+3
    015E9 A422      LDD	R2,Z+42
    015EA A433      LDD	R3,Z+43
    015EB A444      LDD	R4,Z+44
    015EC A455      LDD	R5,Z+45
    015ED A9EE      LDD	R30,Y+54
    015EE A9FF      LDD	R31,Y+55
    015EF 8E22      STD	Z+26,R2
    015F0 8E33      STD	Z+27,R3
    015F1 8E44      STD	Z+28,R4
    015F2 8E55      STD	Z+29,R5
(2332) 		fp->dir_ptr = dir;
    015F3 8EF7      STD	Z+31,R15
    015F4 8EE6      STD	Z+30,R14
(2333) #if _FS_SHARE
(2334) 		fp->lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
(2335) 		if (!fp->lockid) res = FR_INT_ERR;
(2336) #endif
(2337) 	}
(2338) 
(2339) #else				/* R/O configuration */
(2340) 	if (res == FR_OK) {					/* Follow succeeded */
(2341) 		if (!dir) {						/* Current dir itself */
(2342) 			res = FR_INVALID_NAME;
(2343) 		} else {
(2344) 			if (dir[DIR_Attr] & AM_DIR)	/* It is a directory */
(2345) 				res = FR_NO_FILE;
(2346) 		}
(2347) 	}
(2348) #endif
(2349) 	FREE_BUF();
(2350) 
(2351) 	if (res == FR_OK) {
    015F5 20AA      TST	R10
    015F6 F009      BEQ	0x15F8
    015F7 C077      RJMP	0x166F
(2352) 		fp->flag = mode;					/* File access mode */
    015F8 A9EE      LDD	R30,Y+54
    015F9 A9FF      LDD	R31,Y+55
    015FA AC0A      LDD	R0,Y+58
    015FB 8204      STD	Z+4,R0
(2353) 		fp->sclust = LD_CLUST(dir);			/* File start cluster */
    015FC 01F7      MOVW	R30,R14
    015FD 8C22      LDD	R2,Z+26
    015FE 2433      CLR	R3
    015FF 8C43      LDD	R4,Z+27
    01600 2455      CLR	R5
    01601 2C54      MOV	R5,R4
    01602 2444      CLR	R4
    01603 2842      OR	R4,R2
    01604 2853      OR	R5,R3
    01605 0112      MOVW	R2,R4
    01606 2444      CLR	R4
    01607 2455      CLR	R5
    01608 8864      LDD	R6,Z+20
    01609 2477      CLR	R7
    0160A 8885      LDD	R8,Z+21
    0160B 2499      CLR	R9
    0160C 2C98      MOV	R9,R8
    0160D 2488      CLR	R8
    0160E 2886      OR	R8,R6
    0160F 2897      OR	R9,R7
    01610 0134      MOVW	R6,R8
    01611 2488      CLR	R8
    01612 2499      CLR	R9
    01613 0143      MOVW	R8,R6
    01614 2466      CLR	R6
    01615 2477      CLR	R7
    01616 2862      OR	R6,R2
    01617 2873      OR	R7,R3
    01618 2884      OR	R8,R4
    01619 2895      OR	R9,R5
    0161A A9EE      LDD	R30,Y+54
    0161B A9FF      LDD	R31,Y+55
    0161C 8666      STD	Z+14,R6
    0161D 8677      STD	Z+15,R7
    0161E 8A80      STD	Z+16,R8
    0161F 8A91      STD	Z+17,R9
(2354) 		fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
    01620 E188      LDI	R24,0x18
    01621 E090      LDI	R25,0
    01622 01F7      MOVW	R30,R14
    01623 8D07      LDD	R16,Z+31
    01624 2711      CLR	R17
    01625 2722      CLR	R18
    01626 2733      CLR	R19
    01627 938A      ST	-Y,R24
    01628 940E 27F7 CALL	lsl32
    0162A 0118      MOVW	R2,R16
    0162B 0129      MOVW	R4,R18
    0162C 01F7      MOVW	R30,R14
    0162D 8C66      LDD	R6,Z+30
    0162E 2477      CLR	R7
    0162F 2488      CLR	R8
    01630 2499      CLR	R9
    01631 0143      MOVW	R8,R6
    01632 2466      CLR	R6
    01633 2477      CLR	R7
    01634 2826      OR	R2,R6
    01635 2837      OR	R3,R7
    01636 2848      OR	R4,R8
    01637 2859      OR	R5,R9
    01638 8C65      LDD	R6,Z+29
    01639 2477      CLR	R7
    0163A 2C76      MOV	R7,R6
    0163B 2466      CLR	R6
    0163C 2488      CLR	R8
    0163D 2499      CLR	R9
    0163E 2826      OR	R2,R6
    0163F 2837      OR	R3,R7
    01640 2848      OR	R4,R8
    01641 2859      OR	R5,R9
    01642 8C64      LDD	R6,Z+28
    01643 2477      CLR	R7
    01644 2488      CLR	R8
    01645 2499      CLR	R9
    01646 2826      OR	R2,R6
    01647 2837      OR	R3,R7
    01648 2848      OR	R4,R8
    01649 2859      OR	R5,R9
    0164A A9EE      LDD	R30,Y+54
    0164B A9FF      LDD	R31,Y+55
    0164C 8622      STD	Z+10,R2
    0164D 8633      STD	Z+11,R3
    0164E 8644      STD	Z+12,R4
    0164F 8655      STD	Z+13,R5
(2355) 		fp->fptr = 0;						/* File pointer */
    01650 9636      ADIW	R30,6
    01651 E080      LDI	R24,0
    01652 8380      ST	Z,R24
    01653 8381      STD	Z+1,R24
    01654 8382      STD	Z+2,R24
    01655 8383      STD	Z+3,R24
(2356) 		fp->dsect = 0;
    01656 A9EE      LDD	R30,Y+54
    01657 A9FF      LDD	R31,Y+55
    01658 9676      ADIW	R30,0x16
    01659 E080      LDI	R24,0
    0165A 8380      ST	Z,R24
    0165B 8381      STD	Z+1,R24
    0165C 8382      STD	Z+2,R24
    0165D 8383      STD	Z+3,R24
(2357) #if _USE_FASTSEEK
(2358) 		fp->cltbl = 0;						/* Normal seek mode */
    0165E 2422      CLR	R2
    0165F 2433      CLR	R3
    01660 A9EE      LDD	R30,Y+54
    01661 A9FF      LDD	R31,Y+55
    01662 A231      STD	Z+33,R3
    01663 A220      STD	Z+32,R2
(2359) #endif
(2360) 		fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
    01664 802A      LDD	R2,Y+2
    01665 803B      LDD	R3,Y+3
    01666 8231      STD	Z+1,R3
    01667 8220      ST	Z,R2
    01668 01F1      MOVW	R30,R2
    01669 8026      LDD	R2,Z+6
    0166A 8037      LDD	R3,Z+7
    0166B A9EE      LDD	R30,Y+54
    0166C A9FF      LDD	R31,Y+55
    0166D 8233      STD	Z+3,R3
    0166E 8222      STD	Z+2,R2
(2361) 	}
(2362) 
(2363) 	LEAVE_FF(dj.fs, res);
    0166F 2D0A      MOV	R16,R10
    01670 96AC      ADIW	R28,0x2C
    01671 940E 2771 CALL	pop_xgsetF0FC
    01673 9624      ADIW	R28,4
    01674 9508      RET
_f_read:
  remain               --> Y,+13
  res                  --> R10
  clst                 --> Y,+9
  csect                --> R12
  cc                   --> R10
  rbuff                --> R14
  sect                 --> Y,+5
  rcnt                 --> R12
  br                   --> Y,+33
  btr                  --> Y,+31
  buff                 --> R10
  fp                   --> Y,+27
    01675 940E 26A9 CALL	push_arg4
    01677 940E 277C CALL	push_xgsetF0FC
    01679 0159      MOVW	R10,R18
    0167A 9761      SBIW	R28,0x11
(2364) }
(2365) 
(2366) 
(2367) 
(2368) 
(2369) /*-----------------------------------------------------------------------*/
(2370) /* Read File                                                             */
(2371) /*-----------------------------------------------------------------------*/
(2372) 
(2373) FRESULT f_read (
(2374) 	FIL *fp, 		/* Pointer to the file object */
(2375) 	void *buff,		/* Pointer to data buffer */
(2376) 	UINT btr,		/* Number of bytes to read */
(2377) 	UINT *br		/* Pointer to number of bytes read */
(2378) )
(2379) {
(2380) 	FRESULT res;
(2381) 	DWORD clst, sect, remain;
(2382) 	UINT rcnt, cc;
(2383) 	BYTE csect, *rbuff = buff;
    0167B 0175      MOVW	R14,R10
(2384) 
(2385) 	memset(buff,0,512);
    0167C E080      LDI	R24,0
    0167D E092      LDI	R25,2
    0167E 8399      STD	Y+1,R25
    0167F 8388      ST	Y,R24
    01680 2722      CLR	R18
    01681 2733      CLR	R19
    01682 0185      MOVW	R16,R10
    01683 940E 269E CALL	_memset
(2386) 
(2387) 	*br = 0;	/* Initialize byte counter */
    01685 2422      CLR	R2
    01686 2433      CLR	R3
    01687 A1E9      LDD	R30,Y+33
    01688 A1FA      LDD	R31,Y+34
    01689 8231      STD	Z+1,R3
    0168A 8220      ST	Z,R2
(2388) 
(2389) 	res = validate(fp->fs, fp->id);				/* Check validity */
    0168B 8DEB      LDD	R30,Y+27
    0168C 8DFC      LDD	R31,Y+28
    0168D 8122      LDD	R18,Z+2
    0168E 8133      LDD	R19,Z+3
    0168F 8100      LD	R16,Z
    01690 8111      LDD	R17,Z+1
    01691 DDFF      RCALL	ff.c:validate
    01692 2EA0      MOV	R10,R16
(2390) 	if (res != FR_OK) LEAVE_FF(fp->fs, res);
    01693 2300      TST	R16
    01694 F009      BEQ	0x1696
    01695 C245      RJMP	0x18DB
(2391) 	if (fp->flag & FA__ERROR)					/* Aborted file? */
    01696 8DEB      LDD	R30,Y+27
    01697 8DFC      LDD	R31,Y+28
    01698 8024      LDD	R2,Z+4
    01699 FE27      SBRS	R2,7
    0169A C002      RJMP	0x169D
(2392) 		LEAVE_FF(fp->fs, FR_INT_ERR);
    0169B E002      LDI	R16,2
    0169C C23E      RJMP	0x18DB
(2393) 	if (!(fp->flag & FA_READ)) 					/* Check access mode */
    0169D 8DEB      LDD	R30,Y+27
    0169E 8DFC      LDD	R31,Y+28
    0169F 8024      LDD	R2,Z+4
    016A0 FC20      SBRC	R2,0
    016A1 C002      RJMP	0x16A4
(2394) 		LEAVE_FF(fp->fs, FR_DENIED);
    016A2 E007      LDI	R16,7
    016A3 C237      RJMP	0x18DB
(2395) 	remain = fp->fsize - fp->fptr;
    016A4 8DEB      LDD	R30,Y+27
    016A5 8DFC      LDD	R31,Y+28
    016A6 8026      LDD	R2,Z+6
    016A7 8037      LDD	R3,Z+7
    016A8 8440      LDD	R4,Z+8
    016A9 8451      LDD	R5,Z+9
    016AA 963A      ADIW	R30,0xA
    016AB 8060      LD	R6,Z
    016AC 8071      LDD	R7,Z+1
    016AD 8082      LDD	R8,Z+2
    016AE 8093      LDD	R9,Z+3
    016AF 1862      SUB	R6,R2
    016B0 0873      SBC	R7,R3
    016B1 0884      SBC	R8,R4
    016B2 0895      SBC	R9,R5
    016B3 866D      STD	Y+13,R6
    016B4 867E      STD	Y+14,R7
    016B5 868F      STD	Y+15,R8
    016B6 8A98      STD	Y+16,R9
(2396) 	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */
    016B7 842D      LDD	R2,Y+13
    016B8 843E      LDD	R3,Y+14
    016B9 844F      LDD	R4,Y+15
    016BA 8858      LDD	R5,Y+16
    016BB 8C6F      LDD	R6,Y+31
    016BC A078      LDD	R7,Y+32
    016BD 2488      CLR	R8
    016BE 2499      CLR	R9
    016BF 1426      CP	R2,R6
    016C0 0437      CPC	R3,R7
    016C1 0448      CPC	R4,R8
    016C2 0459      CPC	R5,R9
    016C3 F008      BCS	0x16C5
    016C4 C20D      RJMP	0x18D2
    016C5 A238      STD	Y+32,R3
    016C6 8E2F      STD	Y+31,R2
(2397) 
(2398) 	for ( ;  btr;								/* Repeat until all data read */
    016C7 C20A      RJMP	0x18D2
(2399) 		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
(2400) 		if ((fp->fptr % SS(fp->fs)) == 0) {		/* On the sector boundary? */
    016C8 EF4F      LDI	R20,0xFF
    016C9 E051      LDI	R21,1
    016CA E060      LDI	R22,0
    016CB E070      LDI	R23,0
    016CC 8DEB      LDD	R30,Y+27
    016CD 8DFC      LDD	R31,Y+28
    016CE 9636      ADIW	R30,6
    016CF 8020      LD	R2,Z
    016D0 8031      LDD	R3,Z+1
    016D1 8042      LDD	R4,Z+2
    016D2 8053      LDD	R5,Z+3
    016D3 2224      AND	R2,R20
    016D4 2235      AND	R3,R21
    016D5 2246      AND	R4,R22
    016D6 2257      AND	R5,R23
    016D7 9488      BCLR	0
    016D8 2022      TST	R2
    016D9 0432      CPC	R3,R2
    016DA 0442      CPC	R4,R2
    016DB 0452      CPC	R5,R2
    016DC F009      BEQ	0x16DE
    016DD C180      RJMP	0x185E
(2401) 			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
    016DE E089      LDI	R24,0x9
    016DF E090      LDI	R25,0
    016E0 8DEB      LDD	R30,Y+27
    016E1 8DFC      LDD	R31,Y+28
    016E2 8106      LDD	R16,Z+6
    016E3 8117      LDD	R17,Z+7
    016E4 8520      LDD	R18,Z+8
    016E5 8531      LDD	R19,Z+9
    016E6 938A      ST	-Y,R24
    016E7 940E 280A CALL	lsr32
    016E9 0118      MOVW	R2,R16
    016EA 0129      MOVW	R4,R18
    016EB 8DEB      LDD	R30,Y+27
    016EC 8DFC      LDD	R31,Y+28
    016ED 93AF      PUSH	R26
    016EE 93BF      PUSH	R27
    016EF 81A0      LD	R26,Z
    016F0 81B1      LDD	R27,Z+1
    016F1 01FD      MOVW	R30,R26
    016F2 91BF      POP	R27
    016F3 91AF      POP	R26
    016F4 8182      LDD	R24,Z+2
    016F5 2799      CLR	R25
    016F6 9701      SBIW	R24,1
    016F7 013C      MOVW	R6,R24
    016F8 2488      CLR	R8
    016F9 FC77      SBRC	R7,7
    016FA 9480      COM	R8
    016FB 2499      CLR	R9
    016FC FC87      SBRC	R8,7
    016FD 9490      COM	R9
    016FE 2026      AND	R2,R6
    016FF 2037      AND	R3,R7
    01700 2048      AND	R4,R8
    01701 2059      AND	R5,R9
    01702 2CC2      MOV	R12,R2
(2402) 			if (!csect) {						/* On the cluster boundary? */
    01703 2022      TST	R2
    01704 F009      BEQ	0x1706
    01705 C078      RJMP	0x177E
(2403) 				if (fp->fptr == 0) {			/* On the top of the file? */
    01706 8DEB      LDD	R30,Y+27
    01707 8DFC      LDD	R31,Y+28
    01708 9636      ADIW	R30,6
    01709 8020      LD	R2,Z
    0170A 8031      LDD	R3,Z+1
    0170B 8042      LDD	R4,Z+2
    0170C 8053      LDD	R5,Z+3
    0170D 9488      BCLR	0
    0170E 2022      TST	R2
    0170F 0432      CPC	R3,R2
    01710 0442      CPC	R4,R2
    01711 0452      CPC	R5,R2
    01712 F461      BNE	0x171F
(2404) 					clst = fp->sclust;			/* Follow from the origin */
    01713 8DEB      LDD	R30,Y+27
    01714 8DFC      LDD	R31,Y+28
    01715 963E      ADIW	R30,0xE
    01716 8020      LD	R2,Z
    01717 8031      LDD	R3,Z+1
    01718 8042      LDD	R4,Z+2
    01719 8053      LDD	R5,Z+3
    0171A 8629      STD	Y+9,R2
    0171B 863A      STD	Y+10,R3
    0171C 864B      STD	Y+11,R4
    0171D 865C      STD	Y+12,R5
(2405) 				} else {						/* Middle or end of the file */
    0171E C028      RJMP	0x1747
(2406) #if _USE_FASTSEEK
(2407) 					if (fp->cltbl)
    0171F 8DEB      LDD	R30,Y+27
    01720 8DFC      LDD	R31,Y+28
    01721 A020      LDD	R2,Z+32
    01722 A031      LDD	R3,Z+33
    01723 2022      TST	R2
    01724 F411      BNE	0x1727
    01725 2033      TST	R3
    01726 F079      BEQ	0x1736
(2408) 						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
    01727 8026      LDD	R2,Z+6
    01728 8037      LDD	R3,Z+7
    01729 8440      LDD	R4,Z+8
    0172A 8451      LDD	R5,Z+9
    0172B 8248      ST	Y,R4
    0172C 8259      STD	Y+1,R5
    0172D 0191      MOVW	R18,R2
    0172E 018F      MOVW	R16,R30
    0172F 940E 087C CALL	ff.c:clmt_clust
    01731 8709      STD	Y+9,R16
    01732 871A      STD	Y+10,R17
    01733 872B      STD	Y+11,R18
    01734 873C      STD	Y+12,R19
    01735 C011      RJMP	0x1747
(2409) 					else
(2410) #endif
(2411) 						clst = get_fat(fp->fs, fp->clust);	/* Follow cluster chain on the FAT */
    01736 8DEB      LDD	R30,Y+27
    01737 8DFC      LDD	R31,Y+28
    01738 8822      LDD	R2,Z+18
    01739 8833      LDD	R3,Z+19
    0173A 8844      LDD	R4,Z+20
    0173B 8855      LDD	R5,Z+21
    0173C 8248      ST	Y,R4
    0173D 8259      STD	Y+1,R5
    0173E 0191      MOVW	R18,R2
    0173F 8100      LD	R16,Z
    01740 8111      LDD	R17,Z+1
    01741 940E 0342 CALL	_get_fat
    01743 8709      STD	Y+9,R16
    01744 871A      STD	Y+10,R17
    01745 872B      STD	Y+11,R18
    01746 873C      STD	Y+12,R19
(2412) 				}
(2413) 				if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
    01747 E042      LDI	R20,2
    01748 E050      LDI	R21,0
    01749 E060      LDI	R22,0
    0174A E070      LDI	R23,0
    0174B 8429      LDD	R2,Y+9
    0174C 843A      LDD	R3,Y+10
    0174D 844B      LDD	R4,Y+11
    0174E 845C      LDD	R5,Y+12
    0174F 1624      CP	R2,R20
    01750 0635      CPC	R3,R21
    01751 0646      CPC	R4,R22
    01752 0657      CPC	R5,R23
    01753 F448      BCC	0x175D
    01754 8D8B      LDD	R24,Y+27
    01755 8D9C      LDD	R25,Y+28
    01756 9604      ADIW	R24,4
    01757 01FC      MOVW	R30,R24
    01758 8180      LD	R24,Z
    01759 6880      ORI	R24,0x80
    0175A 8380      ST	Z,R24
    0175B E002      LDI	R16,2
    0175C C17E      RJMP	0x18DB
(2414) 				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    0175D EF4F      LDI	R20,0xFF
    0175E EF5F      LDI	R21,0xFF
    0175F EF6F      LDI	R22,0xFF
    01760 EF7F      LDI	R23,0xFF
    01761 8429      LDD	R2,Y+9
    01762 843A      LDD	R3,Y+10
    01763 844B      LDD	R4,Y+11
    01764 845C      LDD	R5,Y+12
    01765 1624      CP	R2,R20
    01766 0635      CPC	R3,R21
    01767 0646      CPC	R4,R22
    01768 0657      CPC	R5,R23
    01769 F451      BNE	0x1774
    0176A 8D8B      LDD	R24,Y+27
    0176B 8D9C      LDD	R25,Y+28
    0176C 9604      ADIW	R24,4
    0176D 015C      MOVW	R10,R24
    0176E 01FC      MOVW	R30,R24
    0176F 8180      LD	R24,Z
    01770 6880      ORI	R24,0x80
    01771 8380      ST	Z,R24
    01772 E001      LDI	R16,1
    01773 C167      RJMP	0x18DB
(2415) 				fp->clust = clst;				/* Update current cluster */
    01774 8429      LDD	R2,Y+9
    01775 843A      LDD	R3,Y+10
    01776 844B      LDD	R4,Y+11
    01777 845C      LDD	R5,Y+12
    01778 8DEB      LDD	R30,Y+27
    01779 8DFC      LDD	R31,Y+28
    0177A 8A22      STD	Z+18,R2
    0177B 8A33      STD	Z+19,R3
    0177C 8A44      STD	Z+20,R4
    0177D 8A55      STD	Z+21,R5
(2416) 			}
(2417) 			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
    0177E 8DEB      LDD	R30,Y+27
    0177F 8DFC      LDD	R31,Y+28
    01780 8822      LDD	R2,Z+18
    01781 8833      LDD	R3,Z+19
    01782 8844      LDD	R4,Z+20
    01783 8855      LDD	R5,Z+21
    01784 8248      ST	Y,R4
    01785 8259      STD	Y+1,R5
    01786 0191      MOVW	R18,R2
    01787 8100      LD	R16,Z
    01788 8111      LDD	R17,Z+1
    01789 940E 02F0 CALL	_clust2sect
    0178B 830D      STD	Y+5,R16
    0178C 831E      STD	Y+6,R17
    0178D 832F      STD	Y+7,R18
    0178E 8738      STD	Y+8,R19
(2418) 			if (!sect) ABORT(fp->fs, FR_INT_ERR);
    0178F 802D      LDD	R2,Y+5
    01790 803E      LDD	R3,Y+6
    01791 804F      LDD	R4,Y+7
    01792 8458      LDD	R5,Y+8
    01793 9488      BCLR	0
    01794 2022      TST	R2
    01795 0432      CPC	R3,R2
    01796 0442      CPC	R4,R2
    01797 0452      CPC	R5,R2
    01798 F451      BNE	0x17A3
    01799 8D8B      LDD	R24,Y+27
    0179A 8D9C      LDD	R25,Y+28
    0179B 9604      ADIW	R24,4
    0179C 015C      MOVW	R10,R24
    0179D 01FC      MOVW	R30,R24
    0179E 8180      LD	R24,Z
    0179F 6880      ORI	R24,0x80
    017A0 8380      ST	Z,R24
    017A1 E002      LDI	R16,2
    017A2 C138      RJMP	0x18DB
(2419) 			sect += csect;
    017A3 2C2C      MOV	R2,R12
    017A4 2433      CLR	R3
    017A5 2444      CLR	R4
    017A6 2455      CLR	R5
    017A7 806D      LDD	R6,Y+5
    017A8 807E      LDD	R7,Y+6
    017A9 808F      LDD	R8,Y+7
    017AA 8498      LDD	R9,Y+8
    017AB 0C62      ADD	R6,R2
    017AC 1C73      ADC	R7,R3
    017AD 1C84      ADC	R8,R4
    017AE 1C95      ADC	R9,R5
    017AF 826D      STD	Y+5,R6
    017B0 827E      STD	Y+6,R7
    017B1 828F      STD	Y+7,R8
    017B2 8698      STD	Y+8,R9
(2420) 			cc = btr / SS(fp->fs);				/* When remaining bytes >= sector size, */
    017B3 E029      LDI	R18,0x9
    017B4 E030      LDI	R19,0
    017B5 8D0F      LDD	R16,Y+31
    017B6 A118      LDD	R17,Y+32
    017B7 940E 2803 CALL	lsr16
    017B9 0158      MOVW	R10,R16
(2421) 			if (cc) {							/* Read maximum contiguous sectors directly */
    017BA 3000      CPI	R16,0
    017BB 0701      CPC	R16,R17
    017BC F409      BNE	0x17BE
    017BD C096      RJMP	0x1854
(2422) 				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
    017BE 2C2C      MOV	R2,R12
    017BF 2433      CLR	R3
    017C0 0E20      ADD	R2,R16
    017C1 1E31      ADC	R3,R17
    017C2 8DEB      LDD	R30,Y+27
    017C3 8DFC      LDD	R31,Y+28
    017C4 93AF      PUSH	R26
    017C5 93BF      PUSH	R27
    017C6 81A0      LD	R26,Z
    017C7 81B1      LDD	R27,Z+1
    017C8 01FD      MOVW	R30,R26
    017C9 91BF      POP	R27
    017CA 91AF      POP	R26
    017CB 8042      LDD	R4,Z+2
    017CC 2455      CLR	R5
    017CD 1442      CP	R4,R2
    017CE 0453      CPC	R5,R3
    017CF F478      BCC	0x17DF
(2423) 					cc = fp->fs->csize - csect;
    017D0 2C2C      MOV	R2,R12
    017D1 2433      CLR	R3
    017D2 8DEB      LDD	R30,Y+27
    017D3 8DFC      LDD	R31,Y+28
    017D4 93AF      PUSH	R26
    017D5 93BF      PUSH	R27
    017D6 81A0      LD	R26,Z
    017D7 81B1      LDD	R27,Z+1
    017D8 01FD      MOVW	R30,R26
    017D9 91BF      POP	R27
    017DA 91AF      POP	R26
    017DB 80A2      LDD	R10,Z+2
    017DC 24BB      CLR	R11
    017DD 18A2      SUB	R10,R2
    017DE 08B3      SBC	R11,R3
(2424) 				if (disk_read(fp->fs->drv, rbuff, sect, (BYTE)cc) != RES_OK)
    017DF 82AC      STD	Y+4,R10
    017E0 802D      LDD	R2,Y+5
    017E1 803E      LDD	R3,Y+6
    017E2 804F      LDD	R4,Y+7
    017E3 8458      LDD	R5,Y+8
    017E4 8228      ST	Y,R2
    017E5 8239      STD	Y+1,R3
    017E6 824A      STD	Y+2,R4
    017E7 825B      STD	Y+3,R5
    017E8 0197      MOVW	R18,R14
    017E9 8DEB      LDD	R30,Y+27
    017EA 8DFC      LDD	R31,Y+28
    017EB 93AF      PUSH	R26
    017EC 93BF      PUSH	R27
    017ED 81A0      LD	R26,Z
    017EE 81B1      LDD	R27,Z+1
    017EF 01FD      MOVW	R30,R26
    017F0 91BF      POP	R27
    017F1 91AF      POP	R26
    017F2 8101      LDD	R16,Z+1
    017F3 940E 00DE CALL	_disk_read
    017F5 2EC0      MOV	R12,R16
    017F6 2300      TST	R16
    017F7 F051      BEQ	0x1802
(2425) 					ABORT(fp->fs, FR_DISK_ERR);
    017F8 8D8B      LDD	R24,Y+27
    017F9 8D9C      LDD	R25,Y+28
    017FA 9604      ADIW	R24,4
    017FB 016C      MOVW	R12,R24
    017FC 01FC      MOVW	R30,R24
    017FD 8180      LD	R24,Z
    017FE 6880      ORI	R24,0x80
    017FF 8380      ST	Z,R24
    01800 E001      LDI	R16,1
    01801 C0D9      RJMP	0x18DB
(2426) #if !_FS_READONLY && _FS_MINIMIZE <= 2			/* Replace one of the read sectors with cached data if it contains a dirty sector */
(2427) #if _FS_TINY
(2428) 				if (fp->fs->wflag && fp->fs->winsect - sect < cc)
    01802 8DEB      LDD	R30,Y+27
    01803 8DFC      LDD	R31,Y+28
    01804 80C0      LD	R12,Z
    01805 80D1      LDD	R13,Z+1
    01806 01F6      MOVW	R30,R12
    01807 9634      ADIW	R30,4
    01808 8020      LD	R2,Z
    01809 2022      TST	R2
    0180A F409      BNE	0x180C
    0180B C041      RJMP	0x184D
    0180C 802D      LDD	R2,Y+5
    0180D 803E      LDD	R3,Y+6
    0180E 804F      LDD	R4,Y+7
    0180F 8458      LDD	R5,Y+8
    01810 01F6      MOVW	R30,R12
    01811 A462      LDD	R6,Z+42
    01812 A473      LDD	R7,Z+43
    01813 A484      LDD	R8,Z+44
    01814 A495      LDD	R9,Z+45
    01815 1862      SUB	R6,R2
    01816 0873      SBC	R7,R3
    01817 0884      SBC	R8,R4
    01818 0895      SBC	R9,R5
    01819 0115      MOVW	R2,R10
    0181A 2444      CLR	R4
    0181B 2455      CLR	R5
    0181C 1462      CP	R6,R2
    0181D 0473      CPC	R7,R3
    0181E 0484      CPC	R8,R4
    0181F 0495      CPC	R9,R5
    01820 F560      BCC	0x184D
(2429) 					mem_cpy(rbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), fp->fs->win, SS(fp->fs));
    01821 E080      LDI	R24,0
    01822 E092      LDI	R25,2
    01823 8399      STD	Y+1,R25
    01824 8388      ST	Y,R24
    01825 8DEB      LDD	R30,Y+27
    01826 8DFC      LDD	R31,Y+28
    01827 80C0      LD	R12,Z
    01828 80D1      LDD	R13,Z+1
    01829 0196      MOVW	R18,R12
    0182A 5D22      SUBI	R18,0xD2
    0182B 4F3F      SBCI	R19,0xFF
    0182C 802D      LDD	R2,Y+5
    0182D 803E      LDD	R3,Y+6
    0182E 804F      LDD	R4,Y+7
    0182F 8458      LDD	R5,Y+8
    01830 01F6      MOVW	R30,R12
    01831 A462      LDD	R6,Z+42
    01832 A473      LDD	R7,Z+43
    01833 A484      LDD	R8,Z+44
    01834 A495      LDD	R9,Z+45
    01835 1862      SUB	R6,R2
    01836 0873      SBC	R7,R3
    01837 0884      SBC	R8,R4
    01838 0895      SBC	R9,R5
    01839 E040      LDI	R20,0
    0183A E052      LDI	R21,2
    0183B E060      LDI	R22,0
    0183C E070      LDI	R23,0
    0183D 932F      PUSH	R18
    0183E 933F      PUSH	R19
    0183F 929A      ST	-Y,R9
    01840 928A      ST	-Y,R8
    01841 927A      ST	-Y,R7
    01842 926A      ST	-Y,R6
    01843 018A      MOVW	R16,R20
    01844 019B      MOVW	R18,R22
    01845 940E 2728 CALL	empy32s|empy32u
    01847 913F      POP	R19
    01848 912F      POP	R18
    01849 0D0E      ADD	R16,R14
    0184A 1D1F      ADC	R17,R15
    0184B 940E 0120 CALL	ff.c:mem_cpy
(2430) #else
(2431) 				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
(2432) 					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
(2433) #endif
(2434) #endif
(2435) 				rcnt = SS(fp->fs) * cc;			/* Number of bytes transferred */
    0184D E000      LDI	R16,0
    0184E E012      LDI	R17,2
    0184F 0195      MOVW	R18,R10
    01850 940E 2718 CALL	empy16s
    01852 0168      MOVW	R12,R16
(2436) 				continue;
    01853 C05A      RJMP	0x18AE
(2437) 			}
(2438) #if !_FS_TINY
(2439) 			if (fp->dsect != sect) {			/* Load data sector if not in cache */
(2440) #if !_FS_READONLY
(2441) 				if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
(2442) 					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
(2443) 						ABORT(fp->fs, FR_DISK_ERR);
(2444) 					fp->flag &= ~FA__DIRTY;
(2445) 				}
(2446) #endif
(2447) 				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)	/* Fill sector cache */
(2448) 					ABORT(fp->fs, FR_DISK_ERR);
(2449) 			}
(2450) #endif
(2451) 			fp->dsect = sect;
    01854 802D      LDD	R2,Y+5
    01855 803E      LDD	R3,Y+6
    01856 804F      LDD	R4,Y+7
    01857 8458      LDD	R5,Y+8
    01858 8DEB      LDD	R30,Y+27
    01859 8DFC      LDD	R31,Y+28
    0185A 8A26      STD	Z+22,R2
    0185B 8A37      STD	Z+23,R3
    0185C 8E40      STD	Z+24,R4
    0185D 8E51      STD	Z+25,R5
(2452) 		}
(2453) 		rcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
    0185E EF4F      LDI	R20,0xFF
    0185F E051      LDI	R21,1
    01860 E060      LDI	R22,0
    01861 E070      LDI	R23,0
    01862 8DEB      LDD	R30,Y+27
    01863 8DFC      LDD	R31,Y+28
    01864 8026      LDD	R2,Z+6
    01865 8037      LDD	R3,Z+7
    01866 8440      LDD	R4,Z+8
    01867 8451      LDD	R5,Z+9
    01868 2224      AND	R2,R20
    01869 2235      AND	R3,R21
    0186A 2246      AND	R4,R22
    0186B 2257      AND	R5,R23
    0186C E040      LDI	R20,0
    0186D E052      LDI	R21,2
    0186E E060      LDI	R22,0
    0186F E070      LDI	R23,0
    01870 1942      SUB	R20,R2
    01871 0953      SBC	R21,R3
    01872 0964      SBC	R22,R4
    01873 0975      SBC	R23,R5
    01874 016A      MOVW	R12,R20
(2454) 		if (rcnt > btr) rcnt = btr;
    01875 8C0F      LDD	R0,Y+31
    01876 A018      LDD	R1,Y+32
    01877 1604      CP	R0,R20
    01878 0615      CPC	R1,R21
    01879 F408      BCC	0x187B
    0187A 0160      MOVW	R12,R0
(2455) #if _FS_TINY
(2456) 		if (move_window(fp->fs, fp->dsect))		/* Move sector window */
    0187B 8DEB      LDD	R30,Y+27
    0187C 8DFC      LDD	R31,Y+28
    0187D 8826      LDD	R2,Z+22
    0187E 8837      LDD	R3,Z+23
    0187F 8C40      LDD	R4,Z+24
    01880 8C51      LDD	R5,Z+25
    01881 8248      ST	Y,R4
    01882 8259      STD	Y+1,R5
    01883 0191      MOVW	R18,R2
    01884 8100      LD	R16,Z
    01885 8111      LDD	R17,Z+1
    01886 940E 0179 CALL	ff.c:move_window
    01888 2EA0      MOV	R10,R16
    01889 2300      TST	R16
    0188A F051      BEQ	0x1895
(2457) 			ABORT(fp->fs, FR_DISK_ERR);
    0188B 8D8B      LDD	R24,Y+27
    0188C 8D9C      LDD	R25,Y+28
    0188D 9604      ADIW	R24,4
    0188E 015C      MOVW	R10,R24
    0188F 01FC      MOVW	R30,R24
    01890 8180      LD	R24,Z
    01891 6880      ORI	R24,0x80
    01892 8380      ST	Z,R24
    01893 E001      LDI	R16,1
    01894 C046      RJMP	0x18DB
(2458) 		mem_cpy(rbuff, &fp->fs->win[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
    01895 82D9      STD	Y+1,R13
    01896 82C8      ST	Y,R12
    01897 EF4F      LDI	R20,0xFF
    01898 E051      LDI	R21,1
    01899 E060      LDI	R22,0
    0189A E070      LDI	R23,0
    0189B 8DEB      LDD	R30,Y+27
    0189C 8DFC      LDD	R31,Y+28
    0189D 8026      LDD	R2,Z+6
    0189E 8037      LDD	R3,Z+7
    0189F 8440      LDD	R4,Z+8
    018A0 8451      LDD	R5,Z+9
    018A1 2224      AND	R2,R20
    018A2 2235      AND	R3,R21
    018A3 2246      AND	R4,R22
    018A4 2257      AND	R5,R23
    018A5 0191      MOVW	R18,R2
    018A6 8180      LD	R24,Z
    018A7 8191      LDD	R25,Z+1
    018A8 968E      ADIW	R24,0x2E
    018A9 0F28      ADD	R18,R24
    018AA 1F39      ADC	R19,R25
    018AB 0187      MOVW	R16,R14
    018AC 940E 0120 CALL	ff.c:mem_cpy
    018AE 0CEC      ADD	R14,R12
    018AF 1CFD      ADC	R15,R13
    018B0 8D8B      LDD	R24,Y+27
    018B1 8D9C      LDD	R25,Y+28
    018B2 9606      ADIW	R24,6
    018B3 015C      MOVW	R10,R24
    018B4 0116      MOVW	R2,R12
    018B5 2444      CLR	R4
    018B6 2455      CLR	R5
    018B7 01FC      MOVW	R30,R24
    018B8 8060      LD	R6,Z
    018B9 8071      LDD	R7,Z+1
    018BA 8082      LDD	R8,Z+2
    018BB 8093      LDD	R9,Z+3
    018BC 0C62      ADD	R6,R2
    018BD 1C73      ADC	R7,R3
    018BE 1C84      ADC	R8,R4
    018BF 1C95      ADC	R9,R5
    018C0 8260      ST	Z,R6
    018C1 8271      STD	Z+1,R7
    018C2 8282      STD	Z+2,R8
    018C3 8293      STD	Z+3,R9
    018C4 A1E9      LDD	R30,Y+33
    018C5 A1FA      LDD	R31,Y+34
    018C6 8020      LD	R2,Z
    018C7 8031      LDD	R3,Z+1
    018C8 0C2C      ADD	R2,R12
    018C9 1C3D      ADC	R3,R13
    018CA 8231      STD	Z+1,R3
    018CB 8220      ST	Z,R2
    018CC 8C0F      LDD	R0,Y+31
    018CD A018      LDD	R1,Y+32
    018CE 180C      SUB	R0,R12
    018CF 081D      SBC	R1,R13
    018D0 A218      STD	Y+32,R1
    018D1 8E0F      STD	Y+31,R0
    018D2 8C0F      LDD	R0,Y+31
    018D3 A018      LDD	R1,Y+32
    018D4 2000      TST	R0
    018D5 F009      BEQ	0x18D7
    018D6 CDF1      RJMP	0x16C8
    018D7 2011      TST	R1
    018D8 F009      BEQ	0x18DA
    018D9 CDEE      RJMP	0x16C8
(2459) #else
(2460) 		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
(2461) #endif
(2462) 	}
(2463) 
(2464) 	LEAVE_FF(fp->fs, FR_OK);
    018DA 2700      CLR	R16
    018DB 9661      ADIW	R28,0x11
    018DC 940E 2771 CALL	pop_xgsetF0FC
    018DE 9624      ADIW	R28,4
    018DF 9508      RET
_f_write:
  res                  --> R10
  clst                 --> Y,+9
  csect                --> R12
  cc                   --> R10
  wbuff                --> R14
  sect                 --> Y,+5
  wcnt                 --> R12
  bw                   --> Y,+33
  btw                  --> Y,+31
  buff                 --> R10
  fp                   --> Y,+27
    018E0 940E 26A9 CALL	push_arg4
    018E2 940E 277C CALL	push_xgsetF0FC
    018E4 0159      MOVW	R10,R18
    018E5 9761      SBIW	R28,0x11
(2465) }
(2466) 
(2467) 
(2468) 
(2469) 
(2470) #if !_FS_READONLY
(2471) /*-----------------------------------------------------------------------*/
(2472) /* Write File                                                            */
(2473) /*-----------------------------------------------------------------------*/
(2474) 
(2475) FRESULT f_write (
(2476) 	FIL *fp,			/* Pointer to the file object */
(2477) 	const void *buff,	/* Pointer to the data to be written */
(2478) 	UINT btw,			/* Number of bytes to write */
(2479) 	UINT *bw			/* Pointer to number of bytes written */
(2480) )
(2481) {
(2482) 	FRESULT res;
(2483) 	DWORD clst, sect;
(2484) 	UINT wcnt, cc;
(2485) 	const BYTE *wbuff = buff;
    018E6 0175      MOVW	R14,R10
(2486) 	BYTE csect;
(2487) 
(2488) 
(2489) 	*bw = 0;	/* Initialize byte counter */
    018E7 2422      CLR	R2
    018E8 2433      CLR	R3
    018E9 A1E9      LDD	R30,Y+33
    018EA A1FA      LDD	R31,Y+34
    018EB 8231      STD	Z+1,R3
    018EC 8220      ST	Z,R2
(2490) 
(2491) 	res = validate(fp->fs, fp->id);			/* Check validity */
    018ED 8DEB      LDD	R30,Y+27
    018EE 8DFC      LDD	R31,Y+28
    018EF 8122      LDD	R18,Z+2
    018F0 8133      LDD	R19,Z+3
    018F1 8100      LD	R16,Z
    018F2 8111      LDD	R17,Z+1
    018F3 DB9D      RCALL	ff.c:validate
    018F4 2EA0      MOV	R10,R16
(2492) 	if (res != FR_OK) LEAVE_FF(fp->fs, res);
    018F5 2300      TST	R16
    018F6 F009      BEQ	0x18F8
    018F7 C2FC      RJMP	0x1BF4
(2493) 	if (fp->flag & FA__ERROR)				/* Aborted file? */
    018F8 8DEB      LDD	R30,Y+27
    018F9 8DFC      LDD	R31,Y+28
    018FA 8024      LDD	R2,Z+4
    018FB FE27      SBRS	R2,7
    018FC C002      RJMP	0x18FF
(2494) 		LEAVE_FF(fp->fs, FR_INT_ERR);
    018FD E002      LDI	R16,2
    018FE C2F5      RJMP	0x1BF4
(2495) 	if (!(fp->flag & FA_WRITE))				/* Check access mode */
    018FF 8DEB      LDD	R30,Y+27
    01900 8DFC      LDD	R31,Y+28
    01901 8024      LDD	R2,Z+4
    01902 FC21      SBRC	R2,1
    01903 C002      RJMP	0x1906
(2496) 		LEAVE_FF(fp->fs, FR_DENIED);
    01904 E007      LDI	R16,7
    01905 C2EE      RJMP	0x1BF4
(2497) 	if ((DWORD)(fp->fsize + btw) < fp->fsize) btw = 0;	/* File size cannot reach 4GB */
    01906 8DEB      LDD	R30,Y+27
    01907 8DFC      LDD	R31,Y+28
    01908 963A      ADIW	R30,0xA
    01909 8020      LD	R2,Z
    0190A 8031      LDD	R3,Z+1
    0190B 8042      LDD	R4,Z+2
    0190C 8053      LDD	R5,Z+3
    0190D 862D      STD	Y+13,R2
    0190E 863E      STD	Y+14,R3
    0190F 864F      STD	Y+15,R4
    01910 8A58      STD	Y+16,R5
    01911 8C2F      LDD	R2,Y+31
    01912 A038      LDD	R3,Y+32
    01913 2444      CLR	R4
    01914 2455      CLR	R5
    01915 846D      LDD	R6,Y+13
    01916 847E      LDD	R7,Y+14
    01917 848F      LDD	R8,Y+15
    01918 8898      LDD	R9,Y+16
    01919 0C62      ADD	R6,R2
    0191A 1C73      ADC	R7,R3
    0191B 1C84      ADC	R8,R4
    0191C 1C95      ADC	R9,R5
    0191D 842D      LDD	R2,Y+13
    0191E 843E      LDD	R3,Y+14
    0191F 844F      LDD	R4,Y+15
    01920 8858      LDD	R5,Y+16
    01921 1462      CP	R6,R2
    01922 0473      CPC	R7,R3
    01923 0484      CPC	R8,R4
    01924 0495      CPC	R9,R5
    01925 F008      BCS	0x1927
    01926 C2A5      RJMP	0x1BCC
    01927 2400      CLR	R0
    01928 2411      CLR	R1
    01929 A218      STD	Y+32,R1
    0192A 8E0F      STD	Y+31,R0
(2498) 
(2499) 	for ( ;  btw;							/* Repeat until all data written */
    0192B C2A0      RJMP	0x1BCC
(2500) 		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
(2501) 		if ((fp->fptr % SS(fp->fs)) == 0) {	/* On the sector boundary? */
    0192C EF4F      LDI	R20,0xFF
    0192D E051      LDI	R21,1
    0192E E060      LDI	R22,0
    0192F E070      LDI	R23,0
    01930 8DEB      LDD	R30,Y+27
    01931 8DFC      LDD	R31,Y+28
    01932 9636      ADIW	R30,6
    01933 8020      LD	R2,Z
    01934 8031      LDD	R3,Z+1
    01935 8042      LDD	R4,Z+2
    01936 8053      LDD	R5,Z+3
    01937 2224      AND	R2,R20
    01938 2235      AND	R3,R21
    01939 2246      AND	R4,R22
    0193A 2257      AND	R5,R23
    0193B 9488      BCLR	0
    0193C 2022      TST	R2
    0193D 0432      CPC	R3,R2
    0193E 0442      CPC	R4,R2
    0193F 0452      CPC	R5,R2
    01940 F009      BEQ	0x1942
    01941 C20B      RJMP	0x1B4D
(2502) 			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
    01942 E089      LDI	R24,0x9
    01943 E090      LDI	R25,0
    01944 8DEB      LDD	R30,Y+27
    01945 8DFC      LDD	R31,Y+28
    01946 8106      LDD	R16,Z+6
    01947 8117      LDD	R17,Z+7
    01948 8520      LDD	R18,Z+8
    01949 8531      LDD	R19,Z+9
    0194A 938A      ST	-Y,R24
    0194B 940E 280A CALL	lsr32
    0194D 0118      MOVW	R2,R16
    0194E 0129      MOVW	R4,R18
    0194F 8DEB      LDD	R30,Y+27
    01950 8DFC      LDD	R31,Y+28
    01951 93AF      PUSH	R26
    01952 93BF      PUSH	R27
    01953 81A0      LD	R26,Z
    01954 81B1      LDD	R27,Z+1
    01955 01FD      MOVW	R30,R26
    01956 91BF      POP	R27
    01957 91AF      POP	R26
    01958 8182      LDD	R24,Z+2
    01959 2799      CLR	R25
    0195A 9701      SBIW	R24,1
    0195B 013C      MOVW	R6,R24
    0195C 2488      CLR	R8
    0195D FC77      SBRC	R7,7
    0195E 9480      COM	R8
    0195F 2499      CLR	R9
    01960 FC87      SBRC	R8,7
    01961 9490      COM	R9
    01962 2026      AND	R2,R6
    01963 2037      AND	R3,R7
    01964 2048      AND	R4,R8
    01965 2059      AND	R5,R9
    01966 2CC2      MOV	R12,R2
(2503) 			if (!csect) {					/* On the cluster boundary? */
    01967 2022      TST	R2
    01968 F009      BEQ	0x196A
    01969 C0A5      RJMP	0x1A0F
(2504) 				if (fp->fptr == 0) {		/* On the top of the file? */
    0196A 8DEB      LDD	R30,Y+27
    0196B 8DFC      LDD	R31,Y+28
    0196C 9636      ADIW	R30,6
    0196D 8020      LD	R2,Z
    0196E 8031      LDD	R3,Z+1
    0196F 8042      LDD	R4,Z+2
    01970 8053      LDD	R5,Z+3
    01971 9488      BCLR	0
    01972 2022      TST	R2
    01973 0432      CPC	R3,R2
    01974 0442      CPC	R4,R2
    01975 0452      CPC	R5,R2
    01976 F571      BNE	0x19A5
(2505) 					clst = fp->sclust;		/* Follow from the origin */
    01977 8DEB      LDD	R30,Y+27
    01978 8DFC      LDD	R31,Y+28
    01979 963E      ADIW	R30,0xE
    0197A 8020      LD	R2,Z
    0197B 8031      LDD	R3,Z+1
    0197C 8042      LDD	R4,Z+2
    0197D 8053      LDD	R5,Z+3
    0197E 8629      STD	Y+9,R2
    0197F 863A      STD	Y+10,R3
    01980 864B      STD	Y+11,R4
    01981 865C      STD	Y+12,R5
(2506) 					if (clst == 0)			/* When no cluster is allocated, */
    01982 8429      LDD	R2,Y+9
    01983 843A      LDD	R3,Y+10
    01984 844B      LDD	R4,Y+11
    01985 845C      LDD	R5,Y+12
    01986 9488      BCLR	0
    01987 2022      TST	R2
    01988 0432      CPC	R3,R2
    01989 0442      CPC	R4,R2
    0198A 0452      CPC	R5,R2
    0198B F009      BEQ	0x198D
    0198C C040      RJMP	0x19CD
(2507) 						fp->sclust = clst = create_chain(fp->fs, 0);	/* Create a new cluster chain */
    0198D E040      LDI	R20,0
    0198E E050      LDI	R21,0
    0198F E060      LDI	R22,0
    01990 E070      LDI	R23,0
    01991 8368      ST	Y,R22
    01992 8379      STD	Y+1,R23
    01993 019A      MOVW	R18,R20
    01994 8DEB      LDD	R30,Y+27
    01995 8DFC      LDD	R31,Y+28
    01996 8100      LD	R16,Z
    01997 8111      LDD	R17,Z+1
    01998 940E 0704 CALL	ff.c:create_chain
    0199A 8709      STD	Y+9,R16
    0199B 871A      STD	Y+10,R17
    0199C 872B      STD	Y+11,R18
    0199D 873C      STD	Y+12,R19
    0199E 8DEB      LDD	R30,Y+27
    0199F 8DFC      LDD	R31,Y+28
    019A0 8706      STD	Z+14,R16
    019A1 8717      STD	Z+15,R17
    019A2 8B20      STD	Z+16,R18
    019A3 8B31      STD	Z+17,R19
(2508) 				} else {					/* Middle or end of the file */
    019A4 C028      RJMP	0x19CD
(2509) #if _USE_FASTSEEK
(2510) 					if (fp->cltbl)
    019A5 8DEB      LDD	R30,Y+27
    019A6 8DFC      LDD	R31,Y+28
    019A7 A020      LDD	R2,Z+32
    019A8 A031      LDD	R3,Z+33
    019A9 2022      TST	R2
    019AA F411      BNE	0x19AD
    019AB 2033      TST	R3
    019AC F079      BEQ	0x19BC
(2511) 						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
    019AD 8026      LDD	R2,Z+6
    019AE 8037      LDD	R3,Z+7
    019AF 8440      LDD	R4,Z+8
    019B0 8451      LDD	R5,Z+9
    019B1 8248      ST	Y,R4
    019B2 8259      STD	Y+1,R5
    019B3 0191      MOVW	R18,R2
    019B4 018F      MOVW	R16,R30
    019B5 940E 087C CALL	ff.c:clmt_clust
    019B7 8709      STD	Y+9,R16
    019B8 871A      STD	Y+10,R17
    019B9 872B      STD	Y+11,R18
    019BA 873C      STD	Y+12,R19
    019BB C011      RJMP	0x19CD
(2512) 					else
(2513) #endif
(2514) 						clst = create_chain(fp->fs, fp->clust);	/* Follow or stretch cluster chain on the FAT */
    019BC 8DEB      LDD	R30,Y+27
    019BD 8DFC      LDD	R31,Y+28
    019BE 8822      LDD	R2,Z+18
    019BF 8833      LDD	R3,Z+19
    019C0 8844      LDD	R4,Z+20
    019C1 8855      LDD	R5,Z+21
    019C2 8248      ST	Y,R4
    019C3 8259      STD	Y+1,R5
    019C4 0191      MOVW	R18,R2
    019C5 8100      LD	R16,Z
    019C6 8111      LDD	R17,Z+1
    019C7 940E 0704 CALL	ff.c:create_chain
    019C9 8709      STD	Y+9,R16
    019CA 871A      STD	Y+10,R17
    019CB 872B      STD	Y+11,R18
    019CC 873C      STD	Y+12,R19
(2515) 				}
(2516) 				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
    019CD 8429      LDD	R2,Y+9
    019CE 843A      LDD	R3,Y+10
    019CF 844B      LDD	R4,Y+11
    019D0 845C      LDD	R5,Y+12
    019D1 9488      BCLR	0
    019D2 2022      TST	R2
    019D3 0432      CPC	R3,R2
    019D4 0442      CPC	R4,R2
    019D5 0452      CPC	R5,R2
    019D6 F409      BNE	0x19D8
    019D7 C1FC      RJMP	0x1BD4
(2517) 				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
    019D8 E041      LDI	R20,1
    019D9 E050      LDI	R21,0
    019DA E060      LDI	R22,0
    019DB E070      LDI	R23,0
    019DC 8429      LDD	R2,Y+9
    019DD 843A      LDD	R3,Y+10
    019DE 844B      LDD	R4,Y+11
    019DF 845C      LDD	R5,Y+12
    019E0 1624      CP	R2,R20
    019E1 0635      CPC	R3,R21
    019E2 0646      CPC	R4,R22
    019E3 0657      CPC	R5,R23
    019E4 F449      BNE	0x19EE
    019E5 8D8B      LDD	R24,Y+27
    019E6 8D9C      LDD	R25,Y+28
    019E7 9604      ADIW	R24,4
    019E8 01FC      MOVW	R30,R24
    019E9 8180      LD	R24,Z
    019EA 6880      ORI	R24,0x80
    019EB 8380      ST	Z,R24
    019EC E002      LDI	R16,2
    019ED C206      RJMP	0x1BF4
(2518) 				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    019EE EF4F      LDI	R20,0xFF
    019EF EF5F      LDI	R21,0xFF
    019F0 EF6F      LDI	R22,0xFF
    019F1 EF7F      LDI	R23,0xFF
    019F2 8429      LDD	R2,Y+9
    019F3 843A      LDD	R3,Y+10
    019F4 844B      LDD	R4,Y+11
    019F5 845C      LDD	R5,Y+12
    019F6 1624      CP	R2,R20
    019F7 0635      CPC	R3,R21
    019F8 0646      CPC	R4,R22
    019F9 0657      CPC	R5,R23
    019FA F451      BNE	0x1A05
    019FB 8D8B      LDD	R24,Y+27
    019FC 8D9C      LDD	R25,Y+28
    019FD 9604      ADIW	R24,4
    019FE 015C      MOVW	R10,R24
    019FF 01FC      MOVW	R30,R24
    01A00 8180      LD	R24,Z
    01A01 6880      ORI	R24,0x80
    01A02 8380      ST	Z,R24
    01A03 E001      LDI	R16,1
    01A04 C1EF      RJMP	0x1BF4
(2519) 				fp->clust = clst;			/* Update current cluster */
    01A05 8429      LDD	R2,Y+9
    01A06 843A      LDD	R3,Y+10
    01A07 844B      LDD	R4,Y+11
    01A08 845C      LDD	R5,Y+12
    01A09 8DEB      LDD	R30,Y+27
    01A0A 8DFC      LDD	R31,Y+28
    01A0B 8A22      STD	Z+18,R2
    01A0C 8A33      STD	Z+19,R3
    01A0D 8A44      STD	Z+20,R4
    01A0E 8A55      STD	Z+21,R5
(2520) 			}
(2521) #if _FS_TINY
(2522) 			if (fp->fs->winsect == fp->dsect && move_window(fp->fs, 0))	/* Write-back sector cache */
    01A0F 8DEB      LDD	R30,Y+27
    01A10 8DFC      LDD	R31,Y+28
    01A11 80A0      LD	R10,Z
    01A12 80B1      LDD	R11,Z+1
    01A13 8826      LDD	R2,Z+22
    01A14 8837      LDD	R3,Z+23
    01A15 8C40      LDD	R4,Z+24
    01A16 8C51      LDD	R5,Z+25
    01A17 01F5      MOVW	R30,R10
    01A18 A462      LDD	R6,Z+42
    01A19 A473      LDD	R7,Z+43
    01A1A A484      LDD	R8,Z+44
    01A1B A495      LDD	R9,Z+45
    01A1C 1462      CP	R6,R2
    01A1D 0473      CPC	R7,R3
    01A1E 0484      CPC	R8,R4
    01A1F 0495      CPC	R9,R5
    01A20 F4B9      BNE	0x1A38
    01A21 E040      LDI	R20,0
    01A22 E050      LDI	R21,0
    01A23 E060      LDI	R22,0
    01A24 E070      LDI	R23,0
    01A25 8368      ST	Y,R22
    01A26 8379      STD	Y+1,R23
    01A27 019A      MOVW	R18,R20
    01A28 018F      MOVW	R16,R30
    01A29 940E 0179 CALL	ff.c:move_window
    01A2B 2EA0      MOV	R10,R16
    01A2C 2300      TST	R16
    01A2D F051      BEQ	0x1A38
(2523) 				ABORT(fp->fs, FR_DISK_ERR);
    01A2E 8D8B      LDD	R24,Y+27
    01A2F 8D9C      LDD	R25,Y+28
    01A30 9604      ADIW	R24,4
    01A31 015C      MOVW	R10,R24
    01A32 01FC      MOVW	R30,R24
    01A33 8180      LD	R24,Z
    01A34 6880      ORI	R24,0x80
    01A35 8380      ST	Z,R24
    01A36 E001      LDI	R16,1
    01A37 C1BC      RJMP	0x1BF4
(2524) #else
(2525) 			if (fp->flag & FA__DIRTY) {		/* Write-back sector cache */
(2526) 				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
(2527) 					ABORT(fp->fs, FR_DISK_ERR);
(2528) 				fp->flag &= ~FA__DIRTY;
(2529) 			}
(2530) #endif
(2531) 			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
    01A38 8DEB      LDD	R30,Y+27
    01A39 8DFC      LDD	R31,Y+28
    01A3A 8822      LDD	R2,Z+18
    01A3B 8833      LDD	R3,Z+19
    01A3C 8844      LDD	R4,Z+20
    01A3D 8855      LDD	R5,Z+21
    01A3E 8248      ST	Y,R4
    01A3F 8259      STD	Y+1,R5
    01A40 0191      MOVW	R18,R2
    01A41 8100      LD	R16,Z
    01A42 8111      LDD	R17,Z+1
    01A43 940E 02F0 CALL	_clust2sect
    01A45 830D      STD	Y+5,R16
    01A46 831E      STD	Y+6,R17
    01A47 832F      STD	Y+7,R18
    01A48 8738      STD	Y+8,R19
(2532) 			if (!sect) ABORT(fp->fs, FR_INT_ERR);
    01A49 802D      LDD	R2,Y+5
    01A4A 803E      LDD	R3,Y+6
    01A4B 804F      LDD	R4,Y+7
    01A4C 8458      LDD	R5,Y+8
    01A4D 9488      BCLR	0
    01A4E 2022      TST	R2
    01A4F 0432      CPC	R3,R2
    01A50 0442      CPC	R4,R2
    01A51 0452      CPC	R5,R2
    01A52 F451      BNE	0x1A5D
    01A53 8D8B      LDD	R24,Y+27
    01A54 8D9C      LDD	R25,Y+28
    01A55 9604      ADIW	R24,4
    01A56 015C      MOVW	R10,R24
    01A57 01FC      MOVW	R30,R24
    01A58 8180      LD	R24,Z
    01A59 6880      ORI	R24,0x80
    01A5A 8380      ST	Z,R24
    01A5B E002      LDI	R16,2
    01A5C C197      RJMP	0x1BF4
(2533) 			sect += csect;
    01A5D 2C2C      MOV	R2,R12
    01A5E 2433      CLR	R3
    01A5F 2444      CLR	R4
    01A60 2455      CLR	R5
    01A61 806D      LDD	R6,Y+5
    01A62 807E      LDD	R7,Y+6
    01A63 808F      LDD	R8,Y+7
    01A64 8498      LDD	R9,Y+8
    01A65 0C62      ADD	R6,R2
    01A66 1C73      ADC	R7,R3
    01A67 1C84      ADC	R8,R4
    01A68 1C95      ADC	R9,R5
    01A69 826D      STD	Y+5,R6
    01A6A 827E      STD	Y+6,R7
    01A6B 828F      STD	Y+7,R8
    01A6C 8698      STD	Y+8,R9
(2534) 			cc = btw / SS(fp->fs);			/* When remaining bytes >= sector size, */
    01A6D E029      LDI	R18,0x9
    01A6E E030      LDI	R19,0
    01A6F 8D0F      LDD	R16,Y+31
    01A70 A118      LDD	R17,Y+32
    01A71 940E 2803 CALL	lsr16
    01A73 0158      MOVW	R10,R16
(2535) 			if (cc) {						/* Write maximum contiguous sectors directly */
    01A74 3000      CPI	R16,0
    01A75 0701      CPC	R16,R17
    01A76 F409      BNE	0x1A78
    01A77 C097      RJMP	0x1B0F
(2536) 				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
    01A78 2C2C      MOV	R2,R12
    01A79 2433      CLR	R3
    01A7A 0E20      ADD	R2,R16
    01A7B 1E31      ADC	R3,R17
    01A7C 8DEB      LDD	R30,Y+27
    01A7D 8DFC      LDD	R31,Y+28
    01A7E 93AF      PUSH	R26
    01A7F 93BF      PUSH	R27
    01A80 81A0      LD	R26,Z
    01A81 81B1      LDD	R27,Z+1
    01A82 01FD      MOVW	R30,R26
    01A83 91BF      POP	R27
    01A84 91AF      POP	R26
    01A85 8042      LDD	R4,Z+2
    01A86 2455      CLR	R5
    01A87 1442      CP	R4,R2
    01A88 0453      CPC	R5,R3
    01A89 F478      BCC	0x1A99
(2537) 					cc = fp->fs->csize - csect;
    01A8A 2C2C      MOV	R2,R12
    01A8B 2433      CLR	R3
    01A8C 8DEB      LDD	R30,Y+27
    01A8D 8DFC      LDD	R31,Y+28
    01A8E 93AF      PUSH	R26
    01A8F 93BF      PUSH	R27
    01A90 81A0      LD	R26,Z
    01A91 81B1      LDD	R27,Z+1
    01A92 01FD      MOVW	R30,R26
    01A93 91BF      POP	R27
    01A94 91AF      POP	R26
    01A95 80A2      LDD	R10,Z+2
    01A96 24BB      CLR	R11
    01A97 18A2      SUB	R10,R2
    01A98 08B3      SBC	R11,R3
(2538) 				if (disk_write(fp->fs->drv,(char*)wbuff, sect, (BYTE)cc) != RES_OK)
    01A99 82AC      STD	Y+4,R10
    01A9A 802D      LDD	R2,Y+5
    01A9B 803E      LDD	R3,Y+6
    01A9C 804F      LDD	R4,Y+7
    01A9D 8458      LDD	R5,Y+8
    01A9E 8228      ST	Y,R2
    01A9F 8239      STD	Y+1,R3
    01AA0 824A      STD	Y+2,R4
    01AA1 825B      STD	Y+3,R5
    01AA2 0197      MOVW	R18,R14
    01AA3 8DEB      LDD	R30,Y+27
    01AA4 8DFC      LDD	R31,Y+28
    01AA5 93AF      PUSH	R26
    01AA6 93BF      PUSH	R27
    01AA7 81A0      LD	R26,Z
    01AA8 81B1      LDD	R27,Z+1
    01AA9 01FD      MOVW	R30,R26
    01AAA 91BF      POP	R27
    01AAB 91AF      POP	R26
    01AAC 8101      LDD	R16,Z+1
    01AAD 940E 00FE CALL	_disk_write
    01AAF 2EC0      MOV	R12,R16
    01AB0 2300      TST	R16
    01AB1 F051      BEQ	0x1ABC
(2539) 					ABORT(fp->fs, FR_DISK_ERR);
    01AB2 8D8B      LDD	R24,Y+27
    01AB3 8D9C      LDD	R25,Y+28
    01AB4 9604      ADIW	R24,4
    01AB5 016C      MOVW	R12,R24
    01AB6 01FC      MOVW	R30,R24
    01AB7 8180      LD	R24,Z
    01AB8 6880      ORI	R24,0x80
    01AB9 8380      ST	Z,R24
    01ABA E001      LDI	R16,1
    01ABB C138      RJMP	0x1BF4
(2540) #if _FS_TINY
(2541) 				if (fp->fs->winsect - sect < cc) {	/* Refill sector cache if it gets invalidated by the direct write */
    01ABC 802D      LDD	R2,Y+5
    01ABD 803E      LDD	R3,Y+6
    01ABE 804F      LDD	R4,Y+7
    01ABF 8458      LDD	R5,Y+8
    01AC0 8DEB      LDD	R30,Y+27
    01AC1 8DFC      LDD	R31,Y+28
    01AC2 81A0      LD	R26,Z
    01AC3 81B1      LDD	R27,Z+1
    01AC4 969A      ADIW	R26,0x2A
    01AC5 906D      LD	R6,X+
    01AC6 907D      LD	R7,X+
    01AC7 908D      LD	R8,X+
    01AC8 909C      LD	R9,X
    01AC9 1862      SUB	R6,R2
    01ACA 0873      SBC	R7,R3
    01ACB 0884      SBC	R8,R4
    01ACC 0895      SBC	R9,R5
    01ACD 0115      MOVW	R2,R10
    01ACE 2444      CLR	R4
    01ACF 2455      CLR	R5
    01AD0 1462      CP	R6,R2
    01AD1 0473      CPC	R7,R3
    01AD2 0484      CPC	R8,R4
    01AD3 0495      CPC	R9,R5
    01AD4 F008      BCS	0x1AD6
    01AD5 C032      RJMP	0x1B08
(2542) 					mem_cpy(fp->fs->win, wbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), SS(fp->fs));
    01AD6 E080      LDI	R24,0
    01AD7 E092      LDI	R25,2
    01AD8 8399      STD	Y+1,R25
    01AD9 8388      ST	Y,R24
    01ADA 80C0      LD	R12,Z
    01ADB 80D1      LDD	R13,Z+1
    01ADC 802D      LDD	R2,Y+5
    01ADD 803E      LDD	R3,Y+6
    01ADE 804F      LDD	R4,Y+7
    01ADF 8458      LDD	R5,Y+8
    01AE0 01F6      MOVW	R30,R12
    01AE1 A462      LDD	R6,Z+42
    01AE2 A473      LDD	R7,Z+43
    01AE3 A484      LDD	R8,Z+44
    01AE4 A495      LDD	R9,Z+45
    01AE5 1862      SUB	R6,R2
    01AE6 0873      SBC	R7,R3
    01AE7 0884      SBC	R8,R4
    01AE8 0895      SBC	R9,R5
    01AE9 E040      LDI	R20,0
    01AEA E052      LDI	R21,2
    01AEB E060      LDI	R22,0
    01AEC E070      LDI	R23,0
    01AED 929A      ST	-Y,R9
    01AEE 928A      ST	-Y,R8
    01AEF 927A      ST	-Y,R7
    01AF0 926A      ST	-Y,R6
    01AF1 018A      MOVW	R16,R20
    01AF2 019B      MOVW	R18,R22
    01AF3 940E 2728 CALL	empy32s|empy32u
    01AF5 0198      MOVW	R18,R16
    01AF6 0D2E      ADD	R18,R14
    01AF7 1D3F      ADC	R19,R15
    01AF8 0186      MOVW	R16,R12
    01AF9 5D02      SUBI	R16,0xD2
    01AFA 4F1F      SBCI	R17,0xFF
    01AFB 940E 0120 CALL	ff.c:mem_cpy
(2543) 					fp->fs->wflag = 0;
    01AFD 2422      CLR	R2
    01AFE 8DEB      LDD	R30,Y+27
    01AFF 8DFC      LDD	R31,Y+28
    01B00 93AF      PUSH	R26
    01B01 93BF      PUSH	R27
    01B02 81A0      LD	R26,Z
    01B03 81B1      LDD	R27,Z+1
    01B04 01FD      MOVW	R30,R26
    01B05 91BF      POP	R27
    01B06 91AF      POP	R26
    01B07 8224      STD	Z+4,R2
(2544) 				}
(2545) #else
(2546) 				if (fp->dsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
(2547) 					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
(2548) 					fp->flag &= ~FA__DIRTY;
(2549) 				}
(2550) #endif
(2551) 				wcnt = SS(fp->fs) * cc;		/* Number of bytes transferred */
    01B08 E000      LDI	R16,0
    01B09 E012      LDI	R17,2
    01B0A 0195      MOVW	R18,R10
    01B0B 940E 2718 CALL	empy16s
    01B0D 0168      MOVW	R12,R16
(2552) 				continue;
    01B0E C099      RJMP	0x1BA8
(2553) 			}
(2554) #if _FS_TINY
(2555) 			if (fp->fptr >= fp->fsize) {	/* Avoid silly cache filling at growing edge */
    01B0F 8DEB      LDD	R30,Y+27
    01B10 8DFC      LDD	R31,Y+28
    01B11 8422      LDD	R2,Z+10
    01B12 8433      LDD	R3,Z+11
    01B13 8444      LDD	R4,Z+12
    01B14 8455      LDD	R5,Z+13
    01B15 8066      LDD	R6,Z+6
    01B16 8077      LDD	R7,Z+7
    01B17 8480      LDD	R8,Z+8
    01B18 8491      LDD	R9,Z+9
    01B19 1462      CP	R6,R2
    01B1A 0473      CPC	R7,R3
    01B1B 0484      CPC	R8,R4
    01B1C 0495      CPC	R9,R5
    01B1D F128      BCS	0x1B43
(2556) 				if (move_window(fp->fs, 0)) ABORT(fp->fs, FR_DISK_ERR);
    01B1E E040      LDI	R20,0
    01B1F E050      LDI	R21,0
    01B20 E060      LDI	R22,0
    01B21 E070      LDI	R23,0
    01B22 8368      ST	Y,R22
    01B23 8379      STD	Y+1,R23
    01B24 019A      MOVW	R18,R20
    01B25 8100      LD	R16,Z
    01B26 8111      LDD	R17,Z+1
    01B27 940E 0179 CALL	ff.c:move_window
    01B29 2EA0      MOV	R10,R16
    01B2A 2300      TST	R16
    01B2B F051      BEQ	0x1B36
    01B2C 8D8B      LDD	R24,Y+27
    01B2D 8D9C      LDD	R25,Y+28
    01B2E 9604      ADIW	R24,4
    01B2F 015C      MOVW	R10,R24
    01B30 01FC      MOVW	R30,R24
    01B31 8180      LD	R24,Z
    01B32 6880      ORI	R24,0x80
    01B33 8380      ST	Z,R24
    01B34 E001      LDI	R16,1
    01B35 C0BE      RJMP	0x1BF4
(2557) 				fp->fs->winsect = sect;
    01B36 802D      LDD	R2,Y+5
    01B37 803E      LDD	R3,Y+6
    01B38 804F      LDD	R4,Y+7
    01B39 8458      LDD	R5,Y+8
    01B3A 8DEB      LDD	R30,Y+27
    01B3B 8DFC      LDD	R31,Y+28
    01B3C 81A0      LD	R26,Z
    01B3D 81B1      LDD	R27,Z+1
    01B3E 969A      ADIW	R26,0x2A
    01B3F 922D      ST	X+,R2
    01B40 923D      ST	X+,R3
    01B41 924D      ST	X+,R4
    01B42 925C      ST	X,R5
(2558) 			}
(2559) #else
(2560) 			if (fp->dsect != sect) {		/* Fill sector cache with file data */
(2561) 				if (fp->fptr < fp->fsize &&
(2562) 					disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
(2563) 						ABORT(fp->fs, FR_DISK_ERR);
(2564) 			}
(2565) #endif
(2566) 			fp->dsect = sect;
    01B43 802D      LDD	R2,Y+5
    01B44 803E      LDD	R3,Y+6
    01B45 804F      LDD	R4,Y+7
    01B46 8458      LDD	R5,Y+8
    01B47 8DEB      LDD	R30,Y+27
    01B48 8DFC      LDD	R31,Y+28
    01B49 8A26      STD	Z+22,R2
    01B4A 8A37      STD	Z+23,R3
    01B4B 8E40      STD	Z+24,R4
    01B4C 8E51      STD	Z+25,R5
(2567) 		}
(2568) 		wcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));/* Put partial sector into file I/O buffer */
    01B4D EF4F      LDI	R20,0xFF
    01B4E E051      LDI	R21,1
    01B4F E060      LDI	R22,0
    01B50 E070      LDI	R23,0
    01B51 8DEB      LDD	R30,Y+27
    01B52 8DFC      LDD	R31,Y+28
    01B53 8026      LDD	R2,Z+6
    01B54 8037      LDD	R3,Z+7
    01B55 8440      LDD	R4,Z+8
    01B56 8451      LDD	R5,Z+9
    01B57 2224      AND	R2,R20
    01B58 2235      AND	R3,R21
    01B59 2246      AND	R4,R22
    01B5A 2257      AND	R5,R23
    01B5B E040      LDI	R20,0
    01B5C E052      LDI	R21,2
    01B5D E060      LDI	R22,0
    01B5E E070      LDI	R23,0
    01B5F 1942      SUB	R20,R2
    01B60 0953      SBC	R21,R3
    01B61 0964      SBC	R22,R4
    01B62 0975      SBC	R23,R5
    01B63 016A      MOVW	R12,R20
(2569) 		if (wcnt > btw) wcnt = btw;
    01B64 8C0F      LDD	R0,Y+31
    01B65 A018      LDD	R1,Y+32
    01B66 1604      CP	R0,R20
    01B67 0615      CPC	R1,R21
    01B68 F408      BCC	0x1B6A
    01B69 0160      MOVW	R12,R0
(2570) #if _FS_TINY
(2571) 		if (move_window(fp->fs, fp->dsect))	/* Move sector window */
    01B6A 8DEB      LDD	R30,Y+27
    01B6B 8DFC      LDD	R31,Y+28
    01B6C 8826      LDD	R2,Z+22
    01B6D 8837      LDD	R3,Z+23
    01B6E 8C40      LDD	R4,Z+24
    01B6F 8C51      LDD	R5,Z+25
    01B70 8248      ST	Y,R4
    01B71 8259      STD	Y+1,R5
    01B72 0191      MOVW	R18,R2
    01B73 8100      LD	R16,Z
    01B74 8111      LDD	R17,Z+1
    01B75 940E 0179 CALL	ff.c:move_window
    01B77 2EA0      MOV	R10,R16
    01B78 2300      TST	R16
    01B79 F051      BEQ	0x1B84
(2572) 			ABORT(fp->fs, FR_DISK_ERR);
    01B7A 8D8B      LDD	R24,Y+27
    01B7B 8D9C      LDD	R25,Y+28
    01B7C 9604      ADIW	R24,4
    01B7D 015C      MOVW	R10,R24
    01B7E 01FC      MOVW	R30,R24
    01B7F 8180      LD	R24,Z
    01B80 6880      ORI	R24,0x80
    01B81 8380      ST	Z,R24
    01B82 E001      LDI	R16,1
    01B83 C070      RJMP	0x1BF4
(2573) 		mem_cpy(&fp->fs->win[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
    01B84 82D9      STD	Y+1,R13
    01B85 82C8      ST	Y,R12
    01B86 0197      MOVW	R18,R14
    01B87 EF4F      LDI	R20,0xFF
    01B88 E051      LDI	R21,1
    01B89 E060      LDI	R22,0
    01B8A E070      LDI	R23,0
    01B8B 8DEB      LDD	R30,Y+27
    01B8C 8DFC      LDD	R31,Y+28
    01B8D 8026      LDD	R2,Z+6
    01B8E 8037      LDD	R3,Z+7
    01B8F 8440      LDD	R4,Z+8
    01B90 8451      LDD	R5,Z+9
    01B91 2224      AND	R2,R20
    01B92 2235      AND	R3,R21
    01B93 2246      AND	R4,R22
    01B94 2257      AND	R5,R23
    01B95 0181      MOVW	R16,R2
    01B96 8180      LD	R24,Z
    01B97 8191      LDD	R25,Z+1
    01B98 968E      ADIW	R24,0x2E
    01B99 0F08      ADD	R16,R24
    01B9A 1F19      ADC	R17,R25
    01B9B 940E 0120 CALL	ff.c:mem_cpy
(2574) 		fp->fs->wflag = 1;
    01B9D E081      LDI	R24,1
    01B9E 8DEB      LDD	R30,Y+27
    01B9F 8DFC      LDD	R31,Y+28
    01BA0 93AF      PUSH	R26
    01BA1 93BF      PUSH	R27
    01BA2 81A0      LD	R26,Z
    01BA3 81B1      LDD	R27,Z+1
    01BA4 01FD      MOVW	R30,R26
    01BA5 91BF      POP	R27
    01BA6 91AF      POP	R26
    01BA7 8384      STD	Z+4,R24
    01BA8 0CEC      ADD	R14,R12
    01BA9 1CFD      ADC	R15,R13
    01BAA 8D8B      LDD	R24,Y+27
    01BAB 8D9C      LDD	R25,Y+28
    01BAC 9606      ADIW	R24,6
    01BAD 015C      MOVW	R10,R24
    01BAE 0116      MOVW	R2,R12
    01BAF 2444      CLR	R4
    01BB0 2455      CLR	R5
    01BB1 01FC      MOVW	R30,R24
    01BB2 8060      LD	R6,Z
    01BB3 8071      LDD	R7,Z+1
    01BB4 8082      LDD	R8,Z+2
    01BB5 8093      LDD	R9,Z+3
    01BB6 0C62      ADD	R6,R2
    01BB7 1C73      ADC	R7,R3
    01BB8 1C84      ADC	R8,R4
    01BB9 1C95      ADC	R9,R5
    01BBA 8260      ST	Z,R6
    01BBB 8271      STD	Z+1,R7
    01BBC 8282      STD	Z+2,R8
    01BBD 8293      STD	Z+3,R9
    01BBE A1E9      LDD	R30,Y+33
    01BBF A1FA      LDD	R31,Y+34
    01BC0 8020      LD	R2,Z
    01BC1 8031      LDD	R3,Z+1
    01BC2 0C2C      ADD	R2,R12
    01BC3 1C3D      ADC	R3,R13
    01BC4 8231      STD	Z+1,R3
    01BC5 8220      ST	Z,R2
    01BC6 8C0F      LDD	R0,Y+31
    01BC7 A018      LDD	R1,Y+32
    01BC8 180C      SUB	R0,R12
    01BC9 081D      SBC	R1,R13
    01BCA A218      STD	Y+32,R1
    01BCB 8E0F      STD	Y+31,R0
    01BCC 8C0F      LDD	R0,Y+31
    01BCD A018      LDD	R1,Y+32
    01BCE 2000      TST	R0
    01BCF F009      BEQ	0x1BD1
    01BD0 CD5B      RJMP	0x192C
    01BD1 2011      TST	R1
    01BD2 F009      BEQ	0x1BD4
    01BD3 CD58      RJMP	0x192C
(2575) #else
(2576) 		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
(2577) 		fp->flag |= FA__DIRTY;
(2578) #endif
(2579) 	}
(2580) 
(2581) 	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
    01BD4 8DEB      LDD	R30,Y+27
    01BD5 8DFC      LDD	R31,Y+28
    01BD6 8422      LDD	R2,Z+10
    01BD7 8433      LDD	R3,Z+11
    01BD8 8444      LDD	R4,Z+12
    01BD9 8455      LDD	R5,Z+13
    01BDA 8066      LDD	R6,Z+6
    01BDB 8077      LDD	R7,Z+7
    01BDC 8480      LDD	R8,Z+8
    01BDD 8491      LDD	R9,Z+9
    01BDE 1426      CP	R2,R6
    01BDF 0437      CPC	R3,R7
    01BE0 0448      CPC	R4,R8
    01BE1 0459      CPC	R5,R9
    01BE2 F440      BCC	0x1BEB
    01BE3 8026      LDD	R2,Z+6
    01BE4 8037      LDD	R3,Z+7
    01BE5 8440      LDD	R4,Z+8
    01BE6 8451      LDD	R5,Z+9
    01BE7 8622      STD	Z+10,R2
    01BE8 8633      STD	Z+11,R3
    01BE9 8644      STD	Z+12,R4
    01BEA 8655      STD	Z+13,R5
(2582) 	fp->flag |= FA__WRITTEN;						/* Set file change flag */
    01BEB 8D8B      LDD	R24,Y+27
    01BEC 8D9C      LDD	R25,Y+28
    01BED 9604      ADIW	R24,4
    01BEE 015C      MOVW	R10,R24
    01BEF 01FC      MOVW	R30,R24
    01BF0 8180      LD	R24,Z
    01BF1 6280      ORI	R24,0x20
    01BF2 8380      ST	Z,R24
(2583) 
(2584) 	LEAVE_FF(fp->fs, FR_OK);
    01BF3 2700      CLR	R16
    01BF4 9661      ADIW	R28,0x11
    01BF5 940E 2771 CALL	pop_xgsetF0FC
    01BF7 9624      ADIW	R28,4
    01BF8 9508      RET
_f_sync:
  tim                  --> Y,+2
  dir                  --> R22
  res                  --> R10
  fp                   --> R20
    01BF9 940E 27B7 CALL	push_xgsetF03C
    01BFB 01A8      MOVW	R20,R16
    01BFC 9726      SBIW	R28,6
(2585) }
(2586) 
(2587) 
(2588) 
(2589) 
(2590) /*-----------------------------------------------------------------------*/
(2591) /* Synchronize the File Object                                           */
(2592) /*-----------------------------------------------------------------------*/
(2593) 
(2594) FRESULT f_sync (
(2595) 	FIL *fp		/* Pointer to the file object */
(2596) )
(2597) {
(2598) 	FRESULT res;
(2599) 	DWORD tim;
(2600) 	BYTE *dir;
(2601) 
(2602) 
(2603) 	res = validate(fp->fs, fp->id);		/* Check validity of the object */
    01BFD 01FA      MOVW	R30,R20
    01BFE 8122      LDD	R18,Z+2
    01BFF 8133      LDD	R19,Z+3
    01C00 8100      LD	R16,Z
    01C01 8111      LDD	R17,Z+1
    01C02 D88E      RCALL	ff.c:validate
    01C03 2EA0      MOV	R10,R16
(2604) 	if (res == FR_OK) {
    01C04 2300      TST	R16
    01C05 F009      BEQ	0x1C07
    01C06 C09F      RJMP	0x1CA6
(2605) 		if (fp->flag & FA__WRITTEN) {	/* Has the file been written? */
    01C07 01FA      MOVW	R30,R20
    01C08 8024      LDD	R2,Z+4
    01C09 FE25      SBRS	R2,5
    01C0A C09B      RJMP	0x1CA6
(2606) #if !_FS_TINY	/* Write-back dirty buffer */
(2607) 			if (fp->flag & FA__DIRTY) {
(2608) 				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
(2609) 					LEAVE_FF(fp->fs, FR_DISK_ERR);
(2610) 				fp->flag &= ~FA__DIRTY;
(2611) 			}
(2612) #endif
(2613) 			/* Update the directory entry */
(2614) 			res = move_window(fp->fs, fp->dir_sect);
    01C0B 8C22      LDD	R2,Z+26
    01C0C 8C33      LDD	R3,Z+27
    01C0D 8C44      LDD	R4,Z+28
    01C0E 8C55      LDD	R5,Z+29
    01C0F 8248      ST	Y,R4
    01C10 8259      STD	Y+1,R5
    01C11 0191      MOVW	R18,R2
    01C12 8100      LD	R16,Z
    01C13 8111      LDD	R17,Z+1
    01C14 940E 0179 CALL	ff.c:move_window
    01C16 2EA0      MOV	R10,R16
(2615) 			if (res == FR_OK) {
    01C17 2300      TST	R16
    01C18 F009      BEQ	0x1C1A
    01C19 C08C      RJMP	0x1CA6
(2616) 				dir = fp->dir_ptr;
    01C1A 01FA      MOVW	R30,R20
    01C1B 8D66      LDD	R22,Z+30
    01C1C 8D77      LDD	R23,Z+31
(2617) 				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
    01C1D 01CB      MOVW	R24,R22
    01C1E 960B      ADIW	R24,0xB
    01C1F 01FC      MOVW	R30,R24
    01C20 8180      LD	R24,Z
    01C21 6280      ORI	R24,0x20
    01C22 8380      ST	Z,R24
(2618) 				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
    01C23 01FA      MOVW	R30,R20
    01C24 8422      LDD	R2,Z+10
    01C25 8433      LDD	R3,Z+11
    01C26 8444      LDD	R4,Z+12
    01C27 8455      LDD	R5,Z+13
    01C28 01FB      MOVW	R30,R22
    01C29 8E24      STD	Z+28,R2
    01C2A 01FA      MOVW	R30,R20
    01C2B 8422      LDD	R2,Z+10
    01C2C 8433      LDD	R3,Z+11
    01C2D 2C23      MOV	R2,R3
    01C2E 2433      CLR	R3
    01C2F 01FB      MOVW	R30,R22
    01C30 8E25      STD	Z+29,R2
    01C31 01FA      MOVW	R30,R20
    01C32 8422      LDD	R2,Z+10
    01C33 8433      LDD	R3,Z+11
    01C34 8444      LDD	R4,Z+12
    01C35 8455      LDD	R5,Z+13
    01C36 0112      MOVW	R2,R4
    01C37 2444      CLR	R4
    01C38 2455      CLR	R5
    01C39 01FB      MOVW	R30,R22
    01C3A 8E26      STD	Z+30,R2
    01C3B E188      LDI	R24,0x18
    01C3C E090      LDI	R25,0
    01C3D 01FA      MOVW	R30,R20
    01C3E 8502      LDD	R16,Z+10
    01C3F 8513      LDD	R17,Z+11
    01C40 8524      LDD	R18,Z+12
    01C41 8535      LDD	R19,Z+13
    01C42 938A      ST	-Y,R24
    01C43 940E 280A CALL	lsr32
    01C45 01FB      MOVW	R30,R22
    01C46 8F07      STD	Z+31,R16
(2619) 				ST_CLUST(dir, fp->sclust);					/* Update start cluster */
    01C47 01FA      MOVW	R30,R20
    01C48 8426      LDD	R2,Z+14
    01C49 8437      LDD	R3,Z+15
    01C4A 8840      LDD	R4,Z+16
    01C4B 8851      LDD	R5,Z+17
    01C4C 01FB      MOVW	R30,R22
    01C4D 8E22      STD	Z+26,R2
    01C4E 01FA      MOVW	R30,R20
    01C4F 8426      LDD	R2,Z+14
    01C50 8437      LDD	R3,Z+15
    01C51 2C23      MOV	R2,R3
    01C52 2433      CLR	R3
    01C53 01FB      MOVW	R30,R22
    01C54 8E23      STD	Z+27,R2
    01C55 01FA      MOVW	R30,R20
    01C56 8426      LDD	R2,Z+14
    01C57 8437      LDD	R3,Z+15
    01C58 8840      LDD	R4,Z+16
    01C59 8851      LDD	R5,Z+17
    01C5A 0112      MOVW	R2,R4
    01C5B 2444      CLR	R4
    01C5C 2455      CLR	R5
    01C5D 01FB      MOVW	R30,R22
    01C5E 8A24      STD	Z+20,R2
    01C5F 01FA      MOVW	R30,R20
    01C60 8426      LDD	R2,Z+14
    01C61 8437      LDD	R3,Z+15
    01C62 8840      LDD	R4,Z+16
    01C63 8851      LDD	R5,Z+17
    01C64 0112      MOVW	R2,R4
    01C65 2C23      MOV	R2,R3
    01C66 2433      CLR	R3
    01C67 01FB      MOVW	R30,R22
    01C68 8A25      STD	Z+21,R2
(2620) 				tim = get_fattime();						/* Update updated time */
    01C69 940E 011B CALL	_get_fattime
    01C6B 830A      STD	Y+2,R16
    01C6C 831B      STD	Y+3,R17
    01C6D 832C      STD	Y+4,R18
    01C6E 833D      STD	Y+5,R19
(2621) 				ST_DWORD(dir+DIR_WrtTime, tim);
    01C6F 802A      LDD	R2,Y+2
    01C70 803B      LDD	R3,Y+3
    01C71 804C      LDD	R4,Y+4
    01C72 805D      LDD	R5,Y+5
    01C73 01FB      MOVW	R30,R22
    01C74 8A26      STD	Z+22,R2
    01C75 2C23      MOV	R2,R3
    01C76 2433      CLR	R3
    01C77 9677      ADIW	R30,0x17
    01C78 8220      ST	Z,R2
    01C79 802A      LDD	R2,Y+2
    01C7A 803B      LDD	R3,Y+3
    01C7B 804C      LDD	R4,Y+4
    01C7C 805D      LDD	R5,Y+5
    01C7D 0112      MOVW	R2,R4
    01C7E 2444      CLR	R4
    01C7F 2455      CLR	R5
    01C80 01FB      MOVW	R30,R22
    01C81 9678      ADIW	R30,0x18
    01C82 8220      ST	Z,R2
    01C83 E188      LDI	R24,0x18
    01C84 E090      LDI	R25,0
    01C85 810A      LDD	R16,Y+2
    01C86 811B      LDD	R17,Y+3
    01C87 812C      LDD	R18,Y+4
    01C88 813D      LDD	R19,Y+5
    01C89 938A      ST	-Y,R24
    01C8A 940E 280A CALL	lsr32
    01C8C 01FB      MOVW	R30,R22
    01C8D 8F01      STD	Z+25,R16
(2622) 				fp->flag &= ~FA__WRITTEN;
    01C8E 01BA      MOVW	R22,R20
    01C8F 5F6C      SUBI	R22,0xFC
    01C90 4F7F      SBCI	R23,0xFF
    01C91 01FB      MOVW	R30,R22
    01C92 8180      LD	R24,Z
    01C93 7D8F      ANDI	R24,0xDF
    01C94 8380      ST	Z,R24
(2623) 				fp->fs->wflag = 1;
    01C95 E081      LDI	R24,1
    01C96 01FA      MOVW	R30,R20
    01C97 93AF      PUSH	R26
    01C98 93BF      PUSH	R27
    01C99 81A0      LD	R26,Z
    01C9A 81B1      LDD	R27,Z+1
    01C9B 01FD      MOVW	R30,R26
    01C9C 91BF      POP	R27
    01C9D 91AF      POP	R26
    01C9E 8384      STD	Z+4,R24
(2624) 				res = sync(fp->fs);
    01C9F 01FA      MOVW	R30,R20
    01CA0 8100      LD	R16,Z
    01CA1 8111      LDD	R17,Z+1
    01CA2 940E 021B CALL	ff.c:sync
    01CA4 2EC0      MOV	R12,R16
    01CA5 2CAC      MOV	R10,R12
(2625) 			}
(2626) 		}
(2627) 	}
(2628) 
(2629) 	LEAVE_FF(fp->fs, res);
    01CA6 2D0A      MOV	R16,R10
    01CA7 9626      ADIW	R28,6
    01CA8 940C 27C0 JMP	pop_xgsetF03C
_f_close:
  res                  --> R10
  fp                   --> R12
    01CAA 940E 2782 CALL	push_xgset003C
    01CAC 0168      MOVW	R12,R16
(2630) }
(2631) 
(2632) #endif /* !_FS_READONLY */
(2633) 
(2634) 
(2635) 
(2636) 
(2637) /*-----------------------------------------------------------------------*/
(2638) /* Close File                                                            */
(2639) /*-----------------------------------------------------------------------*/
(2640) 
(2641) FRESULT f_close (
(2642) 	FIL *fp		/* Pointer to the file object to be closed */
(2643) )
(2644) {
(2645) 	FRESULT res;
(2646) 
(2647) #if _FS_READONLY
(2648) 	FATFS *fs = fp->fs;
(2649) 	res = validate(fs, fp->id);
(2650) 	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
(2651) 	LEAVE_FF(fs, res);
(2652) 
(2653) #else
(2654) 	res = f_sync(fp);		/* Flush cached data */
    01CAD 0186      MOVW	R16,R12
    01CAE DF4A      RCALL	_f_sync
    01CAF 2EA0      MOV	R10,R16
(2655) #if _FS_SHARE
(2656) 	if (res == FR_OK) {		/* Decrement open counter */
(2657) #if _FS_REENTRANT
(2658) 		res = validate(fp->fs, fp->id);
(2659) 		if (res == FR_OK) {
(2660) 			res = dec_lock(fp->lockid);	
(2661) 			unlock_fs(fp->fs, FR_OK);
(2662) 		}
(2663) #else
(2664) 		res = dec_lock(fp->lockid);
(2665) #endif
(2666) 	}
(2667) #endif
(2668) 	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
    01CB0 2300      TST	R16
    01CB1 F429      BNE	0x1CB7
    01CB2 2422      CLR	R2
    01CB3 2433      CLR	R3
    01CB4 01F6      MOVW	R30,R12
    01CB5 8231      STD	Z+1,R3
    01CB6 8220      ST	Z,R2
(2669) 	return res;
    01CB7 2D0A      MOV	R16,R10
    01CB8 940C 275C JMP	pop_xgset003C
_f_lseek:
  ifptr                --> Y,+14
  nsect                --> Y,+10
  bcs                  --> Y,+6
  clst                 --> Y,+2
  dsc                  --> Y,+26
  tlen                 --> Y,+22
  tbl                  --> R14
  tcl                  --> Y,+18
  ulen                 --> Y,+14
  ncl                  --> Y,+10
  pcl                  --> Y,+6
  cl                   --> Y,+2
  res                  --> R10
  ofs                  --> Y,+42
  fp                   --> Y,+40
    01CBA 940E 26A9 CALL	push_arg4
    01CBC 940E 277C CALL	push_xgsetF0FC
    01CBE 976E      SBIW	R28,0x1E
(2670) #endif
(2671) }
(2672) 
(2673) 
(2674) 
(2675) 
(2676) /*-----------------------------------------------------------------------*/
(2677) /* Current Drive/Directory Handlings                                     */
(2678) /*-----------------------------------------------------------------------*/
(2679) 
(2680) #if _FS_RPATH >= 1
(2681) 
(2682) FRESULT f_chdrive (
(2683) 	BYTE drv		/* Drive number */
(2684) )
(2685) {
(2686) 	if (drv >= _VOLUMES) return FR_INVALID_DRIVE;
(2687) 
(2688) 	CurrVol = drv;
(2689) 
(2690) 	return FR_OK;
(2691) }
(2692) 
(2693) 
(2694) 
(2695) FRESULT f_chdir (
(2696) 	const TCHAR *path	/* Pointer to the directory path */
(2697) )
(2698) {
(2699) 	FRESULT res;
(2700) 	DIR dj;
(2701) 	DEF_NAMEBUF;
(2702) 
(2703) 
(2704) 	res = chk_mounted(&path, &dj.fs, 0);
(2705) 	if (res == FR_OK) {
(2706) 		INIT_BUF(dj);
(2707) 		res = follow_path(&dj, path);		/* Follow the path */
(2708) 		FREE_BUF();
(2709) 		if (res == FR_OK) {					/* Follow completed */
(2710) 			if (!dj.dir) {
(2711) 				dj.fs->cdir = dj.sclust;	/* Start directory itself */
(2712) 			} else {
(2713) 				if (dj.dir[DIR_Attr] & AM_DIR)	/* Reached to the directory */
(2714) 					dj.fs->cdir = LD_CLUST(dj.dir);
(2715) 				else
(2716) 					res = FR_NO_PATH;		/* Reached but a file */
(2717) 			}
(2718) 		}
(2719) 		if (res == FR_NO_FILE) res = FR_NO_PATH;
(2720) 	}
(2721) 
(2722) 	LEAVE_FF(dj.fs, res);
(2723) }
(2724) 
(2725) 
(2726) #if _FS_RPATH >= 2
(2727) FRESULT f_getcwd (
(2728) 	TCHAR *path,	/* Pointer to the directory path */
(2729) 	UINT sz_path	/* Size of path */
(2730) )
(2731) {
(2732) 	FRESULT res;
(2733) 	DIR dj;
(2734) 	UINT i, n;
(2735) 	DWORD ccl;
(2736) 	TCHAR *tp;
(2737) 	FILINFO fno;
(2738) 	DEF_NAMEBUF;
(2739) 
(2740) 
(2741) 	*path = 0;
(2742) 	res = chk_mounted((const TCHAR**)&path, &dj.fs, 0);	/* Get current volume */
(2743) 	if (res == FR_OK) {
(2744) 		INIT_BUF(dj);
(2745) 		i = sz_path;		/* Bottom of buffer (dir stack base) */
(2746) 		dj.sclust = dj.fs->cdir;			/* Start to follow upper dir from current dir */
(2747) 		while ((ccl = dj.sclust) != 0) {	/* Repeat while current dir is a sub-dir */
(2748) 			res = dir_sdi(&dj, 1);			/* Get parent dir */
(2749) 			if (res != FR_OK) break;
(2750) 			res = dir_read(&dj);
(2751) 			if (res != FR_OK) break;
(2752) 			dj.sclust = LD_CLUST(dj.dir);	/* Goto parent dir */
(2753) 			res = dir_sdi(&dj, 0);
(2754) 			if (res != FR_OK) break;
(2755) 			do {							/* Find the entry links to the child dir */
(2756) 				res = dir_read(&dj);
(2757) 				if (res != FR_OK) break;
(2758) 				if (ccl == LD_CLUST(dj.dir)) break;	/* Found the entry */
(2759) 				res = dir_next(&dj, 0);	
(2760) 			} while (res == FR_OK);
(2761) 			if (res == FR_NO_FILE) res = FR_INT_ERR;/* It cannot be 'not found'. */
(2762) 			if (res != FR_OK) break;
(2763) #if _USE_LFN
(2764) 			fno.lfname = path;
(2765) 			fno.lfsize = i;
(2766) #endif
(2767) 			get_fileinfo(&dj, &fno);		/* Get the dir name and push it to the buffer */
(2768) 			tp = fno.fname;
(2769) 			if (_USE_LFN && *path) tp = path;
(2770) 			for (n = 0; tp[n]; n++) ;
(2771) 			if (i < n + 3) {
(2772) 				res = FR_NOT_ENOUGH_CORE; break;
(2773) 			}
(2774) 			while (n) path[--i] = tp[--n];
(2775) 			path[--i] = '/';
(2776) 		}
(2777) 		tp = path;
(2778) 		if (res == FR_OK) {
(2779) 			*tp++ = '0' + CurrVol;			/* Put drive number */
(2780) 			*tp++ = ':';
(2781) 			if (i == sz_path) {				/* Root-dir */
(2782) 				*tp++ = '/';
(2783) 			} else {						/* Sub-dir */
(2784) 				do		/* Add stacked path str */
(2785) 					*tp++ = path[i++];
(2786) 				while (i < sz_path);
(2787) 			}
(2788) 		}
(2789) 		*tp = 0;
(2790) 		FREE_BUF();
(2791) 	}
(2792) 
(2793) 	LEAVE_FF(dj.fs, res);
(2794) }
(2795) #endif /* _FS_RPATH >= 2 */
(2796) #endif /* _FS_RPATH >= 1 */
(2797) 
(2798) 
(2799) 
(2800) #if _FS_MINIMIZE <= 2
(2801) /*-----------------------------------------------------------------------*/
(2802) /* Seek File R/W Pointer                                                 */
(2803) /*-----------------------------------------------------------------------*/
(2804) 
(2805) FRESULT f_lseek (
(2806) 	FIL *fp,		/* Pointer to the file object */
(2807) 	DWORD ofs		/* File pointer from top of file */
(2808) )
(2809) {
(2810) 	FRESULT res;
(2811) 
(2812) 
(2813) 	res = validate(fp->fs, fp->id);		/* Check validity of the object */
    01CBF A5E8      LDD	R30,Y+40
    01CC0 A5F9      LDD	R31,Y+41
    01CC1 8122      LDD	R18,Z+2
    01CC2 8133      LDD	R19,Z+3
    01CC3 8100      LD	R16,Z
    01CC4 8111      LDD	R17,Z+1
    01CC5 940E 1491 CALL	ff.c:validate
    01CC7 2EA0      MOV	R10,R16
(2814) 	if (res != FR_OK) LEAVE_FF(fp->fs, res);
    01CC8 2300      TST	R16
    01CC9 F009      BEQ	0x1CCB
    01CCA C4A7      RJMP	0x2172
(2815) 	if (fp->flag & FA__ERROR)			/* Check abort flag */
    01CCB A5E8      LDD	R30,Y+40
    01CCC A5F9      LDD	R31,Y+41
    01CCD 8024      LDD	R2,Z+4
    01CCE FE27      SBRS	R2,7
    01CCF C002      RJMP	0x1CD2
(2816) 		LEAVE_FF(fp->fs, FR_INT_ERR);
    01CD0 E002      LDI	R16,2
    01CD1 C4A0      RJMP	0x2172
(2817) 
(2818) #if _USE_FASTSEEK
(2819) 	if (fp->cltbl) {	/* Fast seek */
    01CD2 A5E8      LDD	R30,Y+40
    01CD3 A5F9      LDD	R31,Y+41
    01CD4 96B0      ADIW	R30,0x20
    01CD5 8020      LD	R2,Z
    01CD6 8031      LDD	R3,Z+1
    01CD7 2022      TST	R2
    01CD8 F419      BNE	0x1CDC
    01CD9 2033      TST	R3
    01CDA F409      BNE	0x1CDC
    01CDB C1E3      RJMP	0x1EBF
(2820) 		DWORD cl, pcl, ncl, tcl, dsc, tlen, ulen, *tbl;
(2821) 
(2822) 		if (ofs == CREATE_LINKMAP) {	/* Create CLMT */
    01CDC EF4F      LDI	R20,0xFF
    01CDD EF5F      LDI	R21,0xFF
    01CDE EF6F      LDI	R22,0xFF
    01CDF EF7F      LDI	R23,0xFF
    01CE0 A42A      LDD	R2,Y+42
    01CE1 A43B      LDD	R3,Y+43
    01CE2 A44C      LDD	R4,Y+44
    01CE3 A45D      LDD	R5,Y+45
    01CE4 1624      CP	R2,R20
    01CE5 0635      CPC	R3,R21
    01CE6 0646      CPC	R4,R22
    01CE7 0657      CPC	R5,R23
    01CE8 F009      BEQ	0x1CEA
    01CE9 C109      RJMP	0x1DF3
(2823) 			tbl = fp->cltbl;
    01CEA A5E8      LDD	R30,Y+40
    01CEB A5F9      LDD	R31,Y+41
    01CEC A0E0      LDD	R14,Z+32
    01CED A0F1      LDD	R15,Z+33
(2824) 			tlen = *tbl++; ulen = 2;	/* Given table size and required table size */
    01CEE 01F7      MOVW	R30,R14
    01CEF 9021      LD	R2,Z+
    01CF0 9031      LD	R3,Z+
    01CF1 9041      LD	R4,Z+
    01CF2 9051      LD	R5,Z+
    01CF3 017F      MOVW	R14,R30
    01CF4 8A2E      STD	Y+22,R2
    01CF5 8A3F      STD	Y+23,R3
    01CF6 8E48      STD	Y+24,R4
    01CF7 8E59      STD	Y+25,R5
    01CF8 E082      LDI	R24,2
    01CF9 878E      STD	Y+14,R24
    01CFA E080      LDI	R24,0
    01CFB 878F      STD	Y+15,R24
    01CFC 8B88      STD	Y+16,R24
    01CFD 8B89      STD	Y+17,R24
(2825) 			cl = fp->sclust;			/* Top of the chain */
    01CFE A5E8      LDD	R30,Y+40
    01CFF A5F9      LDD	R31,Y+41
    01D00 963E      ADIW	R30,0xE
    01D01 8020      LD	R2,Z
    01D02 8031      LDD	R3,Z+1
    01D03 8042      LDD	R4,Z+2
    01D04 8053      LDD	R5,Z+3
    01D05 822A      STD	Y+2,R2
    01D06 823B      STD	Y+3,R3
    01D07 824C      STD	Y+4,R4
    01D08 825D      STD	Y+5,R5
(2826) 			if (cl) {
    01D09 802A      LDD	R2,Y+2
    01D0A 803B      LDD	R3,Y+3
    01D0B 804C      LDD	R4,Y+4
    01D0C 805D      LDD	R5,Y+5
    01D0D 9488      BCLR	0
    01D0E 2022      TST	R2
    01D0F 0432      CPC	R3,R2
    01D10 0442      CPC	R4,R2
    01D11 0452      CPC	R5,R2
    01D12 F409      BNE	0x1D14
    01D13 C0BB      RJMP	0x1DCF
(2827) 				do {
(2828) 					/* Get a fragment */
(2829) 					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
    01D14 802A      LDD	R2,Y+2
    01D15 803B      LDD	R3,Y+3
    01D16 804C      LDD	R4,Y+4
    01D17 805D      LDD	R5,Y+5
    01D18 8A2A      STD	Y+18,R2
    01D19 8A3B      STD	Y+19,R3
    01D1A 8A4C      STD	Y+20,R4
    01D1B 8A5D      STD	Y+21,R5
    01D1C E080      LDI	R24,0
    01D1D 878A      STD	Y+10,R24
    01D1E 878B      STD	Y+11,R24
    01D1F 878C      STD	Y+12,R24
    01D20 878D      STD	Y+13,R24
    01D21 E042      LDI	R20,2
    01D22 E050      LDI	R21,0
    01D23 E060      LDI	R22,0
    01D24 E070      LDI	R23,0
    01D25 842E      LDD	R2,Y+14
    01D26 843F      LDD	R3,Y+15
    01D27 8848      LDD	R4,Y+16
    01D28 8859      LDD	R5,Y+17
    01D29 0E24      ADD	R2,R20
    01D2A 1E35      ADC	R3,R21
    01D2B 1E46      ADC	R4,R22
    01D2C 1E57      ADC	R5,R23
    01D2D 862E      STD	Y+14,R2
    01D2E 863F      STD	Y+15,R3
    01D2F 8A48      STD	Y+16,R4
    01D30 8A59      STD	Y+17,R5
(2830) 					do {
(2831) 						pcl = cl; ncl++;
    01D31 802A      LDD	R2,Y+2
    01D32 803B      LDD	R3,Y+3
    01D33 804C      LDD	R4,Y+4
    01D34 805D      LDD	R5,Y+5
    01D35 822E      STD	Y+6,R2
    01D36 823F      STD	Y+7,R3
    01D37 8648      STD	Y+8,R4
    01D38 8659      STD	Y+9,R5
    01D39 E041      LDI	R20,1
    01D3A E050      LDI	R21,0
    01D3B E060      LDI	R22,0
    01D3C E070      LDI	R23,0
    01D3D 842A      LDD	R2,Y+10
    01D3E 843B      LDD	R3,Y+11
    01D3F 844C      LDD	R4,Y+12
    01D40 845D      LDD	R5,Y+13
    01D41 0E24      ADD	R2,R20
    01D42 1E35      ADC	R3,R21
    01D43 1E46      ADC	R4,R22
    01D44 1E57      ADC	R5,R23
    01D45 862A      STD	Y+10,R2
    01D46 863B      STD	Y+11,R3
    01D47 864C      STD	Y+12,R4
    01D48 865D      STD	Y+13,R5
(2832) 						cl = get_fat(fp->fs, cl);
    01D49 802A      LDD	R2,Y+2
    01D4A 803B      LDD	R3,Y+3
    01D4B 804C      LDD	R4,Y+4
    01D4C 805D      LDD	R5,Y+5
    01D4D 8248      ST	Y,R4
    01D4E 8259      STD	Y+1,R5
    01D4F 0191      MOVW	R18,R2
    01D50 A5E8      LDD	R30,Y+40
    01D51 A5F9      LDD	R31,Y+41
    01D52 8100      LD	R16,Z
    01D53 8111      LDD	R17,Z+1
    01D54 940E 0342 CALL	_get_fat
    01D56 830A      STD	Y+2,R16
    01D57 831B      STD	Y+3,R17
    01D58 832C      STD	Y+4,R18
    01D59 833D      STD	Y+5,R19
(2833) 						if (cl <= 1) ABORT(fp->fs, FR_INT_ERR);
    01D5A E041      LDI	R20,1
    01D5B E050      LDI	R21,0
    01D5C E060      LDI	R22,0
    01D5D E070      LDI	R23,0
    01D5E 802A      LDD	R2,Y+2
    01D5F 803B      LDD	R3,Y+3
    01D60 804C      LDD	R4,Y+4
    01D61 805D      LDD	R5,Y+5
    01D62 1542      CP	R20,R2
    01D63 0553      CPC	R21,R3
    01D64 0564      CPC	R22,R4
    01D65 0575      CPC	R23,R5
    01D66 F048      BCS	0x1D70
    01D67 A588      LDD	R24,Y+40
    01D68 A599      LDD	R25,Y+41
    01D69 9604      ADIW	R24,4
    01D6A 01FC      MOVW	R30,R24
    01D6B 8180      LD	R24,Z
    01D6C 6880      ORI	R24,0x80
    01D6D 8380      ST	Z,R24
    01D6E E002      LDI	R16,2
    01D6F C402      RJMP	0x2172
(2834) 						if (cl == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    01D70 EF4F      LDI	R20,0xFF
    01D71 EF5F      LDI	R21,0xFF
    01D72 EF6F      LDI	R22,0xFF
    01D73 EF7F      LDI	R23,0xFF
    01D74 802A      LDD	R2,Y+2
    01D75 803B      LDD	R3,Y+3
    01D76 804C      LDD	R4,Y+4
    01D77 805D      LDD	R5,Y+5
    01D78 1624      CP	R2,R20
    01D79 0635      CPC	R3,R21
    01D7A 0646      CPC	R4,R22
    01D7B 0657      CPC	R5,R23
    01D7C F451      BNE	0x1D87
    01D7D A588      LDD	R24,Y+40
    01D7E A599      LDD	R25,Y+41
    01D7F 9604      ADIW	R24,4
    01D80 016C      MOVW	R12,R24
    01D81 01FC      MOVW	R30,R24
    01D82 8180      LD	R24,Z
    01D83 6880      ORI	R24,0x80
    01D84 8380      ST	Z,R24
    01D85 E001      LDI	R16,1
    01D86 C3EB      RJMP	0x2172
(2835) 					} while (cl == pcl + 1);
    01D87 E041      LDI	R20,1
    01D88 E050      LDI	R21,0
    01D89 E060      LDI	R22,0
    01D8A E070      LDI	R23,0
    01D8B 802E      LDD	R2,Y+6
    01D8C 803F      LDD	R3,Y+7
    01D8D 8448      LDD	R4,Y+8
    01D8E 8459      LDD	R5,Y+9
    01D8F 0E24      ADD	R2,R20
    01D90 1E35      ADC	R3,R21
    01D91 1E46      ADC	R4,R22
    01D92 1E57      ADC	R5,R23
    01D93 806A      LDD	R6,Y+2
    01D94 807B      LDD	R7,Y+3
    01D95 808C      LDD	R8,Y+4
    01D96 809D      LDD	R9,Y+5
    01D97 1462      CP	R6,R2
    01D98 0473      CPC	R7,R3
    01D99 0484      CPC	R8,R4
    01D9A 0495      CPC	R9,R5
    01D9B F409      BNE	0x1D9D
    01D9C CF94      RJMP	0x1D31
(2836) 					if (ulen <= tlen) {		/* Store the length and top of the fragment */
    01D9D 882E      LDD	R2,Y+22
    01D9E 883F      LDD	R3,Y+23
    01D9F 8C48      LDD	R4,Y+24
    01DA0 8C59      LDD	R5,Y+25
    01DA1 846E      LDD	R6,Y+14
    01DA2 847F      LDD	R7,Y+15
    01DA3 8888      LDD	R8,Y+16
    01DA4 8899      LDD	R9,Y+17
    01DA5 1426      CP	R2,R6
    01DA6 0437      CPC	R3,R7
    01DA7 0448      CPC	R4,R8
    01DA8 0459      CPC	R5,R9
    01DA9 F090      BCS	0x1DBC
(2837) 						*tbl++ = ncl; *tbl++ = tcl;
    01DAA 842A      LDD	R2,Y+10
    01DAB 843B      LDD	R3,Y+11
    01DAC 844C      LDD	R4,Y+12
    01DAD 845D      LDD	R5,Y+13
    01DAE 01F7      MOVW	R30,R14
    01DAF 9221      ST	Z+,R2
    01DB0 9231      ST	Z+,R3
    01DB1 9241      ST	Z+,R4
    01DB2 9251      ST	Z+,R5
    01DB3 882A      LDD	R2,Y+18
    01DB4 883B      LDD	R3,Y+19
    01DB5 884C      LDD	R4,Y+20
    01DB6 885D      LDD	R5,Y+21
    01DB7 9221      ST	Z+,R2
    01DB8 9231      ST	Z+,R3
    01DB9 9241      ST	Z+,R4
    01DBA 9251      ST	Z+,R5
    01DBB 017F      MOVW	R14,R30
(2838) 					}
(2839) 				} while (cl < fp->fs->n_fatent);	/* Repeat until end of chain */
    01DBC A5E8      LDD	R30,Y+40
    01DBD A5F9      LDD	R31,Y+41
    01DBE 81A0      LD	R26,Z
    01DBF 81B1      LDD	R27,Z+1
    01DC0 9656      ADIW	R26,0x16
    01DC1 902D      LD	R2,X+
    01DC2 903D      LD	R3,X+
    01DC3 904D      LD	R4,X+
    01DC4 905C      LD	R5,X
    01DC5 806A      LDD	R6,Y+2
    01DC6 807B      LDD	R7,Y+3
    01DC7 808C      LDD	R8,Y+4
    01DC8 809D      LDD	R9,Y+5
    01DC9 1462      CP	R6,R2
    01DCA 0473      CPC	R7,R3
    01DCB 0484      CPC	R8,R4
    01DCC 0495      CPC	R9,R5
    01DCD F408      BCC	0x1DCF
    01DCE CF45      RJMP	0x1D14
(2840) 			}
(2841) 			*fp->cltbl = ulen;	/* Number of items used */
    01DCF 842E      LDD	R2,Y+14
    01DD0 843F      LDD	R3,Y+15
    01DD1 8848      LDD	R4,Y+16
    01DD2 8859      LDD	R5,Y+17
    01DD3 A5E8      LDD	R30,Y+40
    01DD4 A5F9      LDD	R31,Y+41
    01DD5 96B0      ADIW	R30,0x20
    01DD6 81A0      LD	R26,Z
    01DD7 81B1      LDD	R27,Z+1
    01DD8 922D      ST	X+,R2
    01DD9 923D      ST	X+,R3
    01DDA 924D      ST	X+,R4
    01DDB 925C      ST	X,R5
(2842) 			if (ulen <= tlen)
    01DDC 882E      LDD	R2,Y+22
    01DDD 883F      LDD	R3,Y+23
    01DDE 8C48      LDD	R4,Y+24
    01DDF 8C59      LDD	R5,Y+25
    01DE0 846E      LDD	R6,Y+14
    01DE1 847F      LDD	R7,Y+15
    01DE2 8888      LDD	R8,Y+16
    01DE3 8899      LDD	R9,Y+17
    01DE4 1426      CP	R2,R6
    01DE5 0437      CPC	R3,R7
    01DE6 0448      CPC	R4,R8
    01DE7 0459      CPC	R5,R9
    01DE8 F038      BCS	0x1DF0
(2843) 				*tbl = 0;		/* Terminate table */
    01DE9 01F7      MOVW	R30,R14
    01DEA E080      LDI	R24,0
    01DEB 8380      ST	Z,R24
    01DEC 8381      STD	Z+1,R24
    01DED 8382      STD	Z+2,R24
    01DEE 8383      STD	Z+3,R24
    01DEF C381      RJMP	0x2171
(2844) 			else
(2845) 				res = FR_NOT_ENOUGH_CORE;	/* Given table size is smaller than required */
    01DF0 E181      LDI	R24,0x11
    01DF1 2EA8      MOV	R10,R24
(2846) 
(2847) 		} else {						/* Fast seek */
    01DF2 C37E      RJMP	0x2171
(2848) 			if (ofs > fp->fsize)		/* Clip offset at the file size */
    01DF3 A5E8      LDD	R30,Y+40
    01DF4 A5F9      LDD	R31,Y+41
    01DF5 963A      ADIW	R30,0xA
    01DF6 8020      LD	R2,Z
    01DF7 8031      LDD	R3,Z+1
    01DF8 8042      LDD	R4,Z+2
    01DF9 8053      LDD	R5,Z+3
    01DFA A46A      LDD	R6,Y+42
    01DFB A47B      LDD	R7,Y+43
    01DFC A48C      LDD	R8,Y+44
    01DFD A49D      LDD	R9,Y+45
    01DFE 1426      CP	R2,R6
    01DFF 0437      CPC	R3,R7
    01E00 0448      CPC	R4,R8
    01E01 0459      CPC	R5,R9
    01E02 F458      BCC	0x1E0E
(2849) 				ofs = fp->fsize;
    01E03 A5E8      LDD	R30,Y+40
    01E04 A5F9      LDD	R31,Y+41
    01E05 963A      ADIW	R30,0xA
    01E06 8020      LD	R2,Z
    01E07 8031      LDD	R3,Z+1
    01E08 8042      LDD	R4,Z+2
    01E09 8053      LDD	R5,Z+3
    01E0A A62A      STD	Y+42,R2
    01E0B A63B      STD	Y+43,R3
    01E0C A64C      STD	Y+44,R4
    01E0D A65D      STD	Y+45,R5
(2850) 			fp->fptr = ofs;				/* Set file pointer */
    01E0E A42A      LDD	R2,Y+42
    01E0F A43B      LDD	R3,Y+43
    01E10 A44C      LDD	R4,Y+44
    01E11 A45D      LDD	R5,Y+45
    01E12 A5E8      LDD	R30,Y+40
    01E13 A5F9      LDD	R31,Y+41
    01E14 9636      ADIW	R30,6
    01E15 8220      ST	Z,R2
    01E16 8231      STD	Z+1,R3
    01E17 8242      STD	Z+2,R4
    01E18 8253      STD	Z+3,R5
(2851) 			if (ofs) {
    01E19 9488      BCLR	0
    01E1A 2022      TST	R2
    01E1B 0432      CPC	R3,R2
    01E1C 0442      CPC	R4,R2
    01E1D 0452      CPC	R5,R2
    01E1E F409      BNE	0x1E20
    01E1F C351      RJMP	0x2171
(2852) 				fp->clust = clmt_clust(fp, ofs - 1);
    01E20 E041      LDI	R20,1
    01E21 E050      LDI	R21,0
    01E22 E060      LDI	R22,0
    01E23 E070      LDI	R23,0
    01E24 1A24      SUB	R2,R20
    01E25 0A35      SBC	R3,R21
    01E26 0A46      SBC	R4,R22
    01E27 0A57      SBC	R5,R23
    01E28 8248      ST	Y,R4
    01E29 8259      STD	Y+1,R5
    01E2A 0191      MOVW	R18,R2
    01E2B A508      LDD	R16,Y+40
    01E2C A519      LDD	R17,Y+41
    01E2D 940E 087C CALL	ff.c:clmt_clust
    01E2F A5E8      LDD	R30,Y+40
    01E30 A5F9      LDD	R31,Y+41
    01E31 8B02      STD	Z+18,R16
    01E32 8B13      STD	Z+19,R17
    01E33 8B24      STD	Z+20,R18
    01E34 8B35      STD	Z+21,R19
(2853) 				dsc = clust2sect(fp->fs, fp->clust);
    01E35 8822      LDD	R2,Z+18
    01E36 8833      LDD	R3,Z+19
    01E37 8844      LDD	R4,Z+20
    01E38 8855      LDD	R5,Z+21
    01E39 8248      ST	Y,R4
    01E3A 8259      STD	Y+1,R5
    01E3B 0191      MOVW	R18,R2
    01E3C 8100      LD	R16,Z
    01E3D 8111      LDD	R17,Z+1
    01E3E 940E 02F0 CALL	_clust2sect
    01E40 8F0A      STD	Y+26,R16
    01E41 8F1B      STD	Y+27,R17
    01E42 8F2C      STD	Y+28,R18
    01E43 8F3D      STD	Y+29,R19
(2854) 				if (!dsc) ABORT(fp->fs, FR_INT_ERR);
    01E44 8C2A      LDD	R2,Y+26
    01E45 8C3B      LDD	R3,Y+27
    01E46 8C4C      LDD	R4,Y+28
    01E47 8C5D      LDD	R5,Y+29
    01E48 9488      BCLR	0
    01E49 2022      TST	R2
    01E4A 0432      CPC	R3,R2
    01E4B 0442      CPC	R4,R2
    01E4C 0452      CPC	R5,R2
    01E4D F451      BNE	0x1E58
    01E4E A588      LDD	R24,Y+40
    01E4F A599      LDD	R25,Y+41
    01E50 9604      ADIW	R24,4
    01E51 017C      MOVW	R14,R24
    01E52 01FC      MOVW	R30,R24
    01E53 8180      LD	R24,Z
    01E54 6880      ORI	R24,0x80
    01E55 8380      ST	Z,R24
    01E56 E002      LDI	R16,2
    01E57 C31A      RJMP	0x2172
(2855) 				dsc += (ofs - 1) / SS(fp->fs) & (fp->fs->csize - 1);
    01E58 E041      LDI	R20,1
    01E59 E050      LDI	R21,0
    01E5A E060      LDI	R22,0
    01E5B E070      LDI	R23,0
    01E5C A50A      LDD	R16,Y+42
    01E5D A51B      LDD	R17,Y+43
    01E5E A52C      LDD	R18,Y+44
    01E5F A53D      LDD	R19,Y+45
    01E60 1B04      SUB	R16,R20
    01E61 0B15      SBC	R17,R21
    01E62 0B26      SBC	R18,R22
    01E63 0B37      SBC	R19,R23
    01E64 E089      LDI	R24,0x9
    01E65 E090      LDI	R25,0
    01E66 938A      ST	-Y,R24
    01E67 940E 280A CALL	lsr32
    01E69 0118      MOVW	R2,R16
    01E6A 0129      MOVW	R4,R18
    01E6B A5E8      LDD	R30,Y+40
    01E6C A5F9      LDD	R31,Y+41
    01E6D 93AF      PUSH	R26
    01E6E 93BF      PUSH	R27
    01E6F 81A0      LD	R26,Z
    01E70 81B1      LDD	R27,Z+1
    01E71 01FD      MOVW	R30,R26
    01E72 91BF      POP	R27
    01E73 91AF      POP	R26
    01E74 9632      ADIW	R30,2
    01E75 8180      LD	R24,Z
    01E76 2799      CLR	R25
    01E77 9701      SBIW	R24,1
    01E78 013C      MOVW	R6,R24
    01E79 2488      CLR	R8
    01E7A FC77      SBRC	R7,7
    01E7B 9480      COM	R8
    01E7C 2499      CLR	R9
    01E7D FC87      SBRC	R8,7
    01E7E 9490      COM	R9
    01E7F 2026      AND	R2,R6
    01E80 2037      AND	R3,R7
    01E81 2048      AND	R4,R8
    01E82 2059      AND	R5,R9
    01E83 8C6A      LDD	R6,Y+26
    01E84 8C7B      LDD	R7,Y+27
    01E85 8C8C      LDD	R8,Y+28
    01E86 8C9D      LDD	R9,Y+29
    01E87 0C62      ADD	R6,R2
    01E88 1C73      ADC	R7,R3
    01E89 1C84      ADC	R8,R4
    01E8A 1C95      ADC	R9,R5
    01E8B 8E6A      STD	Y+26,R6
    01E8C 8E7B      STD	Y+27,R7
    01E8D 8E8C      STD	Y+28,R8
    01E8E 8E9D      STD	Y+29,R9
(2856) 				if (fp->fptr % SS(fp->fs) && dsc != fp->dsect) {	/* Refill sector cache if needed */
    01E8F EF4F      LDI	R20,0xFF
    01E90 E051      LDI	R21,1
    01E91 E060      LDI	R22,0
    01E92 E070      LDI	R23,0
    01E93 A5E8      LDD	R30,Y+40
    01E94 A5F9      LDD	R31,Y+41
    01E95 9636      ADIW	R30,6
    01E96 8020      LD	R2,Z
    01E97 8031      LDD	R3,Z+1
    01E98 8042      LDD	R4,Z+2
    01E99 8053      LDD	R5,Z+3
    01E9A 2224      AND	R2,R20
    01E9B 2235      AND	R3,R21
    01E9C 2246      AND	R4,R22
    01E9D 2257      AND	R5,R23
    01E9E 9488      BCLR	0
    01E9F 2022      TST	R2
    01EA0 0432      CPC	R3,R2
    01EA1 0442      CPC	R4,R2
    01EA2 0452      CPC	R5,R2
    01EA3 F409      BNE	0x1EA5
    01EA4 C2CC      RJMP	0x2171
    01EA5 A5E8      LDD	R30,Y+40
    01EA6 A5F9      LDD	R31,Y+41
    01EA7 9676      ADIW	R30,0x16
    01EA8 8020      LD	R2,Z
    01EA9 8031      LDD	R3,Z+1
    01EAA 8042      LDD	R4,Z+2
    01EAB 8053      LDD	R5,Z+3
    01EAC 8C6A      LDD	R6,Y+26
    01EAD 8C7B      LDD	R7,Y+27
    01EAE 8C8C      LDD	R8,Y+28
    01EAF 8C9D      LDD	R9,Y+29
    01EB0 1462      CP	R6,R2
    01EB1 0473      CPC	R7,R3
    01EB2 0484      CPC	R8,R4
    01EB3 0495      CPC	R9,R5
    01EB4 F409      BNE	0x1EB6
    01EB5 C2BB      RJMP	0x2171
(2857) #if !_FS_TINY
(2858) #if !_FS_READONLY
(2859) 					if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
(2860) 						if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
(2861) 							ABORT(fp->fs, FR_DISK_ERR);
(2862) 						fp->flag &= ~FA__DIRTY;
(2863) 					}
(2864) #endif
(2865) 					if (disk_read(fp->fs->drv, fp->buf, dsc, 1) != RES_OK)	/* Load current sector */
(2866) 						ABORT(fp->fs, FR_DISK_ERR);
(2867) #endif
(2868) 					fp->dsect = dsc;
    01EB6 0113      MOVW	R2,R6
    01EB7 0124      MOVW	R4,R8
    01EB8 A5E8      LDD	R30,Y+40
    01EB9 A5F9      LDD	R31,Y+41
    01EBA 8A26      STD	Z+22,R2
    01EBB 8A37      STD	Z+23,R3
    01EBC 8E40      STD	Z+24,R4
    01EBD 8E51      STD	Z+25,R5
(2869) 				}
(2870) 			}
(2871) 		}
(2872) 	} else
    01EBE C2B2      RJMP	0x2171
(2873) #endif
(2874) 
(2875) 	/* Normal Seek */
(2876) 	{
(2877) 		DWORD clst, bcs, nsect, ifptr;
(2878) 
(2879) 		if (ofs > fp->fsize					/* In read-only mode, clip offset with the file size */
    01EBF A5E8      LDD	R30,Y+40
    01EC0 A5F9      LDD	R31,Y+41
    01EC1 963A      ADIW	R30,0xA
    01EC2 8020      LD	R2,Z
    01EC3 8031      LDD	R3,Z+1
    01EC4 8042      LDD	R4,Z+2
    01EC5 8053      LDD	R5,Z+3
    01EC6 A46A      LDD	R6,Y+42
    01EC7 A47B      LDD	R7,Y+43
    01EC8 A48C      LDD	R8,Y+44
    01EC9 A49D      LDD	R9,Y+45
    01ECA 1426      CP	R2,R6
    01ECB 0437      CPC	R3,R7
    01ECC 0448      CPC	R4,R8
    01ECD 0459      CPC	R5,R9
    01ECE F470      BCC	0x1EDD
    01ECF A5E8      LDD	R30,Y+40
    01ED0 A5F9      LDD	R31,Y+41
    01ED1 8024      LDD	R2,Z+4
    01ED2 FC21      SBRC	R2,1
    01ED3 C009      RJMP	0x1EDD
(2880) #if !_FS_READONLY
(2881) 			 && !(fp->flag & FA_WRITE)
(2882) #endif
(2883) 			) ofs = fp->fsize;
    01ED4 963A      ADIW	R30,0xA
    01ED5 8020      LD	R2,Z
    01ED6 8031      LDD	R3,Z+1
    01ED7 8042      LDD	R4,Z+2
    01ED8 8053      LDD	R5,Z+3
    01ED9 A62A      STD	Y+42,R2
    01EDA A63B      STD	Y+43,R3
    01EDB A64C      STD	Y+44,R4
    01EDC A65D      STD	Y+45,R5
(2884) 
(2885) 		ifptr = fp->fptr;
    01EDD A5E8      LDD	R30,Y+40
    01EDE A5F9      LDD	R31,Y+41
    01EDF 9636      ADIW	R30,6
    01EE0 8020      LD	R2,Z
    01EE1 8031      LDD	R3,Z+1
    01EE2 8042      LDD	R4,Z+2
    01EE3 8053      LDD	R5,Z+3
    01EE4 862E      STD	Y+14,R2
    01EE5 863F      STD	Y+15,R3
    01EE6 8A48      STD	Y+16,R4
    01EE7 8A59      STD	Y+17,R5
(2886) 		fp->fptr = nsect = 0;
    01EE8 E080      LDI	R24,0
    01EE9 878A      STD	Y+10,R24
    01EEA 878B      STD	Y+11,R24
    01EEB 878C      STD	Y+12,R24
    01EEC 878D      STD	Y+13,R24
    01EED A5E8      LDD	R30,Y+40
    01EEE A5F9      LDD	R31,Y+41
    01EEF 9636      ADIW	R30,6
    01EF0 E080      LDI	R24,0
    01EF1 8380      ST	Z,R24
    01EF2 8381      STD	Z+1,R24
    01EF3 8382      STD	Z+2,R24
    01EF4 8383      STD	Z+3,R24
(2887) 		if (ofs) {
    01EF5 A42A      LDD	R2,Y+42
    01EF6 A43B      LDD	R3,Y+43
    01EF7 A44C      LDD	R4,Y+44
    01EF8 A45D      LDD	R5,Y+45
    01EF9 9488      BCLR	0
    01EFA 2022      TST	R2
    01EFB 0432      CPC	R3,R2
    01EFC 0442      CPC	R4,R2
    01EFD 0452      CPC	R5,R2
    01EFE F409      BNE	0x1F00
    01EFF C226      RJMP	0x2126
(2888) 			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
    01F00 A5E8      LDD	R30,Y+40
    01F01 A5F9      LDD	R31,Y+41
    01F02 93AF      PUSH	R26
    01F03 93BF      PUSH	R27
    01F04 81A0      LD	R26,Z
    01F05 81B1      LDD	R27,Z+1
    01F06 01FD      MOVW	R30,R26
    01F07 91BF      POP	R27
    01F08 91AF      POP	R26
    01F09 9632      ADIW	R30,2
    01F0A 8020      LD	R2,Z
    01F0B 2433      CLR	R3
    01F0C 2444      CLR	R4
    01F0D 2455      CLR	R5
    01F0E E040      LDI	R20,0
    01F0F E052      LDI	R21,2
    01F10 E060      LDI	R22,0
    01F11 E070      LDI	R23,0
    01F12 925A      ST	-Y,R5
    01F13 924A      ST	-Y,R4
    01F14 923A      ST	-Y,R3
    01F15 922A      ST	-Y,R2
    01F16 018A      MOVW	R16,R20
    01F17 019B      MOVW	R18,R22
    01F18 940E 2728 CALL	empy32s|empy32u
    01F1A 830E      STD	Y+6,R16
    01F1B 831F      STD	Y+7,R17
    01F1C 8728      STD	Y+8,R18
    01F1D 8739      STD	Y+9,R19
(2889) 			if (ifptr > 0 &&
    01F1E 842E      LDD	R2,Y+14
    01F1F 843F      LDD	R3,Y+15
    01F20 8848      LDD	R4,Y+16
    01F21 8859      LDD	R5,Y+17
    01F22 9488      BCLR	0
    01F23 2022      TST	R2
    01F24 0432      CPC	R3,R2
    01F25 0442      CPC	R4,R2
    01F26 0452      CPC	R5,R2
    01F27 F409      BNE	0x1F29
    01F28 C075      RJMP	0x1F9E
    01F29 E041      LDI	R20,1
    01F2A E050      LDI	R21,0
    01F2B E060      LDI	R22,0
    01F2C E070      LDI	R23,0
    01F2D 0181      MOVW	R16,R2
    01F2E 0192      MOVW	R18,R4
    01F2F 1B04      SUB	R16,R20
    01F30 0B15      SBC	R17,R21
    01F31 0B26      SBC	R18,R22
    01F32 0B37      SBC	R19,R23
    01F33 802E      LDD	R2,Y+6
    01F34 803F      LDD	R3,Y+7
    01F35 8448      LDD	R4,Y+8
    01F36 8459      LDD	R5,Y+9
    01F37 925A      ST	-Y,R5
    01F38 924A      ST	-Y,R4
    01F39 923A      ST	-Y,R3
    01F3A 922A      ST	-Y,R2
    01F3B 940E 26AE CALL	div32u
    01F3D 0118      MOVW	R2,R16
    01F3E 0129      MOVW	R4,R18
    01F3F E041      LDI	R20,1
    01F40 E050      LDI	R21,0
    01F41 E060      LDI	R22,0
    01F42 E070      LDI	R23,0
    01F43 A50A      LDD	R16,Y+42
    01F44 A51B      LDD	R17,Y+43
    01F45 A52C      LDD	R18,Y+44
    01F46 A53D      LDD	R19,Y+45
    01F47 1B04      SUB	R16,R20
    01F48 0B15      SBC	R17,R21
    01F49 0B26      SBC	R18,R22
    01F4A 0B37      SBC	R19,R23
    01F4B 806E      LDD	R6,Y+6
    01F4C 807F      LDD	R7,Y+7
    01F4D 8488      LDD	R8,Y+8
    01F4E 8499      LDD	R9,Y+9
    01F4F 929A      ST	-Y,R9
    01F50 928A      ST	-Y,R8
    01F51 927A      ST	-Y,R7
    01F52 926A      ST	-Y,R6
    01F53 940E 26AE CALL	div32u
    01F55 1502      CP	R16,R2
    01F56 0513      CPC	R17,R3
    01F57 0524      CPC	R18,R4
    01F58 0535      CPC	R19,R5
    01F59 F408      BCC	0x1F5B
    01F5A C043      RJMP	0x1F9E
(2890) 				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
(2891) 				fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
    01F5B E041      LDI	R20,1
    01F5C E050      LDI	R21,0
    01F5D E060      LDI	R22,0
    01F5E E070      LDI	R23,0
    01F5F 802E      LDD	R2,Y+6
    01F60 803F      LDD	R3,Y+7
    01F61 8448      LDD	R4,Y+8
    01F62 8459      LDD	R5,Y+9
    01F63 1A24      SUB	R2,R20
    01F64 0A35      SBC	R3,R21
    01F65 0A46      SBC	R4,R22
    01F66 0A57      SBC	R5,R23
    01F67 9420      COM	R2
    01F68 9430      COM	R3
    01F69 9440      COM	R4
    01F6A 9450      COM	R5
    01F6B E041      LDI	R20,1
    01F6C E050      LDI	R21,0
    01F6D E060      LDI	R22,0
    01F6E E070      LDI	R23,0
    01F6F 846E      LDD	R6,Y+14
    01F70 847F      LDD	R7,Y+15
    01F71 8888      LDD	R8,Y+16
    01F72 8899      LDD	R9,Y+17
    01F73 1A64      SUB	R6,R20
    01F74 0A75      SBC	R7,R21
    01F75 0A86      SBC	R8,R22
    01F76 0A97      SBC	R9,R23
    01F77 2062      AND	R6,R2
    01F78 2073      AND	R7,R3
    01F79 2084      AND	R8,R4
    01F7A 2095      AND	R9,R5
    01F7B A5E8      LDD	R30,Y+40
    01F7C A5F9      LDD	R31,Y+41
    01F7D 8266      STD	Z+6,R6
    01F7E 8277      STD	Z+7,R7
    01F7F 8680      STD	Z+8,R8
    01F80 8691      STD	Z+9,R9
(2892) 				ofs -= fp->fptr;
    01F81 9636      ADIW	R30,6
    01F82 8020      LD	R2,Z
    01F83 8031      LDD	R3,Z+1
    01F84 8042      LDD	R4,Z+2
    01F85 8053      LDD	R5,Z+3
    01F86 A46A      LDD	R6,Y+42
    01F87 A47B      LDD	R7,Y+43
    01F88 A48C      LDD	R8,Y+44
    01F89 A49D      LDD	R9,Y+45
    01F8A 1862      SUB	R6,R2
    01F8B 0873      SBC	R7,R3
    01F8C 0884      SBC	R8,R4
    01F8D 0895      SBC	R9,R5
    01F8E A66A      STD	Y+42,R6
    01F8F A67B      STD	Y+43,R7
    01F90 A68C      STD	Y+44,R8
    01F91 A69D      STD	Y+45,R9
(2893) 				clst = fp->clust;
    01F92 A5E8      LDD	R30,Y+40
    01F93 A5F9      LDD	R31,Y+41
    01F94 9672      ADIW	R30,0x12
    01F95 8020      LD	R2,Z
    01F96 8031      LDD	R3,Z+1
    01F97 8042      LDD	R4,Z+2
    01F98 8053      LDD	R5,Z+3
    01F99 822A      STD	Y+2,R2
    01F9A 823B      STD	Y+3,R3
    01F9B 824C      STD	Y+4,R4
    01F9C 825D      STD	Y+5,R5
(2894) 			} else {									/* When seek to back cluster, */
    01F9D C069      RJMP	0x2007
(2895) 				clst = fp->sclust;						/* start from the first cluster */
    01F9E A5E8      LDD	R30,Y+40
    01F9F A5F9      LDD	R31,Y+41
    01FA0 963E      ADIW	R30,0xE
    01FA1 8020      LD	R2,Z
    01FA2 8031      LDD	R3,Z+1
    01FA3 8042      LDD	R4,Z+2
    01FA4 8053      LDD	R5,Z+3
    01FA5 822A      STD	Y+2,R2
    01FA6 823B      STD	Y+3,R3
    01FA7 824C      STD	Y+4,R4
    01FA8 825D      STD	Y+5,R5
(2896) #if !_FS_READONLY
(2897) 				if (clst == 0) {						/* If no cluster chain, create a new chain */
    01FA9 802A      LDD	R2,Y+2
    01FAA 803B      LDD	R3,Y+3
    01FAB 804C      LDD	R4,Y+4
    01FAC 805D      LDD	R5,Y+5
    01FAD 9488      BCLR	0
    01FAE 2022      TST	R2
    01FAF 0432      CPC	R3,R2
    01FB0 0442      CPC	R4,R2
    01FB1 0452      CPC	R5,R2
    01FB2 F009      BEQ	0x1FB4
    01FB3 C049      RJMP	0x1FFD
(2898) 					clst = create_chain(fp->fs, 0);
    01FB4 E040      LDI	R20,0
    01FB5 E050      LDI	R21,0
    01FB6 E060      LDI	R22,0
    01FB7 E070      LDI	R23,0
    01FB8 8368      ST	Y,R22
    01FB9 8379      STD	Y+1,R23
    01FBA 019A      MOVW	R18,R20
    01FBB A5E8      LDD	R30,Y+40
    01FBC A5F9      LDD	R31,Y+41
    01FBD 8100      LD	R16,Z
    01FBE 8111      LDD	R17,Z+1
    01FBF 940E 0704 CALL	ff.c:create_chain
    01FC1 830A      STD	Y+2,R16
    01FC2 831B      STD	Y+3,R17
    01FC3 832C      STD	Y+4,R18
    01FC4 833D      STD	Y+5,R19
(2899) 					if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
    01FC5 E041      LDI	R20,1
    01FC6 E050      LDI	R21,0
    01FC7 E060      LDI	R22,0
    01FC8 E070      LDI	R23,0
    01FC9 802A      LDD	R2,Y+2
    01FCA 803B      LDD	R3,Y+3
    01FCB 804C      LDD	R4,Y+4
    01FCC 805D      LDD	R5,Y+5
    01FCD 1624      CP	R2,R20
    01FCE 0635      CPC	R3,R21
    01FCF 0646      CPC	R4,R22
    01FD0 0657      CPC	R5,R23
    01FD1 F451      BNE	0x1FDC
    01FD2 A588      LDD	R24,Y+40
    01FD3 A599      LDD	R25,Y+41
    01FD4 9604      ADIW	R24,4
    01FD5 017C      MOVW	R14,R24
    01FD6 01FC      MOVW	R30,R24
    01FD7 8180      LD	R24,Z
    01FD8 6880      ORI	R24,0x80
    01FD9 8380      ST	Z,R24
    01FDA E002      LDI	R16,2
    01FDB C196      RJMP	0x2172
(2900) 					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    01FDC EF4F      LDI	R20,0xFF
    01FDD EF5F      LDI	R21,0xFF
    01FDE EF6F      LDI	R22,0xFF
    01FDF EF7F      LDI	R23,0xFF
    01FE0 802A      LDD	R2,Y+2
    01FE1 803B      LDD	R3,Y+3
    01FE2 804C      LDD	R4,Y+4
    01FE3 805D      LDD	R5,Y+5
    01FE4 1624      CP	R2,R20
    01FE5 0635      CPC	R3,R21
    01FE6 0646      CPC	R4,R22
    01FE7 0657      CPC	R5,R23
    01FE8 F451      BNE	0x1FF3
    01FE9 A588      LDD	R24,Y+40
    01FEA A599      LDD	R25,Y+41
    01FEB 9604      ADIW	R24,4
    01FEC 017C      MOVW	R14,R24
    01FED 01FC      MOVW	R30,R24
    01FEE 8180      LD	R24,Z
    01FEF 6880      ORI	R24,0x80
    01FF0 8380      ST	Z,R24
    01FF1 E001      LDI	R16,1
    01FF2 C17F      RJMP	0x2172
(2901) 					fp->sclust = clst;
    01FF3 802A      LDD	R2,Y+2
    01FF4 803B      LDD	R3,Y+3
    01FF5 804C      LDD	R4,Y+4
    01FF6 805D      LDD	R5,Y+5
    01FF7 A5E8      LDD	R30,Y+40
    01FF8 A5F9      LDD	R31,Y+41
    01FF9 8626      STD	Z+14,R2
    01FFA 8637      STD	Z+15,R3
    01FFB 8A40      STD	Z+16,R4
    01FFC 8A51      STD	Z+17,R5
(2902) 				}
(2903) #endif
(2904) 				fp->clust = clst;
    01FFD 802A      LDD	R2,Y+2
    01FFE 803B      LDD	R3,Y+3
    01FFF 804C      LDD	R4,Y+4
    02000 805D      LDD	R5,Y+5
    02001 A5E8      LDD	R30,Y+40
    02002 A5F9      LDD	R31,Y+41
    02003 8A22      STD	Z+18,R2
    02004 8A33      STD	Z+19,R3
    02005 8A44      STD	Z+20,R4
    02006 8A55      STD	Z+21,R5
(2905) 			}
(2906) 			if (clst != 0) {
    02007 802A      LDD	R2,Y+2
    02008 803B      LDD	R3,Y+3
    02009 804C      LDD	R4,Y+4
    0200A 805D      LDD	R5,Y+5
    0200B 9488      BCLR	0
    0200C 2022      TST	R2
    0200D 0432      CPC	R3,R2
    0200E 0442      CPC	R4,R2
    0200F 0452      CPC	R5,R2
    02010 F409      BNE	0x2012
    02011 C114      RJMP	0x2126
    02012 C0A7      RJMP	0x20BA
(2907) 				while (ofs > bcs) {						/* Cluster following loop */
(2908) #if !_FS_READONLY
(2909) 					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
    02013 A5E8      LDD	R30,Y+40
    02014 A5F9      LDD	R31,Y+41
    02015 9634      ADIW	R30,4
    02016 8020      LD	R2,Z
    02017 FE21      SBRS	R2,1
    02018 C024      RJMP	0x203D
(2910) 						clst = create_chain(fp->fs, clst);	/* Force stretch if in write mode */
    02019 802A      LDD	R2,Y+2
    0201A 803B      LDD	R3,Y+3
    0201B 804C      LDD	R4,Y+4
    0201C 805D      LDD	R5,Y+5
    0201D 8248      ST	Y,R4
    0201E 8259      STD	Y+1,R5
    0201F 0191      MOVW	R18,R2
    02020 A5E8      LDD	R30,Y+40
    02021 A5F9      LDD	R31,Y+41
    02022 8100      LD	R16,Z
    02023 8111      LDD	R17,Z+1
    02024 940E 0704 CALL	ff.c:create_chain
    02026 830A      STD	Y+2,R16
    02027 831B      STD	Y+3,R17
    02028 832C      STD	Y+4,R18
    02029 833D      STD	Y+5,R19
(2911) 						if (clst == 0) {				/* When disk gets full, clip file size */
    0202A 802A      LDD	R2,Y+2
    0202B 803B      LDD	R3,Y+3
    0202C 804C      LDD	R4,Y+4
    0202D 805D      LDD	R5,Y+5
    0202E 9488      BCLR	0
    0202F 2022      TST	R2
    02030 0432      CPC	R3,R2
    02031 0442      CPC	R4,R2
    02032 0452      CPC	R5,R2
    02033 F4D1      BNE	0x204E
(2912) 							ofs = bcs; break;
    02034 802E      LDD	R2,Y+6
    02035 803F      LDD	R3,Y+7
    02036 8448      LDD	R4,Y+8
    02037 8459      LDD	R5,Y+9
    02038 A62A      STD	Y+42,R2
    02039 A63B      STD	Y+43,R3
    0203A A64C      STD	Y+44,R4
    0203B A65D      STD	Y+45,R5
    0203C C08B      RJMP	0x20C8
(2913) 						}
(2914) 					} else
(2915) #endif
(2916) 						clst = get_fat(fp->fs, clst);	/* Follow cluster chain if not in write mode */
    0203D 802A      LDD	R2,Y+2
    0203E 803B      LDD	R3,Y+3
    0203F 804C      LDD	R4,Y+4
    02040 805D      LDD	R5,Y+5
    02041 8248      ST	Y,R4
    02042 8259      STD	Y+1,R5
    02043 0191      MOVW	R18,R2
    02044 A5E8      LDD	R30,Y+40
    02045 A5F9      LDD	R31,Y+41
    02046 8100      LD	R16,Z
    02047 8111      LDD	R17,Z+1
    02048 940E 0342 CALL	_get_fat
    0204A 830A      STD	Y+2,R16
    0204B 831B      STD	Y+3,R17
    0204C 832C      STD	Y+4,R18
    0204D 833D      STD	Y+5,R19
(2917) 					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    0204E EF4F      LDI	R20,0xFF
    0204F EF5F      LDI	R21,0xFF
    02050 EF6F      LDI	R22,0xFF
    02051 EF7F      LDI	R23,0xFF
    02052 802A      LDD	R2,Y+2
    02053 803B      LDD	R3,Y+3
    02054 804C      LDD	R4,Y+4
    02055 805D      LDD	R5,Y+5
    02056 1624      CP	R2,R20
    02057 0635      CPC	R3,R21
    02058 0646      CPC	R4,R22
    02059 0657      CPC	R5,R23
    0205A F451      BNE	0x2065
    0205B A588      LDD	R24,Y+40
    0205C A599      LDD	R25,Y+41
    0205D 9604      ADIW	R24,4
    0205E 017C      MOVW	R14,R24
    0205F 01FC      MOVW	R30,R24
    02060 8180      LD	R24,Z
    02061 6880      ORI	R24,0x80
    02062 8380      ST	Z,R24
    02063 E001      LDI	R16,1
    02064 C10D      RJMP	0x2172
(2918) 					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
    02065 E041      LDI	R20,1
    02066 E050      LDI	R21,0
    02067 E060      LDI	R22,0
    02068 E070      LDI	R23,0
    02069 802A      LDD	R2,Y+2
    0206A 803B      LDD	R3,Y+3
    0206B 804C      LDD	R4,Y+4
    0206C 805D      LDD	R5,Y+5
    0206D 1542      CP	R20,R2
    0206E 0553      CPC	R21,R3
    0206F 0564      CPC	R22,R4
    02070 0575      CPC	R23,R5
    02071 F490      BCC	0x2084
    02072 A5E8      LDD	R30,Y+40
    02073 A5F9      LDD	R31,Y+41
    02074 81A0      LD	R26,Z
    02075 81B1      LDD	R27,Z+1
    02076 9656      ADIW	R26,0x16
    02077 902D      LD	R2,X+
    02078 903D      LD	R3,X+
    02079 904D      LD	R4,X+
    0207A 905C      LD	R5,X
    0207B 806A      LDD	R6,Y+2
    0207C 807B      LDD	R7,Y+3
    0207D 808C      LDD	R8,Y+4
    0207E 809D      LDD	R9,Y+5
    0207F 1462      CP	R6,R2
    02080 0473      CPC	R7,R3
    02081 0484      CPC	R8,R4
    02082 0495      CPC	R9,R5
    02083 F050      BCS	0x208E
    02084 A588      LDD	R24,Y+40
    02085 A599      LDD	R25,Y+41
    02086 9604      ADIW	R24,4
    02087 017C      MOVW	R14,R24
    02088 01FC      MOVW	R30,R24
    02089 8180      LD	R24,Z
    0208A 6880      ORI	R24,0x80
    0208B 8380      ST	Z,R24
    0208C E002      LDI	R16,2
    0208D C0E4      RJMP	0x2172
(2919) 					fp->clust = clst;
    0208E 802A      LDD	R2,Y+2
    0208F 803B      LDD	R3,Y+3
    02090 804C      LDD	R4,Y+4
    02091 805D      LDD	R5,Y+5
    02092 A5E8      LDD	R30,Y+40
    02093 A5F9      LDD	R31,Y+41
    02094 9672      ADIW	R30,0x12
    02095 8220      ST	Z,R2
    02096 8231      STD	Z+1,R3
    02097 8242      STD	Z+2,R4
    02098 8253      STD	Z+3,R5
(2920) 					fp->fptr += bcs;
    02099 A588      LDD	R24,Y+40
    0209A A599      LDD	R25,Y+41
    0209B 9606      ADIW	R24,6
    0209C 017C      MOVW	R14,R24
    0209D 802E      LDD	R2,Y+6
    0209E 803F      LDD	R3,Y+7
    0209F 8448      LDD	R4,Y+8
    020A0 8459      LDD	R5,Y+9
    020A1 01FC      MOVW	R30,R24
    020A2 8060      LD	R6,Z
    020A3 8071      LDD	R7,Z+1
    020A4 8082      LDD	R8,Z+2
    020A5 8093      LDD	R9,Z+3
    020A6 0C62      ADD	R6,R2
    020A7 1C73      ADC	R7,R3
    020A8 1C84      ADC	R8,R4
    020A9 1C95      ADC	R9,R5
    020AA 8260      ST	Z,R6
    020AB 8271      STD	Z+1,R7
    020AC 8282      STD	Z+2,R8
    020AD 8293      STD	Z+3,R9
(2921) 					ofs -= bcs;
    020AE A46A      LDD	R6,Y+42
    020AF A47B      LDD	R7,Y+43
    020B0 A48C      LDD	R8,Y+44
    020B1 A49D      LDD	R9,Y+45
    020B2 1862      SUB	R6,R2
    020B3 0873      SBC	R7,R3
    020B4 0884      SBC	R8,R4
    020B5 0895      SBC	R9,R5
    020B6 A66A      STD	Y+42,R6
    020B7 A67B      STD	Y+43,R7
    020B8 A68C      STD	Y+44,R8
    020B9 A69D      STD	Y+45,R9
    020BA 802E      LDD	R2,Y+6
    020BB 803F      LDD	R3,Y+7
    020BC 8448      LDD	R4,Y+8
    020BD 8459      LDD	R5,Y+9
    020BE A46A      LDD	R6,Y+42
    020BF A47B      LDD	R7,Y+43
    020C0 A48C      LDD	R8,Y+44
    020C1 A49D      LDD	R9,Y+45
    020C2 1426      CP	R2,R6
    020C3 0437      CPC	R3,R7
    020C4 0448      CPC	R4,R8
    020C5 0459      CPC	R5,R9
    020C6 F408      BCC	0x20C8
    020C7 CF4B      RJMP	0x2013
(2922) 				}
(2923) 				fp->fptr += ofs;
    020C8 A588      LDD	R24,Y+40
    020C9 A599      LDD	R25,Y+41
    020CA 9606      ADIW	R24,6
    020CB 017C      MOVW	R14,R24
    020CC A42A      LDD	R2,Y+42
    020CD A43B      LDD	R3,Y+43
    020CE A44C      LDD	R4,Y+44
    020CF A45D      LDD	R5,Y+45
    020D0 01FC      MOVW	R30,R24
    020D1 8060      LD	R6,Z
    020D2 8071      LDD	R7,Z+1
    020D3 8082      LDD	R8,Z+2
    020D4 8093      LDD	R9,Z+3
    020D5 0C62      ADD	R6,R2
    020D6 1C73      ADC	R7,R3
    020D7 1C84      ADC	R8,R4
    020D8 1C95      ADC	R9,R5
    020D9 8260      ST	Z,R6
    020DA 8271      STD	Z+1,R7
    020DB 8282      STD	Z+2,R8
    020DC 8293      STD	Z+3,R9
(2924) 				if (ofs % SS(fp->fs)) {
    020DD EF4F      LDI	R20,0xFF
    020DE E051      LDI	R21,1
    020DF E060      LDI	R22,0
    020E0 E070      LDI	R23,0
    020E1 2224      AND	R2,R20
    020E2 2235      AND	R3,R21
    020E3 2246      AND	R4,R22
    020E4 2257      AND	R5,R23
    020E5 9488      BCLR	0
    020E6 2022      TST	R2
    020E7 0432      CPC	R3,R2
    020E8 0442      CPC	R4,R2
    020E9 0452      CPC	R5,R2
    020EA F409      BNE	0x20EC
    020EB C03A      RJMP	0x2126
(2925) 					nsect = clust2sect(fp->fs, clst);	/* Current sector */
    020EC 802A      LDD	R2,Y+2
    020ED 803B      LDD	R3,Y+3
    020EE 804C      LDD	R4,Y+4
    020EF 805D      LDD	R5,Y+5
    020F0 8248      ST	Y,R4
    020F1 8259      STD	Y+1,R5
    020F2 0191      MOVW	R18,R2
    020F3 A5E8      LDD	R30,Y+40
    020F4 A5F9      LDD	R31,Y+41
    020F5 8100      LD	R16,Z
    020F6 8111      LDD	R17,Z+1
    020F7 940E 02F0 CALL	_clust2sect
    020F9 870A      STD	Y+10,R16
    020FA 871B      STD	Y+11,R17
    020FB 872C      STD	Y+12,R18
    020FC 873D      STD	Y+13,R19
(2926) 					if (!nsect) ABORT(fp->fs, FR_INT_ERR);
    020FD 842A      LDD	R2,Y+10
    020FE 843B      LDD	R3,Y+11
    020FF 844C      LDD	R4,Y+12
    02100 845D      LDD	R5,Y+13
    02101 9488      BCLR	0
    02102 2022      TST	R2
    02103 0432      CPC	R3,R2
    02104 0442      CPC	R4,R2
    02105 0452      CPC	R5,R2
    02106 F451      BNE	0x2111
    02107 A588      LDD	R24,Y+40
    02108 A599      LDD	R25,Y+41
    02109 9604      ADIW	R24,4
    0210A 017C      MOVW	R14,R24
    0210B 01FC      MOVW	R30,R24
    0210C 8180      LD	R24,Z
    0210D 6880      ORI	R24,0x80
    0210E 8380      ST	Z,R24
    0210F E002      LDI	R16,2
    02110 C061      RJMP	0x2172
(2927) 					nsect += ofs / SS(fp->fs);
    02111 E089      LDI	R24,0x9
    02112 E090      LDI	R25,0
    02113 A50A      LDD	R16,Y+42
    02114 A51B      LDD	R17,Y+43
    02115 A52C      LDD	R18,Y+44
    02116 A53D      LDD	R19,Y+45
    02117 938A      ST	-Y,R24
    02118 940E 280A CALL	lsr32
    0211A 842A      LDD	R2,Y+10
    0211B 843B      LDD	R3,Y+11
    0211C 844C      LDD	R4,Y+12
    0211D 845D      LDD	R5,Y+13
    0211E 0E20      ADD	R2,R16
    0211F 1E31      ADC	R3,R17
    02120 1E42      ADC	R4,R18
    02121 1E53      ADC	R5,R19
    02122 862A      STD	Y+10,R2
    02123 863B      STD	Y+11,R3
    02124 864C      STD	Y+12,R4
    02125 865D      STD	Y+13,R5
(2928) 				}
(2929) 			}
(2930) 		}
(2931) 		if (fp->fptr % SS(fp->fs) && nsect != fp->dsect) {	/* Fill sector cache if needed */
    02126 EF4F      LDI	R20,0xFF
    02127 E051      LDI	R21,1
    02128 E060      LDI	R22,0
    02129 E070      LDI	R23,0
    0212A A5E8      LDD	R30,Y+40
    0212B A5F9      LDD	R31,Y+41
    0212C 9636      ADIW	R30,6
    0212D 8020      LD	R2,Z
    0212E 8031      LDD	R3,Z+1
    0212F 8042      LDD	R4,Z+2
    02130 8053      LDD	R5,Z+3
    02131 2224      AND	R2,R20
    02132 2235      AND	R3,R21
    02133 2246      AND	R4,R22
    02134 2257      AND	R5,R23
    02135 9488      BCLR	0
    02136 2022      TST	R2
    02137 0432      CPC	R3,R2
    02138 0442      CPC	R4,R2
    02139 0452      CPC	R5,R2
    0213A F0C1      BEQ	0x2153
    0213B A5E8      LDD	R30,Y+40
    0213C A5F9      LDD	R31,Y+41
    0213D 9676      ADIW	R30,0x16
    0213E 8020      LD	R2,Z
    0213F 8031      LDD	R3,Z+1
    02140 8042      LDD	R4,Z+2
    02141 8053      LDD	R5,Z+3
    02142 846A      LDD	R6,Y+10
    02143 847B      LDD	R7,Y+11
    02144 848C      LDD	R8,Y+12
    02145 849D      LDD	R9,Y+13
    02146 1462      CP	R6,R2
    02147 0473      CPC	R7,R3
    02148 0484      CPC	R8,R4
    02149 0495      CPC	R9,R5
    0214A F041      BEQ	0x2153
(2932) #if !_FS_TINY
(2933) #if !_FS_READONLY
(2934) 			if (fp->flag & FA__DIRTY) {			/* Write-back dirty sector cache */
(2935) 				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
(2936) 					ABORT(fp->fs, FR_DISK_ERR);
(2937) 				fp->flag &= ~FA__DIRTY;
(2938) 			}
(2939) #endif
(2940) 			if (disk_read(fp->fs->drv, fp->buf, nsect, 1) != RES_OK)	/* Fill sector cache */
(2941) 				ABORT(fp->fs, FR_DISK_ERR);
(2942) #endif
(2943) 			fp->dsect = nsect;
    0214B 0113      MOVW	R2,R6
    0214C 0124      MOVW	R4,R8
    0214D A5E8      LDD	R30,Y+40
    0214E A5F9      LDD	R31,Y+41
    0214F 8A26      STD	Z+22,R2
    02150 8A37      STD	Z+23,R3
    02151 8E40      STD	Z+24,R4
    02152 8E51      STD	Z+25,R5
(2944) 		}
(2945) #if !_FS_READONLY
(2946) 		if (fp->fptr > fp->fsize) {			/* Set file change flag if the file size is extended */
    02153 A5E8      LDD	R30,Y+40
    02154 A5F9      LDD	R31,Y+41
    02155 8422      LDD	R2,Z+10
    02156 8433      LDD	R3,Z+11
    02157 8444      LDD	R4,Z+12
    02158 8455      LDD	R5,Z+13
    02159 8066      LDD	R6,Z+6
    0215A 8077      LDD	R7,Z+7
    0215B 8480      LDD	R8,Z+8
    0215C 8491      LDD	R9,Z+9
    0215D 1426      CP	R2,R6
    0215E 0437      CPC	R3,R7
    0215F 0448      CPC	R4,R8
    02160 0459      CPC	R5,R9
    02161 F478      BCC	0x2171
(2947) 			fp->fsize = fp->fptr;
    02162 8026      LDD	R2,Z+6
    02163 8037      LDD	R3,Z+7
    02164 8440      LDD	R4,Z+8
    02165 8451      LDD	R5,Z+9
    02166 8622      STD	Z+10,R2
    02167 8633      STD	Z+11,R3
    02168 8644      STD	Z+12,R4
    02169 8655      STD	Z+13,R5
(2948) 			fp->flag |= FA__WRITTEN;
    0216A 01CF      MOVW	R24,R30
    0216B 9604      ADIW	R24,4
    0216C 016C      MOVW	R12,R24
    0216D 01FC      MOVW	R30,R24
    0216E 8180      LD	R24,Z
    0216F 6280      ORI	R24,0x20
    02170 8380      ST	Z,R24
(2949) 		}
(2950) #endif
(2951) 	}
(2952) 
(2953) 	LEAVE_FF(fp->fs, res);
    02171 2D0A      MOV	R16,R10
    02172 966E      ADIW	R28,0x1E
    02173 940E 2771 CALL	pop_xgsetF0FC
    02175 9624      ADIW	R28,4
    02176 9508      RET
_f_opendir:
  sfn                  --> Y,+1
  res                  --> R20
  path                 --> Y,+19
  dj                   --> R22
    02177 933A      ST	-Y,R19
    02178 932A      ST	-Y,R18
    02179 940E 279B CALL	push_xgsetF00C
    0217B 01B8      MOVW	R22,R16
    0217C 972D      SBIW	R28,0xD
(2954) }
(2955) 
(2956) 
(2957) 
(2958) #if _FS_MINIMIZE <= 1
(2959) /*-----------------------------------------------------------------------*/
(2960) /* Create a Directroy Object                                             */
(2961) /*-----------------------------------------------------------------------*/
(2962) 
(2963) FRESULT f_opendir (
(2964) 	DIR *dj,			/* Pointer to directory object to create */
(2965) 	const TCHAR *path	/* Pointer to the directory path */
(2966) )
(2967) {
(2968) 	FRESULT res;
(2969) 	DEF_NAMEBUF;
(2970) 
(2971) 
(2972) 	res = chk_mounted(&path, &dj->fs, 0);
    0217D 2422      CLR	R2
    0217E 8228      ST	Y,R2
    0217F 019B      MOVW	R18,R22
    02180 018E      MOVW	R16,R28
    02181 5E0D      SUBI	R16,0xED
    02182 4F1F      SBCI	R17,0xFF
    02183 940E 0F97 CALL	ff.c:chk_mounted
    02185 2F40      MOV	R20,R16
(2973) 	if (res == FR_OK) {
    02186 2300      TST	R16
    02187 F009      BEQ	0x2189
    02188 C05C      RJMP	0x21E5
(2974) 		INIT_BUF(*dj);
    02189 01CE      MOVW	R24,R28
    0218A 9601      ADIW	R24,1
    0218B 01FB      MOVW	R30,R22
    0218C 8B95      STD	Z+21,R25
    0218D 8B84      STD	Z+20,R24
(2975) 		res = follow_path(dj, path);			/* Follow the path to the directory */
    0218E 892B      LDD	R18,Y+19
    0218F 893C      LDD	R19,Y+20
    02190 018F      MOVW	R16,R30
    02191 940E 0E4B CALL	ff.c:follow_path
    02193 2F40      MOV	R20,R16
(2976) 		FREE_BUF();
(2977) 		if (res == FR_OK) {						/* Follow completed */
    02194 2300      TST	R16
    02195 F009      BEQ	0x2197
    02196 C04B      RJMP	0x21E2
(2978) 			if (dj->dir) {						/* It is not the root dir */
    02197 01FB      MOVW	R30,R22
    02198 8822      LDD	R2,Z+18
    02199 8833      LDD	R3,Z+19
    0219A 2022      TST	R2
    0219B F419      BNE	0x219F
    0219C 2033      TST	R3
    0219D F409      BNE	0x219F
    0219E C032      RJMP	0x21D1
(2979) 				if (dj->dir[DIR_Attr] & AM_DIR) {	/* The object is a directory */
    0219F 93AF      PUSH	R26
    021A0 93BF      PUSH	R27
    021A1 89A2      LDD	R26,Z+18
    021A2 89B3      LDD	R27,Z+19
    021A3 01FD      MOVW	R30,R26
    021A4 91BF      POP	R27
    021A5 91AF      POP	R26
    021A6 8423      LDD	R2,Z+11
    021A7 FE24      SBRS	R2,4
    021A8 C027      RJMP	0x21D0
(2980) 					dj->sclust = LD_CLUST(dj->dir);
    021A9 01FB      MOVW	R30,R22
    021AA 88A2      LDD	R10,Z+18
    021AB 88B3      LDD	R11,Z+19
    021AC 01F5      MOVW	R30,R10
    021AD 8C22      LDD	R2,Z+26
    021AE 2433      CLR	R3
    021AF 8C43      LDD	R4,Z+27
    021B0 2455      CLR	R5
    021B1 2C54      MOV	R5,R4
    021B2 2444      CLR	R4
    021B3 2842      OR	R4,R2
    021B4 2853      OR	R5,R3
    021B5 0112      MOVW	R2,R4
    021B6 2444      CLR	R4
    021B7 2455      CLR	R5
    021B8 8864      LDD	R6,Z+20
    021B9 2477      CLR	R7
    021BA 8885      LDD	R8,Z+21
    021BB 2499      CLR	R9
    021BC 2C98      MOV	R9,R8
    021BD 2488      CLR	R8
    021BE 2886      OR	R8,R6
    021BF 2897      OR	R9,R7
    021C0 0134      MOVW	R6,R8
    021C1 2488      CLR	R8
    021C2 2499      CLR	R9
    021C3 0143      MOVW	R8,R6
    021C4 2466      CLR	R6
    021C5 2477      CLR	R7
    021C6 2862      OR	R6,R2
    021C7 2873      OR	R7,R3
    021C8 2884      OR	R8,R4
    021C9 2895      OR	R9,R5
    021CA 01FB      MOVW	R30,R22
    021CB 8266      STD	Z+6,R6
    021CC 8277      STD	Z+7,R7
    021CD 8680      STD	Z+8,R8
    021CE 8691      STD	Z+9,R9
(2981) 				} else {						/* The object is not a directory */
    021CF C001      RJMP	0x21D1
(2982) 					res = FR_NO_PATH;
    021D0 E045      LDI	R20,5
(2983) 				}
(2984) 			}
(2985) 			if (res == FR_OK) {
    021D1 2344      TST	R20
    021D2 F479      BNE	0x21E2
(2986) 				dj->id = dj->fs->id;
    021D3 01FB      MOVW	R30,R22
    021D4 81A0      LD	R26,Z
    021D5 81B1      LDD	R27,Z+1
    021D6 9616      ADIW	R26,6
    021D7 902D      LD	R2,X+
    021D8 903C      LD	R3,X
    021D9 8233      STD	Z+3,R3
    021DA 8222      STD	Z+2,R2
(2987) 				res = dir_sdi(dj, 0);			/* Rewind dir */
    021DB 2722      CLR	R18
    021DC 2733      CLR	R19
    021DD 018F      MOVW	R16,R30
    021DE 940E 08F5 CALL	ff.c:dir_sdi
    021E0 2EA0      MOV	R10,R16
    021E1 2D4A      MOV	R20,R10
(2988) 			}
(2989) 		}
(2990) 		if (res == FR_NO_FILE) res = FR_NO_PATH;
    021E2 3044      CPI	R20,4
    021E3 F409      BNE	0x21E5
    021E4 E045      LDI	R20,5
(2991) 	}
(2992) 
(2993) 	LEAVE_FF(dj->fs, res);
    021E5 2F04      MOV	R16,R20
    021E6 962D      ADIW	R28,0xD
    021E7 940E 27A2 CALL	pop_xgsetF00C
    021E9 9622      ADIW	R28,2
    021EA 9508      RET
_f_readdir:
  sfn                  --> Y,+0
  res                  --> R20
  fno                  --> R10
  dj                   --> R22
    021EB 940E 27B7 CALL	push_xgsetF03C
    021ED 0159      MOVW	R10,R18
    021EE 01B8      MOVW	R22,R16
    021EF 972C      SBIW	R28,0xC
(2994) }
(2995) 
(2996) 
(2997) 
(2998) 
(2999) /*-----------------------------------------------------------------------*/
(3000) /* Read Directory Entry in Sequense                                      */
(3001) /*-----------------------------------------------------------------------*/
(3002) 
(3003) FRESULT f_readdir (
(3004) 	DIR *dj,			/* Pointer to the open directory object */
(3005) 	FILINFO *fno		/* Pointer to file information to return */
(3006) )
(3007) {
(3008) 	FRESULT res;
(3009) 	DEF_NAMEBUF;
(3010) 
(3011) 
(3012) 	res = validate(dj->fs, dj->id);			/* Check validity of the object */
    021F0 01FB      MOVW	R30,R22
    021F1 8122      LDD	R18,Z+2
    021F2 8133      LDD	R19,Z+3
    021F3 8100      LD	R16,Z
    021F4 8111      LDD	R17,Z+1
    021F5 940E 1491 CALL	ff.c:validate
    021F7 2F40      MOV	R20,R16
(3013) 	if (res == FR_OK) {
    021F8 2300      TST	R16
    021F9 F009      BEQ	0x21FB
    021FA C035      RJMP	0x2230
(3014) 		if (!fno) {
    021FB 20AA      TST	R10
    021FC F449      BNE	0x2206
    021FD 20BB      TST	R11
    021FE F439      BNE	0x2206
(3015) 			res = dir_sdi(dj, 0);			/* Rewind the directory object */
    021FF 2722      CLR	R18
    02200 2733      CLR	R19
    02201 018B      MOVW	R16,R22
    02202 940E 08F5 CALL	ff.c:dir_sdi
    02204 2F40      MOV	R20,R16
(3016) 		} else {
    02205 C02A      RJMP	0x2230
(3017) 			INIT_BUF(*dj);
    02206 01CE      MOVW	R24,R28
    02207 01FB      MOVW	R30,R22
    02208 8B95      STD	Z+21,R25
    02209 8B84      STD	Z+20,R24
(3018) 			res = dir_read(dj);				/* Read an directory item */
    0220A 018F      MOVW	R16,R30
    0220B 940E 0BF2 CALL	ff.c:dir_read
    0220D 2EC0      MOV	R12,R16
    0220E 2D4C      MOV	R20,R12
(3019) 			if (res == FR_NO_FILE) {		/* Reached end of dir */
    0220F 3004      CPI	R16,4
    02210 F441      BNE	0x2219
(3020) 				dj->sect = 0;
    02211 01FB      MOVW	R30,R22
    02212 963E      ADIW	R30,0xE
    02213 E080      LDI	R24,0
    02214 8380      ST	Z,R24
    02215 8381      STD	Z+1,R24
    02216 8382      STD	Z+2,R24
    02217 8383      STD	Z+3,R24
(3021) 				res = FR_OK;
    02218 2744      CLR	R20
(3022) 			}
(3023) 			if (res == FR_OK) {				/* A valid entry is found */
    02219 2344      TST	R20
    0221A F4A9      BNE	0x2230
(3024) 				get_fileinfo(dj, fno);		/* Get the object information */
    0221B 0195      MOVW	R18,R10
    0221C 018B      MOVW	R16,R22
    0221D 940E 0DA8 CALL	ff.c:get_fileinfo
(3025) 				res = dir_next(dj, 0);		/* Increment index for next */
    0221F 2722      CLR	R18
    02220 2733      CLR	R19
    02221 018B      MOVW	R16,R22
    02222 940E 09FF CALL	ff.c:dir_next
    02224 2EA0      MOV	R10,R16
    02225 2D4A      MOV	R20,R10
(3026) 				if (res == FR_NO_FILE) {
    02226 3004      CPI	R16,4
    02227 F441      BNE	0x2230
(3027) 					dj->sect = 0;
    02228 01FB      MOVW	R30,R22
    02229 963E      ADIW	R30,0xE
    0222A E080      LDI	R24,0
    0222B 8380      ST	Z,R24
    0222C 8381      STD	Z+1,R24
    0222D 8382      STD	Z+2,R24
    0222E 8383      STD	Z+3,R24
(3028) 					res = FR_OK;
    0222F 2744      CLR	R20
(3029) 				}
(3030) 			}
(3031) 			FREE_BUF();
(3032) 		}
(3033) 	}
(3034) 
(3035) 	LEAVE_FF(dj->fs, res);
    02230 2F04      MOV	R16,R20
    02231 962C      ADIW	R28,0xC
    02232 940C 27C0 JMP	pop_xgsetF03C
FILE: D:\LQD\工程仿真2012_7_5\software\MEGA128\FILERW\software_src\delay.c
(0001) /*******************************
(0002)  function ：延时函数
(0003) Clock F  :7.3728M 
(0004) Software : ICCAVR7.14C
(0005) ********************************/
(0006) /*---------------------------------------------------------------------------------
(0007)      延时程序计算方法
(0008)      计数个数j = 延时时间/6*晶振频率 - 1
(0009) ---------------------------------------------------------------------------------*/
(0010) void delayus(unsigned int tttt)   // 1.2us 延时子函数   
(0011) { 
(0012)    do
(0013)    {
(0014)        tttt--;
_delayus:
  tttt                 --> R16
    02234 5001      SUBI	R16,1
    02235 4010      SBCI	R17,0
(0015)    }
(0016)    while(tttt>1);
    02236 E081      LDI	R24,1
    02237 E090      LDI	R25,0
    02238 1780      CP	R24,R16
    02239 0791      CPC	R25,R17
    0223A F3C8      BCS	0x2234
    0223B 9508      RET
_delayms:
  j                    --> R20
  i                    --> R16
    0223C 934A      ST	-Y,R20
    0223D 935A      ST	-Y,R21
(0017) }
(0018) void delayms(unsigned int i)                 //1ms延时
(0019)    {
    0223E C00A      RJMP	0x2249
(0020)     while(i--)
(0021)     {                          
(0022) 	    unsigned int j;                
(0023)         for(j=1;j<=1227;j++)   
    0223F E041      LDI	R20,1
    02240 E050      LDI	R21,0
    02241 C002      RJMP	0x2244
    02242 5F4F      SUBI	R20,0xFF
    02243 4F5F      SBCI	R21,0xFF
    02244 EC8B      LDI	R24,0xCB
    02245 E094      LDI	R25,4
    02246 1784      CP	R24,R20
    02247 0795      CPC	R25,R21
    02248 F7C8      BCC	0x2242
    02249 0118      MOVW	R2,R16
    0224A 5001      SUBI	R16,1
    0224B 4010      SBCI	R17,0
    0224C 2022      TST	R2
    0224D F789      BNE	0x223F
    0224E 2033      TST	R3
    0224F F779      BNE	0x223F
    02250 9159      LD	R21,Y+
    02251 9149      LD	R20,Y+
    02252 9508      RET
FILE: D:\LQD\工程仿真2012_7_5\software\MEGA128\FILERW\software_src\main.c
(0001) #include "config.h"
(0002) 
(0003) char buffer[512];
(0004) void initDevices(void){
(0005) 	 SPI_IO_Init();
_initDevices:
    02253 940E 24B4 CALL	_SPI_IO_Init
(0006) 	 SD_Init();
    02255 940E 22EF CALL	_SD_Init
(0007) 	 uart1_init();
    02257 940C 24C8 JMP	_uart1_init
_main:
  i                    --> Y,+0
    02259 9724      SBIW	R28,4
(0008) 
(0009) }
(0010) void WriteFileHead(void) ;
(0011) void main(void){
(0012) 	 long i=0x5500;
    0225A E080      LDI	R24,0
    0225B 8388      ST	Y,R24
    0225C 838A      STD	Y+2,R24
    0225D 838B      STD	Y+3,R24
    0225E E585      LDI	R24,0x55
    0225F 8389      STD	Y+1,R24
(0013) 	 initDevices();
    02260 DFF2      RCALL	_initDevices
(0014) 	 WriteFileHead();
    02261 D003      RCALL	_WriteFileHead
(0015) 	 while(1)
    02262 CFFF      RJMP	0x2262
    02263 9624      ADIW	R28,4
    02264 9508      RET
_WriteFileHead:
  fs                   --> Y,+165
  bw                   --> Y,+163
  itam                 --> Y,+38
  file                 --> Y,+4
  res                  --> R10
    02265 92AA      ST	-Y,R10
    02266 92CA      ST	-Y,R12
    02267 97EF      SBIW	R28,0x3F
    02268 97EF      SBIW	R28,0x3F
    02269 97EF      SBIW	R28,0x3F
    0226A 97EF      SBIW	R28,0x3F
    0226B 97EF      SBIW	R28,0x3F
    0226C 97EF      SBIW	R28,0x3F
    0226D 97EF      SBIW	R28,0x3F
    0226E 97EF      SBIW	R28,0x3F
    0226F 97EF      SBIW	R28,0x3F
    02270 97EF      SBIW	R28,0x3F
    02271 97EF      SBIW	R28,0x3F
    02272 976E      SBIW	R28,0x1E
(0016) 	 {
(0017) 	  
(0018)  
(0019) 	 }
(0020) 
(0021) 
(0022) }
(0023) void WriteFileHead(void)   
(0024) {
(0025)  	 unsigned int bw;
(0026) 	 FRESULT res;
(0027) 	 FATFS fs;
(0028) 	 FIL file;
(0029) 	 UINT8 itam[]="DEV000001\t\t\t\t\t\t\t\t\t\t\t\r\n序号\t日期\t时分\t温度\t风速\t风冷指数\t等价制冷温度\t相当温度\t冻伤危害性\t安静作业\t中等强度作业\t高强度作业\r\n\0";
    02273 E08F      LDI	R24,0xF
    02274 E091      LDI	R25,1
    02275 01FE      MOVW	R30,R28
    02276 96B6      ADIW	R30,0x26
    02277 E70D      LDI	R16,0x7D
    02278 E010      LDI	R17,0
    02279 93FA      ST	-Y,R31
    0227A 93EA      ST	-Y,R30
    0227B 939A      ST	-Y,R25
    0227C 938A      ST	-Y,R24
    0227D 940E 2816 CALL	asgnblk
(0030) 	 res=disk_initialize(0);
    0227F 2700      CLR	R16
    02280 940E 00C2 CALL	_disk_initialize
(0031) 	 #if _UARTDEBUG
(0032) 	 PrintString("\n diskinit=");   PrintChar(res);//debug
(0033) 	 #endif
(0034) 	 res = f_mount(0, &fs);
    02282 019E      MOVW	R18,R28
    02283 552B      SUBI	R18,0x5B
    02284 4F3F      SBCI	R19,0xFF
    02285 2700      CLR	R16
    02286 940E 14AE CALL	_f_mount
(0035) 	 #if _UARTDEBUG
(0036)  	 PrintString("\n diskmount=");   PrintChar(res);//debug
(0037) 	 #endif
(0038) 	 res = f_open(&file,"lululala.xls", FA_OPEN_ALWAYS | FA_WRITE );  //创建一个新的文件
    02288 E182      LDI	R24,0x12
    02289 8388      ST	Y,R24
    0228A E82C      LDI	R18,0x8C
    0228B E031      LDI	R19,1
    0228C 018E      MOVW	R16,R28
    0228D 5F0C      SUBI	R16,0xFC
    0228E 4F1F      SBCI	R17,0xFF
    0228F 940E 14D9 CALL	_f_open
(0039) 	 #if _UARTDEBUG
(0040) 	 PrintString("\n diskopen=");   PrintChar(res);//debug
(0041) 	 #endif
(0042) 	 res = f_write(&file,itam,128,&bw);   //bw 已写入字节数
    02291 01CE      MOVW	R24,R28
    02292 558D      SUBI	R24,0x5D
    02293 4F9F      SBCI	R25,0xFF
    02294 839B      STD	Y+3,R25
    02295 838A      STD	Y+2,R24
    02296 E880      LDI	R24,0x80
    02297 E090      LDI	R25,0
    02298 8399      STD	Y+1,R25
    02299 8388      ST	Y,R24
    0229A 019E      MOVW	R18,R28
    0229B 5D2A      SUBI	R18,0xDA
    0229C 4F3F      SBCI	R19,0xFF
    0229D 018E      MOVW	R16,R28
    0229E 5F0C      SUBI	R16,0xFC
    0229F 4F1F      SBCI	R17,0xFF
    022A0 940E 18E0 CALL	_f_write
    022A2 2EC0      MOV	R12,R16
    022A3 2CAC      MOV	R10,R12
(0043) 	 #if _UARTDEBUG
(0044) 	 PrintString("\n diskwrite=");   PrintChar(res);//debug
(0045) 	 #endif
(0046) 	 f_close(&file);
    022A4 018E      MOVW	R16,R28
    022A5 5F0C      SUBI	R16,0xFC
    022A6 4F1F      SBCI	R17,0xFF
    022A7 940E 1CAA CALL	_f_close
(0047) 	 f_mount(0, NULL);
    022A9 2722      CLR	R18
    022AA 2733      CLR	R19
    022AB 2700      CLR	R16
    022AC 940E 14AE CALL	_f_mount
    022AE 96EF      ADIW	R28,0x3F
    022AF 96EF      ADIW	R28,0x3F
    022B0 96EF      ADIW	R28,0x3F
    022B1 96EF      ADIW	R28,0x3F
    022B2 96EF      ADIW	R28,0x3F
    022B3 96EF      ADIW	R28,0x3F
    022B4 96EF      ADIW	R28,0x3F
    022B5 96EF      ADIW	R28,0x3F
    022B6 96EF      ADIW	R28,0x3F
    022B7 96EF      ADIW	R28,0x3F
    022B8 96EF      ADIW	R28,0x3F
    022B9 966E      ADIW	R28,0x1E
    022BA 90C9      LD	R12,Y+
    022BB 90A9      LD	R10,Y+
    022BC 9508      RET
_SD_Write_cmd:
  k                    --> R22
  temp                 --> R20
  p                    --> R20
    022BD 940E 2791 CALL	push_xgsetF000
    022BF 01A8      MOVW	R20,R16
FILE: D:\LQD\工程仿真2012_7_5\software\MEGA128\FILERW\software_src\sd.c
(0001) //*****************************************************************************//
(0002) //*								数码相框
(0003) //*控制芯片：ATmgea128
(0004) //*开发环境：AVR Studio+GCC
(0005) //*隶属模块：SD卡控制
(0006) //*修改者：  桃子
(0007) //*****************************************************************************//
(0008) #include "sd.h"
(0009) 
(0010) //****************************************************************
(0011) //*隶属模块：SD卡控制
(0012) //*函数功能：写6字节数据
(0013) //****************************************************************
(0014) UINT8 SD_Write_cmd(UINT8 *p)
(0015) {	
(0016) 	UINT16 temp,k=0;
    022C0 2766      CLR	R22
    022C1 2777      CLR	R23
(0017) 	SD_CS_DIS();//禁止SPI
    022C2 9AC0      SBI	0x18,0
(0018) 	SPI_Read();//空读一字节
    022C3 940E 24C2 CALL	_SPI_Read
(0019) 	SD_CS_EN();//使能SPI
    022C5 98C0      CBI	0x18,0
(0020) 
(0021) 	SPI_Write(p[0]);
    022C6 01FA      MOVW	R30,R20
    022C7 8100      LD	R16,Z
    022C8 940E 24BE CALL	_SPI_Write
(0022) 	SPI_Write(p[1]);
    022CA 01FA      MOVW	R30,R20
    022CB 8101      LDD	R16,Z+1
    022CC 940E 24BE CALL	_SPI_Write
(0023) 	SPI_Write(p[2]);
    022CE 01FA      MOVW	R30,R20
    022CF 8102      LDD	R16,Z+2
    022D0 940E 24BE CALL	_SPI_Write
(0024) 	SPI_Write(p[3]);
    022D2 01FA      MOVW	R30,R20
    022D3 8103      LDD	R16,Z+3
    022D4 940E 24BE CALL	_SPI_Write
(0025) 	SPI_Write(p[4]);
    022D6 01FA      MOVW	R30,R20
    022D7 8104      LDD	R16,Z+4
    022D8 940E 24BE CALL	_SPI_Write
(0026) 	SPI_Write(p[5]);
    022DA 01FA      MOVW	R30,R20
    022DB 8105      LDD	R16,Z+5
    022DC 940E 24BE CALL	_SPI_Write
(0027) 
(0028) 	do 
(0029)  	{  
(0030)   		temp = SPI_Read();//一直读，直到读到的不是0xff或超时
    022DE 940E 24C2 CALL	_SPI_Read
    022E0 2F40      MOV	R20,R16
    022E1 2755      CLR	R21
(0031)  		k++;
    022E2 5F6F      SUBI	R22,0xFF
    022E3 4F7F      SBCI	R23,0xFF
(0032)  	}while((temp==0xff)&&(k<TRY_TIME)); 
    022E4 3F4F      CPI	R20,0xFF
    022E5 E0E0      LDI	R30,0
    022E6 075E      CPC	R21,R30
    022E7 F421      BNE	0x22EC
    022E8 3164      CPI	R22,0x14
    022E9 E0E0      LDI	R30,0
    022EA 077E      CPC	R23,R30
    022EB F390      BCS	0x22DE
(0033) 
(0034) 	return temp;
    022EC 2F04      MOV	R16,R20
    022ED 940C 2796 JMP	pop_xgsetF000
_SD_Init:
  pcmd                 --> Y,+0
  temp                 --> R22
  time                 --> R20
    022EF 934A      ST	-Y,R20
    022F0 936A      ST	-Y,R22
    022F1 9726      SBIW	R28,6
(0035) }
(0036) //****************************************************************
(0037) //*隶属模块：SD卡控制
(0038) //*函数功能：初始化
(0039) //****************************************************************
(0040) UINT8 SD_Init(void)	
(0041) {  
(0042) 	UINT8 time=0,temp=0;
    022F2 2766      CLR	R22
(0043) 	UINT8 pcmd[] = {0x40,0x00,0x00,0x00,0x00,0x95}; //命令0的字节序列
    022F3 E989      LDI	R24,0x99
    022F4 E091      LDI	R25,1
    022F5 01FE      MOVW	R30,R28
    022F6 E006      LDI	R16,6
    022F7 E010      LDI	R17,0
    022F8 93FA      ST	-Y,R31
    022F9 93EA      ST	-Y,R30
    022FA 939A      ST	-Y,R25
    022FB 938A      ST	-Y,R24
    022FC 940E 2816 CALL	asgnblk
(0044) 
(0045) 	SD_PORT |= (1<<SD_CS);
    022FE 9AC0      SBI	0x18,0
(0046) 	SD_DDR |= (1<<SD_CS);
    022FF 9AB8      SBI	0x17,0
(0047) 
(0048) 	SPI_IO_Init();
    02300 940E 24B4 CALL	_SPI_IO_Init
(0049) 	SPI_Low();
    02302 E582      LDI	R24,0x52
    02303 B98D      OUT	0x0D,R24
    02304 B18E      IN	R24,0x0E
    02305 7F8F      ANDI	R24,0xFF
    02306 B98E      OUT	0x0E,R24
(0050) 
(0051) 	SD_CS_DIS();  //关闭片选 
    02307 9AC0      SBI	0x18,0
(0052) 	for(time=0;time<10;time++) //初始时，首先要发送最少74个时钟信号，这是必须的！！！
    02308 2744      CLR	R20
    02309 C003      RJMP	0x230D
(0053) 	{
(0054)   		SPI_Read(); 
    0230A 940E 24C2 CALL	_SPI_Read
    0230C 9543      INC	R20
    0230D 304A      CPI	R20,0xA
    0230E F3D8      BCS	0x230A
(0055) 	}
(0056) 	SD_CS_EN(); //打开片选
    0230F 98C0      CBI	0x18,0
(0057) 	time = 0;
    02310 2744      CLR	R20
(0058) 	do
(0059) 	{ 
(0060) 		temp=SD_Write_cmd(pcmd);//写入CMD0
    02311 018E      MOVW	R16,R28
    02312 DFAA      RCALL	_SD_Write_cmd
    02313 2F60      MOV	R22,R16
(0061) 	 	time++;
    02314 9543      INC	R20
(0062) 	 	if(time==TRY_TIME) 
    02315 3144      CPI	R20,0x14
    02316 F419      BNE	0x231A
(0063) 	 	{ 
(0064) 	  		SD_CS_DIS(); //关闭片选
    02317 9AC0      SBI	0x18,0
(0065) 	  		return(INIT_CMD0_ERROR);//CMD0写入失败
    02318 E001      LDI	R16,1
    02319 C01D      RJMP	0x2337
(0066) 	 	}
(0067) 	 }while(temp!=0x01);
    0231A 3061      CPI	R22,1
    0231B F7A9      BNE	0x2311
(0068) 
(0069) 	SD_CS_DIS(); //关闭片选
    0231C 9AC0      SBI	0x18,0
(0070) 	SPI_Read(); //按照SD卡的操作时序在这里补8个时钟 
    0231D 940E 24C2 CALL	_SPI_Read
(0071) 	SD_CS_EN(); //打开片选
    0231F 98C0      CBI	0x18,0
(0072) 
(0073) 	pcmd[0]=0x41,pcmd[5]=0xff;
    02320 E481      LDI	R24,0x41
    02321 8388      ST	Y,R24
    02322 EF8F      LDI	R24,0xFF
    02323 838D      STD	Y+5,R24
(0074) 	time = 0;
    02324 2744      CLR	R20
(0075) 	do
(0076) 	{ 
(0077) 		temp=SD_Write_cmd(pcmd);
    02325 018E      MOVW	R16,R28
    02326 DF96      RCALL	_SD_Write_cmd
    02327 2F60      MOV	R22,R16
(0078) 		time++;
    02328 9543      INC	R20
(0079) 		if(time==TRY_TIME) 
    02329 3144      CPI	R20,0x14
    0232A F419      BNE	0x232E
(0080) 		{ 
(0081) 		 	SD_CS_DIS(); //关闭片选
    0232B 9AC0      SBI	0x18,0
(0082) 			 return(INIT_CMD1_ERROR);//CMD1写入失败
    0232C E002      LDI	R16,2
    0232D C009      RJMP	0x2337
(0083) 		 }
(0084) 	 }while(temp!=0);
    0232E 2366      TST	R22
    0232F F7A9      BNE	0x2325
(0085)   
(0086) 	 SPI_High();  
    02330 E580      LDI	R24,0x50
    02331 B98D      OUT	0x0D,R24
    02332 9A70      SBI	0x0E,0
(0087) 	 SD_CS_DIS();  //关闭片选 
    02333 9AC0      SBI	0x18,0
(0088) 	 SPI_Read(); //按照SD卡的操作时序在这里补8个时钟
    02334 940E 24C2 CALL	_SPI_Read
(0089) 	 return SD_TURE; //返回0,说明初始化操作成功
    02336 2700      CLR	R16
    02337 9626      ADIW	R28,6
    02338 9169      LD	R22,Y+
    02339 9149      LD	R20,Y+
    0233A 9508      RET
_SD_Write_Sector:
  pcmd                 --> Y,+0
  time                 --> R12
  temp                 --> R20
  i                    --> R22
  buffer               --> R10
  addr                 --> Y,+14
    0233B 940E 26A9 CALL	push_arg4
    0233D 940E 27B7 CALL	push_xgsetF03C
    0233F 9726      SBIW	R28,6
    02340 88AA      LDD	R10,Y+18
    02341 88BB      LDD	R11,Y+19
(0090) } 
(0091) //****************************************************************
(0092) //*隶属模块：SD卡控制
(0093) //*函数功能：写512字节数据（一扇区字节）
(0094) //****************************************************************
(0095) UINT16 SD_Write_Sector(UINT32 addr,UINT8 *buffer)
(0096) {  
(0097) 	UINT8 temp=0,time=0;
    02342 2744      CLR	R20
    02343 24CC      CLR	R12
(0098) 	UINT16 i=0;
    02344 2766      CLR	R22
    02345 2777      CLR	R23
(0099) 	UINT8 pcmd[] = {0x58,0x00,0x00,0x00,0x00,0xff}; //向SD卡中单个块（512字节，一个扇区）写入数据，用CMD24
    02346 E98F      LDI	R24,0x9F
    02347 E091      LDI	R25,1
    02348 01FE      MOVW	R30,R28
    02349 E006      LDI	R16,6
    0234A E010      LDI	R17,0
    0234B 93FA      ST	-Y,R31
    0234C 93EA      ST	-Y,R30
    0234D 939A      ST	-Y,R25
    0234E 938A      ST	-Y,R24
    0234F 940E 2816 CALL	asgnblk
(0100) 
(0101) 	 addr<<=9; //将块地址（扇区地址）转为字节地址 ［这里就限制了SD卡的最大容量为4G］
    02351 E089      LDI	R24,0x9
    02352 E090      LDI	R25,0
    02353 850E      LDD	R16,Y+14
    02354 851F      LDD	R17,Y+15
    02355 8928      LDD	R18,Y+16
    02356 8939      LDD	R19,Y+17
    02357 938A      ST	-Y,R24
    02358 940E 27F7 CALL	lsl32
    0235A 870E      STD	Y+14,R16
    0235B 871F      STD	Y+15,R17
    0235C 8B28      STD	Y+16,R18
    0235D 8B39      STD	Y+17,R19
(0102) 
(0103) 	 pcmd[1]=(addr>>24); //将字节地址写入到CMD24字节序列中
    0235E E188      LDI	R24,0x18
    0235F E090      LDI	R25,0
    02360 850E      LDD	R16,Y+14
    02361 851F      LDD	R17,Y+15
    02362 8928      LDD	R18,Y+16
    02363 8939      LDD	R19,Y+17
    02364 938A      ST	-Y,R24
    02365 940E 280A CALL	lsr32
    02367 8309      STD	Y+1,R16
(0104) 	 pcmd[2]=(addr>>16);
    02368 842E      LDD	R2,Y+14
    02369 843F      LDD	R3,Y+15
    0236A 8848      LDD	R4,Y+16
    0236B 8859      LDD	R5,Y+17
    0236C 0112      MOVW	R2,R4
    0236D 2444      CLR	R4
    0236E 2455      CLR	R5
    0236F 822A      STD	Y+2,R2
(0105) 	 pcmd[3]=(addr>>8);
    02370 E088      LDI	R24,0x8
    02371 E090      LDI	R25,0
    02372 850E      LDD	R16,Y+14
    02373 851F      LDD	R17,Y+15
    02374 8928      LDD	R18,Y+16
    02375 8939      LDD	R19,Y+17
    02376 938A      ST	-Y,R24
    02377 940E 280A CALL	lsr32
    02379 830B      STD	Y+3,R16
(0106) 	// pcmd[4]=offset;	
(0107) 	 SD_CS_EN();//打开SD卡片选
    0237A 98C0      CBI	0x18,0
(0108) 
(0109) 	 do
(0110) 	 {  
(0111) 		temp=SD_Write_cmd(pcmd);
    0237B 018E      MOVW	R16,R28
    0237C DF40      RCALL	_SD_Write_cmd
    0237D 2F40      MOV	R20,R16
(0112)   		time++;
    0237E 94C3      INC	R12
(0113)   		if(time==TRY_TIME) 
    0237F 2D8C      MOV	R24,R12
    02380 3184      CPI	R24,0x14
    02381 F419      BNE	0x2385
(0114)   		{ 
(0115)    			SD_CS_DIS(); //关闭片选
    02382 9AC0      SBI	0x18,0
(0116)    			return(temp); //命令写入失败
    02383 2711      CLR	R17
    02384 C037      RJMP	0x23BC
(0117)   		}
(0118) 	}while(temp!=0); 
    02385 2344      TST	R20
    02386 F7A1      BNE	0x237B
(0119) 
(0120) 	for(i=0;i<100;i++) //这里要插入若干时钟信号
    02387 2766      CLR	R22
    02388 2777      CLR	R23
    02389 C004      RJMP	0x238E
(0121)   		SPI_Read();
    0238A 940E 24C2 CALL	_SPI_Read
    0238C 5F6F      SUBI	R22,0xFF
    0238D 4F7F      SBCI	R23,0xFF
    0238E 3664      CPI	R22,0x64
    0238F E0E0      LDI	R30,0
    02390 077E      CPC	R23,R30
    02391 F3C0      BCS	0x238A
(0122) 	
(0123) 	SPI_Write(0xfe);//写入开始字节 0xfe，后面就是要写入的512个字节的数据	
    02392 EF0E      LDI	R16,0xFE
    02393 940E 24BE CALL	_SPI_Write
(0124) 	
(0125) 	for(i=0;i<512;i++) //将缓冲区中要写入的512个字节写入SD卡
    02395 2766      CLR	R22
    02396 2777      CLR	R23
    02397 C007      RJMP	0x239F
(0126) 		SPI_Write(*buffer++);
    02398 01F5      MOVW	R30,R10
    02399 9101      LD	R16,Z+
    0239A 015F      MOVW	R10,R30
    0239B 940E 24BE CALL	_SPI_Write
    0239D 5F6F      SUBI	R22,0xFF
    0239E 4F7F      SBCI	R23,0xFF
    0239F 3060      CPI	R22,0
    023A0 E0E2      LDI	R30,2
    023A1 077E      CPC	R23,R30
    023A2 F3A8      BCS	0x2398
(0127)   
(0128) 	SPI_Read(); 
    023A3 940E 24C2 CALL	_SPI_Read
(0129) 	SPI_Read(); //两个字节的CRC校验码，不用关心
    023A5 940E 24C2 CALL	_SPI_Read
(0130)    
(0131)     
(0132) 	temp=SPI_Read();   //读取返回值
    023A7 940E 24C2 CALL	_SPI_Read
    023A9 2F40      MOV	R20,R16
(0133) 	if((temp&0x1F)!=0x05) //如果返回值是 XXX00101说明数据已经被SD卡接受了
    023AA 2F84      MOV	R24,R20
    023AB 718F      ANDI	R24,0x1F
    023AC 3085      CPI	R24,5
    023AD F021      BEQ	0x23B2
(0134) 	{
(0135)  		SD_CS_DIS();
    023AE 9AC0      SBI	0x18,0
(0136)  		return(WRITE_BLOCK_ERROR); //写块数据失败
    023AF E003      LDI	R16,3
    023B0 E010      LDI	R17,0
    023B1 C00A      RJMP	0x23BC
(0137) 	}
(0138)  
(0139) 	while(SPI_Read()!=0xff);//等到SD卡不忙（数据被接受以后，SD卡要将这些数据写入到自身的FLASH中，需要一个时间）
    023B2 940E 24C2 CALL	_SPI_Read
    023B4 2F40      MOV	R20,R16
    023B5 3F0F      CPI	R16,0xFF
    023B6 F7D9      BNE	0x23B2
(0140) 						    //忙时，读回来的值为0x00,不忙时，为0xff
(0141) 
(0142) 	SD_CS_DIS(); //关闭片选
    023B7 9AC0      SBI	0x18,0
(0143) 
(0144) 	SPI_Read();//按照SD卡的操作时序在这里补8个时钟
    023B8 940E 24C2 CALL	_SPI_Read
(0145) 	return SD_TURE;		 //返回0,说明写扇区操作成功
    023BA 2700      CLR	R16
    023BB 2711      CLR	R17
    023BC 9626      ADIW	R28,6
    023BD 940E 27C0 CALL	pop_xgsetF03C
    023BF 9624      ADIW	R28,4
    023C0 9508      RET
_SD_Read_Sector:
  pcmd                 --> Y,+0
  temp                 --> R12
  time                 --> R22
  j                    --> R20
  buffer               --> R10
  addr                 --> Y,+14
    023C1 940E 26A9 CALL	push_arg4
    023C3 940E 27B7 CALL	push_xgsetF03C
    023C5 9726      SBIW	R28,6
    023C6 88AA      LDD	R10,Y+18
    023C7 88BB      LDD	R11,Y+19
(0146) } 
(0147) //****************************************************************
(0148) //*隶属模块：SD卡控制
(0149) //*函数功能：读512字节数据（一扇区字节）
(0150) //****************************************************************
(0151) UINT16 SD_Read_Sector(UINT32 addr,UINT8 *buffer)//从SD卡的指定扇区中读出512个字节，使用CMD17（17号命令）
(0152) {
(0153) 
(0154) 	 UINT16 j=0;
    023C8 2744      CLR	R20
    023C9 2755      CLR	R21
(0155) 	 UINT8 time=0,temp=0;
    023CA 2766      CLR	R22
    023CB 24CC      CLR	R12
(0156) 	 UINT8 pcmd[]={0x51,0x00,0x00,0x00,0x00,0xff}; //CMD17的字节序列
    023CC EA85      LDI	R24,0xA5
    023CD E091      LDI	R25,1
    023CE 01FE      MOVW	R30,R28
    023CF E006      LDI	R16,6
    023D0 E010      LDI	R17,0
    023D1 93FA      ST	-Y,R31
    023D2 93EA      ST	-Y,R30
    023D3 939A      ST	-Y,R25
    023D4 938A      ST	-Y,R24
    023D5 940E 2816 CALL	asgnblk
(0157) 
(0158) 	 addr <<= 9; //将块地址（扇区地址）转为字节地址
    023D7 E089      LDI	R24,0x9
    023D8 E090      LDI	R25,0
    023D9 850E      LDD	R16,Y+14
    023DA 851F      LDD	R17,Y+15
    023DB 8928      LDD	R18,Y+16
    023DC 8939      LDD	R19,Y+17
    023DD 938A      ST	-Y,R24
    023DE 940E 27F7 CALL	lsl32
    023E0 870E      STD	Y+14,R16
    023E1 871F      STD	Y+15,R17
    023E2 8B28      STD	Y+16,R18
    023E3 8B39      STD	Y+17,R19
(0159) 
(0160) 	 pcmd[1] = (addr>>24);//将字节地址写入到CMD17字节序列中
    023E4 E188      LDI	R24,0x18
    023E5 E090      LDI	R25,0
    023E6 850E      LDD	R16,Y+14
    023E7 851F      LDD	R17,Y+15
    023E8 8928      LDD	R18,Y+16
    023E9 8939      LDD	R19,Y+17
    023EA 938A      ST	-Y,R24
    023EB 940E 280A CALL	lsr32
    023ED 8309      STD	Y+1,R16
(0161) 	 pcmd[2] = (addr>>16);
    023EE 842E      LDD	R2,Y+14
    023EF 843F      LDD	R3,Y+15
    023F0 8848      LDD	R4,Y+16
    023F1 8859      LDD	R5,Y+17
    023F2 0112      MOVW	R2,R4
    023F3 2444      CLR	R4
    023F4 2455      CLR	R5
    023F5 822A      STD	Y+2,R2
(0162) 	 pcmd[3] =(addr>>8);
    023F6 E088      LDI	R24,0x8
    023F7 E090      LDI	R25,0
    023F8 850E      LDD	R16,Y+14
    023F9 851F      LDD	R17,Y+15
    023FA 8928      LDD	R18,Y+16
    023FB 8939      LDD	R19,Y+17
    023FC 938A      ST	-Y,R24
    023FD 940E 280A CALL	lsr32
    023FF 830B      STD	Y+3,R16
(0163) 	// pcmd[4] = offset;
(0164) 
(0165) 	 SD_CS_EN();//打开片选 
    02400 98C0      CBI	0x18,0
(0166) 
(0167) 	 do
(0168) 	 {  
(0169) 		  temp=SD_Write_cmd(pcmd); //写入CMD17
    02401 018E      MOVW	R16,R28
    02402 DEBA      RCALL	_SD_Write_cmd
    02403 2EC0      MOV	R12,R16
(0170) 		  time++;
    02404 9563      INC	R22
(0171) 		  if(time==TRY_TIME) 
    02405 3164      CPI	R22,0x14
    02406 F421      BNE	0x240B
(0172) 		  {
(0173) 		   SD_CS_DIS();
    02407 9AC0      SBI	0x18,0
(0174) 		   return(READ_BLOCK_ERROR); //读块失败
    02408 E004      LDI	R16,4
    02409 E010      LDI	R17,0
    0240A C01F      RJMP	0x242A
(0175) 		  }
(0176) 	 }while(temp!=0); 
    0240B 20CC      TST	R12
    0240C F7A1      BNE	0x2401
(0177)    			
(0178) 	 while(SPI_Read()!= 0xfe); //一直读，当读到0xfe时，说明后面的是512字节的数据了
    0240D 940E 24C2 CALL	_SPI_Read
    0240F 3F0E      CPI	R16,0xFE
    02410 F7E1      BNE	0x240D
(0179)  		   	   	
(0180) 	 for(j=0;j<512;j++)	 //将数据写入到数据缓冲区中
    02411 2744      CLR	R20
    02412 2755      CLR	R21
    02413 C009      RJMP	0x241D
(0181) 	 {	
(0182) 	    buffer[j]=SPI_Read();
    02414 940E 24C2 CALL	_SPI_Read
    02416 2EC0      MOV	R12,R16
    02417 01FA      MOVW	R30,R20
    02418 0DEA      ADD	R30,R10
    02419 1DFB      ADC	R31,R11
    0241A 82C0      ST	Z,R12
    0241B 5F4F      SUBI	R20,0xFF
    0241C 4F5F      SBCI	R21,0xFF
    0241D 3040      CPI	R20,0
    0241E E0E2      LDI	R30,2
    0241F 075E      CPC	R21,R30
    02420 F398      BCS	0x2414
(0183) 	 }
(0184) 
(0185) 	 SPI_Read();//读取两个字节的CRC校验码，不用关心它们
    02421 940E 24C2 CALL	_SPI_Read
(0186) 	 SPI_Read();
    02423 940E 24C2 CALL	_SPI_Read
(0187) 
(0188) 	 SD_CS_DIS();  //SD卡关闭片选 
    02425 9AC0      SBI	0x18,0
(0189) 
(0190) 	 SPI_Read();//按照SD卡的操作时序在这里补8个时钟
    02426 940E 24C2 CALL	_SPI_Read
(0191) 
(0192) 	 return SD_TURE;
    02428 2700      CLR	R16
    02429 2711      CLR	R17
    0242A 9626      ADIW	R28,6
    0242B 940E 27C0 CALL	pop_xgsetF03C
    0242D 9624      ADIW	R28,4
    0242E 9508      RET
_SD_Read_Sector_ndata:
  pcmd                 --> Y,+0
  temp                 --> R12
  time                 --> R22
  j                    --> R20
  len                  --> R14
  offset               --> R10
  buffer               --> Y,+20
  addr                 --> Y,+16
    0242F 940E 26A9 CALL	push_arg4
    02431 940E 277C CALL	push_xgsetF0FC
    02433 9726      SBIW	R28,6
    02434 88AE      LDD	R10,Y+22
    02435 88BF      LDD	R11,Y+23
    02436 8CE8      LDD	R14,Y+24
    02437 8CF9      LDD	R15,Y+25
(0193) }
(0194) //****************************************************************
(0195) //*隶属模块：SD卡控制
(0196) //*函数功能：写多扇区数据（多扇区字节）
(0197) //****************************************************************
(0198) UINT16 SD_Read_Sector_ndata(UINT32 addr,UINT8 *buffer,UINT16 offset,UINT16 len)//从SD卡的指定扇区中读出512个字节，使用CMD17（17号命令）
(0199) {
(0200) 
(0201) 	 UINT16 j=0;
    02438 2744      CLR	R20
    02439 2755      CLR	R21
(0202) 	 UINT8 time=0,temp=0;
    0243A 2766      CLR	R22
    0243B 24CC      CLR	R12
(0203) 	 UINT8 pcmd[]={0x51,0x00,0x00,0x00,0x00,0xff}; //CMD17的字节序列
    0243C EA8B      LDI	R24,0xAB
    0243D E091      LDI	R25,1
    0243E 01FE      MOVW	R30,R28
    0243F E006      LDI	R16,6
    02440 E010      LDI	R17,0
    02441 93FA      ST	-Y,R31
    02442 93EA      ST	-Y,R30
    02443 939A      ST	-Y,R25
    02444 938A      ST	-Y,R24
    02445 940E 2816 CALL	asgnblk
(0204) 
(0205) 	 addr <<= 9; //将块地址（扇区地址）转为字节地址
    02447 E089      LDI	R24,0x9
    02448 E090      LDI	R25,0
    02449 8908      LDD	R16,Y+16
    0244A 8919      LDD	R17,Y+17
    0244B 892A      LDD	R18,Y+18
    0244C 893B      LDD	R19,Y+19
    0244D 938A      ST	-Y,R24
    0244E 940E 27F7 CALL	lsl32
    02450 8B08      STD	Y+16,R16
    02451 8B19      STD	Y+17,R17
    02452 8B2A      STD	Y+18,R18
    02453 8B3B      STD	Y+19,R19
(0206) 
(0207) 	 pcmd[1] = (addr>>24);//将字节地址写入到CMD17字节序列中
    02454 E188      LDI	R24,0x18
    02455 E090      LDI	R25,0
    02456 8908      LDD	R16,Y+16
    02457 8919      LDD	R17,Y+17
    02458 892A      LDD	R18,Y+18
    02459 893B      LDD	R19,Y+19
    0245A 938A      ST	-Y,R24
    0245B 940E 280A CALL	lsr32
    0245D 8309      STD	Y+1,R16
(0208) 	 pcmd[2] = (addr>>16);
    0245E 8828      LDD	R2,Y+16
    0245F 8839      LDD	R3,Y+17
    02460 884A      LDD	R4,Y+18
    02461 885B      LDD	R5,Y+19
    02462 0112      MOVW	R2,R4
    02463 2444      CLR	R4
    02464 2455      CLR	R5
    02465 822A      STD	Y+2,R2
(0209) 	 pcmd[3] =(addr>>8);
    02466 E088      LDI	R24,0x8
    02467 E090      LDI	R25,0
    02468 8908      LDD	R16,Y+16
    02469 8919      LDD	R17,Y+17
    0246A 892A      LDD	R18,Y+18
    0246B 893B      LDD	R19,Y+19
    0246C 938A      ST	-Y,R24
    0246D 940E 280A CALL	lsr32
    0246F 830B      STD	Y+3,R16
(0210) 	// pcmd[4] = offset;
(0211) 
(0212) 	 SD_CS_EN();//打开片选 
    02470 98C0      CBI	0x18,0
(0213) 
(0214) 	 do
(0215) 	 {  
(0216) 		  temp=SD_Write_cmd(pcmd); //写入CMD17
    02471 018E      MOVW	R16,R28
    02472 DE4A      RCALL	_SD_Write_cmd
    02473 2EC0      MOV	R12,R16
(0217) 		  time++;
    02474 9563      INC	R22
(0218) 		  if(time==TRY_TIME) 
    02475 3164      CPI	R22,0x14
    02476 F421      BNE	0x247B
(0219) 		  {
(0220) 		   SD_CS_DIS();
    02477 9AC0      SBI	0x18,0
(0221) 		   return(READ_BLOCK_ERROR); //读块失败
    02478 E004      LDI	R16,4
    02479 E010      LDI	R17,0
    0247A C034      RJMP	0x24AF
(0222) 		  }
(0223) 	 }while(temp!=0); 
    0247B 20CC      TST	R12
    0247C F7A1      BNE	0x2471
(0224)    			
(0225) 	 while(SPI_Read()!= 0xfe); //一直读，当读到0xfe时，说明后面的是512字节的数据了
    0247D 940E 24C2 CALL	_SPI_Read
    0247F 3F0E      CPI	R16,0xFE
    02480 F7E1      BNE	0x247D
(0226)  		   	   	
(0227) 	 for(j=0;j<offset;j++)	 //将数据写入到数据缓冲区中
    02481 2744      CLR	R20
    02482 2755      CLR	R21
    02483 C004      RJMP	0x2488
(0228) 	    SPI_Read();
    02484 940E 24C2 CALL	_SPI_Read
    02486 5F4F      SUBI	R20,0xFF
    02487 4F5F      SBCI	R21,0xFF
    02488 154A      CP	R20,R10
    02489 055B      CPC	R21,R11
    0248A F3C8      BCS	0x2484
(0229) 	 for(;j<offset+len;j++)	 
    0248B C00B      RJMP	0x2497
(0230) 		buffer[j]=SPI_Read();
    0248C 940E 24C2 CALL	_SPI_Read
    0248E 2F60      MOV	R22,R16
    0248F 01FA      MOVW	R30,R20
    02490 880C      LDD	R0,Y+20
    02491 881D      LDD	R1,Y+21
    02492 0DE0      ADD	R30,R0
    02493 1DF1      ADC	R31,R1
    02494 8360      ST	Z,R22
    02495 5F4F      SUBI	R20,0xFF
    02496 4F5F      SBCI	R21,0xFF
    02497 0115      MOVW	R2,R10
    02498 0C2E      ADD	R2,R14
    02499 1C3F      ADC	R3,R15
    0249A 1542      CP	R20,R2
    0249B 0553      CPC	R21,R3
    0249C F378      BCS	0x248C
(0231) 	 for(;j<512;j++)	 
    0249D C004      RJMP	0x24A2
(0232) 		SPI_Read();
    0249E 940E 24C2 CALL	_SPI_Read
    024A0 5F4F      SUBI	R20,0xFF
    024A1 4F5F      SBCI	R21,0xFF
    024A2 3040      CPI	R20,0
    024A3 E0E2      LDI	R30,2
    024A4 075E      CPC	R21,R30
    024A5 F3C0      BCS	0x249E
(0233) 
(0234) 	 SPI_Read();//读取两个字节的CRC校验码，不用关心它们
    024A6 940E 24C2 CALL	_SPI_Read
(0235) 	 SPI_Read();
    024A8 940E 24C2 CALL	_SPI_Read
(0236) 
(0237) 	 SD_CS_DIS();  //SD卡关闭片选 
    024AA 9AC0      SBI	0x18,0
(0238) 
(0239) 	 SPI_Read();//按照SD卡的操作时序在这里补8个时钟
    024AB 940E 24C2 CALL	_SPI_Read
(0240) 
(0241) 	 return SD_TURE;
    024AD 2700      CLR	R16
    024AE 2711      CLR	R17
    024AF 9626      ADIW	R28,6
    024B0 940E 2771 CALL	pop_xgsetF0FC
    024B2 9624      ADIW	R28,4
    024B3 9508      RET
FILE: D:\LQD\工程仿真2012_7_5\software\MEGA128\FILERW\software_src\SPI.c
(0001) //*****************************************************************************//
(0002) //*								 
(0003) //*控制芯片：ATmgea128
(0004) //*开发环境：AVR Studio+GCC
(0005) //*隶属模块：SPI接口控制
(0006) //*****************************************************************************//
(0007) #include "SPI.h"
(0008) 
(0009) /******************************************************************
(0010) SPI接口函数初始化
(0011) ******************************************************************/
(0012) void SPI_IO_Init(void)
(0013) {
(0014) 	SPI_PORT |= (1<<SS);////拉高CS
_SPI_IO_Init:
    024B4 9AC0      SBI	0x18,0
(0015) 	SPI_DDR |= (1<<SCLK)|(1<<MOSI)|(1<<SS);////CS,CLK,MOSI设为输出
    024B5 B387      IN	R24,0x17
    024B6 6087      ORI	R24,7
    024B7 BB87      OUT	0x17,R24
(0016) 	SPI_DDR &=~(1<<MISO);//MISO设为输入
    024B8 98BB      CBI	0x17,3
(0017) 	SPI_PORT |= (1<<SCLK);//拉高CLK
    024B9 9AC1      SBI	0x18,1
(0018) 	SPI_High();//SPI高通
    024BA E580      LDI	R24,0x50
    024BB B98D      OUT	0x0D,R24
    024BC 9A70      SBI	0x0E,0
    024BD 9508      RET
(0019) }
(0020) /******************************************************************
(0021) SPI写一个字节
(0022) ******************************************************************/
(0023) void SPI_Write(UINT8 data)
(0024) {
(0025) 	SPDR = data;
_SPI_Write:
  data                 --> R16
    024BE B90F      OUT	0x0F,R16
(0026) 	while ((SPSR&(1<<SPIF))==0);
    024BF 9B77      SBIS	0x0E,7
    024C0 CFFE      RJMP	0x24BF
    024C1 9508      RET
(0027) 	//loop_until_bit_is_set(SPSR,SPIF);
(0028) }
(0029) /******************************************************************
(0030) SPI读一个字节
(0031) ******************************************************************/
(0032) unsigned char SPI_Read(void)
(0033) {
(0034) 	SPDR = 0xFF;//写0xFF启动SPI
_SPI_Read:
    024C2 EF8F      LDI	R24,0xFF
    024C3 B98F      OUT	0x0F,R24
(0035) 	while ((SPSR&(1<<SPIF))==0);
    024C4 9B77      SBIS	0x0E,7
    024C5 CFFE      RJMP	0x24C4
(0036) 	//loop_until_bit_is_set(SPSR,SPIF);//等待SPIF为高电平
(0037) 	return  SPDR;//返回读取值
    024C6 B10F      IN	R16,0x0F
    024C7 9508      RET
FILE: D:\LQD\工程仿真2012_7_5\software\MEGA128\FILERW\software_src\usart.c
(0001) #include "config.h"
(0002) 
(0003) 
(0004) #define fosc 7372800UL //晶振7.3728MHZ
(0005) #define baud 38400  //波特率
(0006) //串口通信初始化  MEGA128
(0007) //UART1 initialize
(0008) // desired baud rate:38400
(0009) // actual baud rate:38400 (0.0%)
(0010) // char size: 8 bit
(0011) // parity: Disabled
(0012) void uart1_init(void)
(0013) {
(0014)  	 UCSR1B = 0x00; //disable while setting baud rate
_uart1_init:
    024C8 2422      CLR	R2
    024C9 9220 009A STS	0x9A,R2
(0015)      UCSR1A = 0x00;
    024CB 9220 009B STS	0x9B,R2
(0016)      UCSR1C = (1<<UCSZ11)|(1<<UCSZ10);//8bit+1bit stop
    024CD E086      LDI	R24,6
    024CE 9380 009D STS	0x9D,R24
(0017)      UBRR1L=(fosc/16/(baud+1))%256;
    024D0 E08B      LDI	R24,0xB
    024D1 9380 0099 STS	0x99,R24
(0018)      UBRR1H=(fosc/16/(baud+1))/256;
    024D3 9220 0098 STS	0x98,R2
(0019)      UCSR1B =(1<<RXEN1)|(1<<TXEN1);//RXCEN TXCEN
    024D5 E188      LDI	R24,0x18
    024D6 9380 009A STS	0x9A,R24
    024D8 9508      RET
_uart1_rx_isr:
  tmp                  --> R16
    024D9 930A      ST	-Y,R16
    024DA B70F      IN	R16,0x3F
    024DB 930A      ST	-Y,R16
(0020) }
(0021) 
(0022) #pragma interrupt_handler uart1_rx_isr:iv_USART1_RXC
(0023) void uart1_rx_isr(void){   
(0024) 	 char tmp;
(0025) 	 tmp=UDR1;
    024DC 9100 009C LDS	R16,0x9C
    024DE 9109      LD	R16,Y+
    024DF BF0F      OUT	0x3F,R16
    024E0 9109      LD	R16,Y+
    024E1 9518      RETI
(0026) }
(0027) 
(0028) void Usart_Transmit(char c)
(0029) {
(0030)  	 while (!(UCSR1A&(1<<UDRE1)));//表明发送器一准备就绪
_Usart_Transmit:
  c                    --> R16
    024E2 9020 009B LDS	R2,0x9B
    024E4 FE25      SBRS	R2,5
    024E5 CFFC      RJMP	_Usart_Transmit
(0031) 	 UDR1=c;
    024E6 9300 009C STS	0x9C,R16
    024E8 9508      RET
_Puts:
  s                    --> R20
    024E9 934A      ST	-Y,R20
    024EA 935A      ST	-Y,R21
    024EB 01A8      MOVW	R20,R16
(0032) }
(0033) 
(0034) //串口输出字符串
(0035) void Puts( unsigned char *s)
(0036) { 
    024EC C00B      RJMP	0x24F8
(0037) 	 while (*s) 
(0038)       { 
(0039) 	  //为数据间的隔断创造一个串口能显示的隔断字符 即'/t'  ->  ' '
(0040) 	  if(*s==0x09)  
    024ED 01FA      MOVW	R30,R20
    024EE 8180      LD	R24,Z
    024EF 3089      CPI	R24,0x9
    024F0 F411      BNE	0x24F3
(0041) 	  {   Usart_Transmit(' ');    }
    024F1 E200      LDI	R16,0x20
    024F2 DFEF      RCALL	_Usart_Transmit
(0042) 	 Usart_Transmit(*s);
    024F3 01FA      MOVW	R30,R20
    024F4 8100      LD	R16,Z
    024F5 DFEC      RCALL	_Usart_Transmit
(0043) 	 s++;
    024F6 5F4F      SUBI	R20,0xFF
    024F7 4F5F      SBCI	R21,0xFF
    024F8 01FA      MOVW	R30,R20
    024F9 8020      LD	R2,Z
    024FA 2022      TST	R2
    024FB F789      BNE	0x24ED
    024FC 9159      LD	R21,Y+
    024FD 9149      LD	R20,Y+
    024FE 9508      RET
_Send_nByte:
  i                    --> R20
  len                  --> R10
  p                    --> R12
    024FF 940E 27A9 CALL	push_xgset303C
    02501 2EA2      MOV	R10,R18
    02502 0168      MOVW	R12,R16
(0044) 	
(0045) 	
(0046)       }
(0047) }
(0048) 
(0049) 
(0050) 
(0051) void Send_nByte(unsigned char *p, unsigned char len)
(0052) { 
(0053)   int i = 0;
(0054)   for(i=0;i<len;i++)
    02503 2744      CLR	R20
    02504 2755      CLR	R21
    02505 C007      RJMP	0x250D
(0055)   {
(0056)    	Usart_Transmit(*(p+i));
    02506 01FA      MOVW	R30,R20
    02507 0DEC      ADD	R30,R12
    02508 1DFD      ADC	R31,R13
    02509 8100      LD	R16,Z
    0250A DFD7      RCALL	_Usart_Transmit
    0250B 5F4F      SUBI	R20,0xFF
    0250C 4F5F      SBCI	R21,0xFF
    0250D 2C2A      MOV	R2,R10
    0250E 2433      CLR	R3
    0250F 1542      CP	R20,R2
    02510 0553      CPC	R21,R3
    02511 F3A4      BLT	0x2506
    02512 940C 27B0 JMP	pop_xgset303C
_PrintString:
  str                  --> R10
    02514 92AA      ST	-Y,R10
    02515 92BA      ST	-Y,R11
    02516 0158      MOVW	R10,R16
(0057)   }
(0058) }
(0059) 
(0060) void  PrintString(const unsigned char *str)
(0061) {    
    02517 C004      RJMP	0x251C
(0062) 	while(*str!=0)	Usart_Transmit(*str++);
    02518 01F5      MOVW	R30,R10
    02519 9101      LD	R16,Z+
    0251A 015F      MOVW	R10,R30
    0251B DFC6      RCALL	_Usart_Transmit
    0251C 01F5      MOVW	R30,R10
    0251D 8020      LD	R2,Z
    0251E 2022      TST	R2
    0251F F7C1      BNE	0x2518
    02520 90B9      LD	R11,Y+
    02521 90A9      LD	R10,Y+
    02522 9508      RET
_PrintString_n:
  str                  --> R10
    02523 92AA      ST	-Y,R10
    02524 92BA      ST	-Y,R11
    02525 0158      MOVW	R10,R16
(0063) }
(0064) void  PrintString_n(const unsigned char *str)
(0065) {   
(0066) 	Usart_Transmit('\r');
    02526 E00D      LDI	R16,0xD
    02527 DFBA      RCALL	_Usart_Transmit
(0067) 	Usart_Transmit('\n'); 
    02528 E00A      LDI	R16,0xA
    02529 DFB8      RCALL	_Usart_Transmit
    0252A C004      RJMP	0x252F
(0068) 	while(*str!=0)	Usart_Transmit(*str++);
    0252B 01F5      MOVW	R30,R10
    0252C 9101      LD	R16,Z+
    0252D 015F      MOVW	R10,R30
    0252E DFB3      RCALL	_Usart_Transmit
    0252F 01F5      MOVW	R30,R10
    02530 8020      LD	R2,Z
    02531 2022      TST	R2
    02532 F7C1      BNE	0x252B
    02533 90B9      LD	R11,Y+
    02534 90A9      LD	R10,Y+
    02535 9508      RET
_PrintLong:
  i                    --> R20
  da                   --> Y,+0
  data                 --> Y,+9
    02536 940E 26A9 CALL	push_arg4
    02538 934A      ST	-Y,R20
    02539 9728      SBIW	R28,0x8
(0069) 
(0070) } 
(0071)  
(0072) void PrintLong(unsigned long data)
(0073) {
(0074)  
(0075) 	unsigned char da[8];
(0076) 	unsigned char i;
(0077) 	for(i=0;i<8;i++)	da[i]=0;
    0253A 2744      CLR	R20
    0253B C008      RJMP	0x2544
    0253C 01CE      MOVW	R24,R28
    0253D 2FE4      MOV	R30,R20
    0253E 27FF      CLR	R31
    0253F 0FE8      ADD	R30,R24
    02540 1FF9      ADC	R31,R25
    02541 2422      CLR	R2
    02542 8220      ST	Z,R2
    02543 9543      INC	R20
    02544 3048      CPI	R20,0x8
    02545 F3B0      BCS	0x253C
    02546 C013      RJMP	0x255A
(0078) 	while(data>=10000000L){ ++da[7];data-=10000000L;}
    02547 818F      LDD	R24,Y+7
    02548 5F8F      SUBI	R24,0xFF
    02549 838F      STD	Y+7,R24
    0254A E880      LDI	R24,0x80
    0254B E996      LDI	R25,0x96
    0254C E9A8      LDI	R26,0x98
    0254D E0B0      LDI	R27,0
    0254E 8429      LDD	R2,Y+9
    0254F 843A      LDD	R3,Y+10
    02550 844B      LDD	R4,Y+11
    02551 845C      LDD	R5,Y+12
    02552 1A28      SUB	R2,R24
    02553 0A39      SBC	R3,R25
    02554 0A4A      SBC	R4,R26
    02555 0A5B      SBC	R5,R27
    02556 8629      STD	Y+9,R2
    02557 863A      STD	Y+10,R3
    02558 864B      STD	Y+11,R4
    02559 865C      STD	Y+12,R5
    0255A E880      LDI	R24,0x80
    0255B E996      LDI	R25,0x96
    0255C E9A8      LDI	R26,0x98
    0255D E0B0      LDI	R27,0
    0255E 8429      LDD	R2,Y+9
    0255F 843A      LDD	R3,Y+10
    02560 844B      LDD	R4,Y+11
    02561 845C      LDD	R5,Y+12
    02562 1628      CP	R2,R24
    02563 0639      CPC	R3,R25
    02564 064A      CPC	R4,R26
    02565 065B      CPC	R5,R27
    02566 F700      BCC	0x2547
(0079) 	if(da[7])	i=0;
    02567 802F      LDD	R2,Y+7
    02568 2022      TST	R2
    02569 F009      BEQ	0x256B
    0256A 2744      CLR	R20
(0080) 	if(i==0)	Usart_Transmit('0'+da[7]);
    0256B 2344      TST	R20
    0256C F4B9      BNE	0x2584
    0256D 810F      LDD	R16,Y+7
    0256E 5D00      SUBI	R16,0xD0
    0256F DF72      RCALL	_Usart_Transmit
    02570 C013      RJMP	0x2584
(0081) 	while(data>=1000000L) { ++da[6];data-=1000000L;}
    02571 818E      LDD	R24,Y+6
    02572 5F8F      SUBI	R24,0xFF
    02573 838E      STD	Y+6,R24
    02574 E480      LDI	R24,0x40
    02575 E492      LDI	R25,0x42
    02576 E0AF      LDI	R26,0xF
    02577 E0B0      LDI	R27,0
    02578 8429      LDD	R2,Y+9
    02579 843A      LDD	R3,Y+10
    0257A 844B      LDD	R4,Y+11
    0257B 845C      LDD	R5,Y+12
    0257C 1A28      SUB	R2,R24
    0257D 0A39      SBC	R3,R25
    0257E 0A4A      SBC	R4,R26
    0257F 0A5B      SBC	R5,R27
    02580 8629      STD	Y+9,R2
    02581 863A      STD	Y+10,R3
    02582 864B      STD	Y+11,R4
    02583 865C      STD	Y+12,R5
    02584 E480      LDI	R24,0x40
    02585 E492      LDI	R25,0x42
    02586 E0AF      LDI	R26,0xF
    02587 E0B0      LDI	R27,0
    02588 8429      LDD	R2,Y+9
    02589 843A      LDD	R3,Y+10
    0258A 844B      LDD	R4,Y+11
    0258B 845C      LDD	R5,Y+12
    0258C 1628      CP	R2,R24
    0258D 0639      CPC	R3,R25
    0258E 064A      CPC	R4,R26
    0258F 065B      CPC	R5,R27
    02590 F700      BCC	0x2571
(0082) 	if(da[6])	i=0;
    02591 802E      LDD	R2,Y+6
    02592 2022      TST	R2
    02593 F009      BEQ	0x2595
    02594 2744      CLR	R20
(0083) 	if(i==0)	Usart_Transmit('0'+da[6]);
    02595 2344      TST	R20
    02596 F4B9      BNE	0x25AE
    02597 810E      LDD	R16,Y+6
    02598 5D00      SUBI	R16,0xD0
    02599 DF48      RCALL	_Usart_Transmit
    0259A C013      RJMP	0x25AE
(0084) 	while(data>=100000L)  { ++da[5];data-=100000L;}
    0259B 818D      LDD	R24,Y+5
    0259C 5F8F      SUBI	R24,0xFF
    0259D 838D      STD	Y+5,R24
    0259E EA80      LDI	R24,0xA0
    0259F E896      LDI	R25,0x86
    025A0 E0A1      LDI	R26,1
    025A1 E0B0      LDI	R27,0
    025A2 8429      LDD	R2,Y+9
    025A3 843A      LDD	R3,Y+10
    025A4 844B      LDD	R4,Y+11
    025A5 845C      LDD	R5,Y+12
    025A6 1A28      SUB	R2,R24
    025A7 0A39      SBC	R3,R25
    025A8 0A4A      SBC	R4,R26
    025A9 0A5B      SBC	R5,R27
    025AA 8629      STD	Y+9,R2
    025AB 863A      STD	Y+10,R3
    025AC 864B      STD	Y+11,R4
    025AD 865C      STD	Y+12,R5
    025AE EA80      LDI	R24,0xA0
    025AF E896      LDI	R25,0x86
    025B0 E0A1      LDI	R26,1
    025B1 E0B0      LDI	R27,0
    025B2 8429      LDD	R2,Y+9
    025B3 843A      LDD	R3,Y+10
    025B4 844B      LDD	R4,Y+11
    025B5 845C      LDD	R5,Y+12
    025B6 1628      CP	R2,R24
    025B7 0639      CPC	R3,R25
    025B8 064A      CPC	R4,R26
    025B9 065B      CPC	R5,R27
    025BA F700      BCC	0x259B
(0085) 	if(da[5])	i=0;
    025BB 802D      LDD	R2,Y+5
    025BC 2022      TST	R2
    025BD F009      BEQ	0x25BF
    025BE 2744      CLR	R20
(0086) 	if(i==0)	Usart_Transmit('0'+da[5]);
    025BF 2344      TST	R20
    025C0 F4B9      BNE	0x25D8
    025C1 810D      LDD	R16,Y+5
    025C2 5D00      SUBI	R16,0xD0
    025C3 DF1E      RCALL	_Usart_Transmit
    025C4 C013      RJMP	0x25D8
(0087) 	while(data>=10000L)   { ++da[4];data-=10000L;}
    025C5 818C      LDD	R24,Y+4
    025C6 5F8F      SUBI	R24,0xFF
    025C7 838C      STD	Y+4,R24
    025C8 E180      LDI	R24,0x10
    025C9 E297      LDI	R25,0x27
    025CA E0A0      LDI	R26,0
    025CB E0B0      LDI	R27,0
    025CC 8429      LDD	R2,Y+9
    025CD 843A      LDD	R3,Y+10
    025CE 844B      LDD	R4,Y+11
    025CF 845C      LDD	R5,Y+12
    025D0 1A28      SUB	R2,R24
    025D1 0A39      SBC	R3,R25
    025D2 0A4A      SBC	R4,R26
    025D3 0A5B      SBC	R5,R27
    025D4 8629      STD	Y+9,R2
    025D5 863A      STD	Y+10,R3
    025D6 864B      STD	Y+11,R4
    025D7 865C      STD	Y+12,R5
    025D8 E180      LDI	R24,0x10
    025D9 E297      LDI	R25,0x27
    025DA E0A0      LDI	R26,0
    025DB E0B0      LDI	R27,0
    025DC 8429      LDD	R2,Y+9
    025DD 843A      LDD	R3,Y+10
    025DE 844B      LDD	R4,Y+11
    025DF 845C      LDD	R5,Y+12
    025E0 1628      CP	R2,R24
    025E1 0639      CPC	R3,R25
    025E2 064A      CPC	R4,R26
    025E3 065B      CPC	R5,R27
    025E4 F700      BCC	0x25C5
(0088) 	if(da[4])	i=0;
    025E5 802C      LDD	R2,Y+4
    025E6 2022      TST	R2
    025E7 F009      BEQ	0x25E9
    025E8 2744      CLR	R20
(0089) 	if(i==0)	Usart_Transmit('0'+da[4]);
    025E9 2344      TST	R20
    025EA F4B9      BNE	0x2602
    025EB 810C      LDD	R16,Y+4
    025EC 5D00      SUBI	R16,0xD0
    025ED DEF4      RCALL	_Usart_Transmit
    025EE C013      RJMP	0x2602
(0090) 	while(data>=1000L)    { ++da[3];data-=1000L;}
    025EF 818B      LDD	R24,Y+3
    025F0 5F8F      SUBI	R24,0xFF
    025F1 838B      STD	Y+3,R24
    025F2 EE88      LDI	R24,0xE8
    025F3 E093      LDI	R25,3
    025F4 E0A0      LDI	R26,0
    025F5 E0B0      LDI	R27,0
    025F6 8429      LDD	R2,Y+9
    025F7 843A      LDD	R3,Y+10
    025F8 844B      LDD	R4,Y+11
    025F9 845C      LDD	R5,Y+12
    025FA 1A28      SUB	R2,R24
    025FB 0A39      SBC	R3,R25
    025FC 0A4A      SBC	R4,R26
    025FD 0A5B      SBC	R5,R27
    025FE 8629      STD	Y+9,R2
    025FF 863A      STD	Y+10,R3
    02600 864B      STD	Y+11,R4
    02601 865C      STD	Y+12,R5
    02602 EE88      LDI	R24,0xE8
    02603 E093      LDI	R25,3
    02604 E0A0      LDI	R26,0
    02605 E0B0      LDI	R27,0
    02606 8429      LDD	R2,Y+9
    02607 843A      LDD	R3,Y+10
    02608 844B      LDD	R4,Y+11
    02609 845C      LDD	R5,Y+12
    0260A 1628      CP	R2,R24
    0260B 0639      CPC	R3,R25
    0260C 064A      CPC	R4,R26
    0260D 065B      CPC	R5,R27
    0260E F700      BCC	0x25EF
(0091) 	if(da[3])	i=0;
    0260F 802B      LDD	R2,Y+3
    02610 2022      TST	R2
    02611 F009      BEQ	0x2613
    02612 2744      CLR	R20
(0092) 	if(i==0)	Usart_Transmit('0'+da[3]);
    02613 2344      TST	R20
    02614 F4B9      BNE	0x262C
    02615 810B      LDD	R16,Y+3
    02616 5D00      SUBI	R16,0xD0
    02617 DECA      RCALL	_Usart_Transmit
    02618 C013      RJMP	0x262C
(0093) 	while(data>=100L)     { ++da[2];data-=100L;}
    02619 818A      LDD	R24,Y+2
    0261A 5F8F      SUBI	R24,0xFF
    0261B 838A      STD	Y+2,R24
    0261C E684      LDI	R24,0x64
    0261D E090      LDI	R25,0
    0261E E0A0      LDI	R26,0
    0261F E0B0      LDI	R27,0
    02620 8429      LDD	R2,Y+9
    02621 843A      LDD	R3,Y+10
    02622 844B      LDD	R4,Y+11
    02623 845C      LDD	R5,Y+12
    02624 1A28      SUB	R2,R24
    02625 0A39      SBC	R3,R25
    02626 0A4A      SBC	R4,R26
    02627 0A5B      SBC	R5,R27
    02628 8629      STD	Y+9,R2
    02629 863A      STD	Y+10,R3
    0262A 864B      STD	Y+11,R4
    0262B 865C      STD	Y+12,R5
    0262C E684      LDI	R24,0x64
    0262D E090      LDI	R25,0
    0262E E0A0      LDI	R26,0
    0262F E0B0      LDI	R27,0
    02630 8429      LDD	R2,Y+9
    02631 843A      LDD	R3,Y+10
    02632 844B      LDD	R4,Y+11
    02633 845C      LDD	R5,Y+12
    02634 1628      CP	R2,R24
    02635 0639      CPC	R3,R25
    02636 064A      CPC	R4,R26
    02637 065B      CPC	R5,R27
    02638 F700      BCC	0x2619
(0094) 	if(da[2])	i=0;
    02639 802A      LDD	R2,Y+2
    0263A 2022      TST	R2
    0263B F009      BEQ	0x263D
    0263C 2744      CLR	R20
(0095) 	if(i==0)	Usart_Transmit('0'+da[2]);
    0263D 2344      TST	R20
    0263E F4B9      BNE	0x2656
    0263F 810A      LDD	R16,Y+2
    02640 5D00      SUBI	R16,0xD0
    02641 DEA0      RCALL	_Usart_Transmit
    02642 C013      RJMP	0x2656
(0096) 	while(data>=10L)      { ++da[1];data-=10L;}
    02643 8189      LDD	R24,Y+1
    02644 5F8F      SUBI	R24,0xFF
    02645 8389      STD	Y+1,R24
    02646 E08A      LDI	R24,0xA
    02647 E090      LDI	R25,0
    02648 E0A0      LDI	R26,0
    02649 E0B0      LDI	R27,0
    0264A 8429      LDD	R2,Y+9
    0264B 843A      LDD	R3,Y+10
    0264C 844B      LDD	R4,Y+11
    0264D 845C      LDD	R5,Y+12
    0264E 1A28      SUB	R2,R24
    0264F 0A39      SBC	R3,R25
    02650 0A4A      SBC	R4,R26
    02651 0A5B      SBC	R5,R27
    02652 8629      STD	Y+9,R2
    02653 863A      STD	Y+10,R3
    02654 864B      STD	Y+11,R4
    02655 865C      STD	Y+12,R5
    02656 E08A      LDI	R24,0xA
    02657 E090      LDI	R25,0
    02658 E0A0      LDI	R26,0
    02659 E0B0      LDI	R27,0
    0265A 8429      LDD	R2,Y+9
    0265B 843A      LDD	R3,Y+10
    0265C 844B      LDD	R4,Y+11
    0265D 845C      LDD	R5,Y+12
    0265E 1628      CP	R2,R24
    0265F 0639      CPC	R3,R25
    02660 064A      CPC	R4,R26
    02661 065B      CPC	R5,R27
    02662 F700      BCC	0x2643
(0097) 	if(da[1])	i=0;
    02663 8029      LDD	R2,Y+1
    02664 2022      TST	R2
    02665 F009      BEQ	0x2667
    02666 2744      CLR	R20
(0098) 	if(i==0)	Usart_Transmit('0'+da[1]);
    02667 2344      TST	R20
    02668 F419      BNE	0x266C
    02669 8109      LDD	R16,Y+1
    0266A 5D00      SUBI	R16,0xD0
    0266B DE76      RCALL	_Usart_Transmit
(0099) 	Usart_Transmit('0'+data);
    0266C E380      LDI	R24,0x30
    0266D E090      LDI	R25,0
    0266E E0A0      LDI	R26,0
    0266F E0B0      LDI	R27,0
    02670 8429      LDD	R2,Y+9
    02671 843A      LDD	R3,Y+10
    02672 844B      LDD	R4,Y+11
    02673 845C      LDD	R5,Y+12
    02674 0E28      ADD	R2,R24
    02675 1E39      ADC	R3,R25
    02676 1E4A      ADC	R4,R26
    02677 1E5B      ADC	R5,R27
    02678 2D02      MOV	R16,R2
    02679 DE68      RCALL	_Usart_Transmit
    0267A 9628      ADIW	R28,0x8
    0267B 9149      LD	R20,Y+
    0267C 9624      ADIW	R28,4
    0267D 9508      RET
_PrintChar:
  h                    --> R20
  d                    --> R22
    0267E 934A      ST	-Y,R20
    0267F 936A      ST	-Y,R22
    02680 2F60      MOV	R22,R16
(0100)  
(0101) }
(0102)  
(0103) void PrintChar(unsigned char d)
(0104) {
(0105) 	unsigned char h=(d&0xF0)>>4;
    02681 2F46      MOV	R20,R22
    02682 7F40      ANDI	R20,0xF0
    02683 9542      SWAP	R20
    02684 704F      ANDI	R20,0xF
(0106) 	if(h<10)	Usart_Transmit('0'+h);
    02685 304A      CPI	R20,0xA
    02686 F420      BCC	0x268B
    02687 2F04      MOV	R16,R20
    02688 5D00      SUBI	R16,0xD0
    02689 DE58      RCALL	_Usart_Transmit
    0268A C003      RJMP	0x268E
(0107) 	else		Usart_Transmit('A'-10+h);
    0268B 2F04      MOV	R16,R20
    0268C 5C09      SUBI	R16,0xC9
    0268D DE54      RCALL	_Usart_Transmit
(0108) 	h=d&0x0f;
    0268E 2F46      MOV	R20,R22
    0268F 704F      ANDI	R20,0xF
(0109) 	if(h<10)	Usart_Transmit('0'+h);
    02690 304A      CPI	R20,0xA
    02691 F420      BCC	0x2696
    02692 2F04      MOV	R16,R20
    02693 5D00      SUBI	R16,0xD0
    02694 DE4D      RCALL	_Usart_Transmit
    02695 C003      RJMP	0x2699
(0110) 	else		Usart_Transmit('A'-10+h);
    02696 2F04      MOV	R16,R20
    02697 5C09      SUBI	R16,0xC9
    02698 DE49      RCALL	_Usart_Transmit
(0111) 	Usart_Transmit(' ');
FILE: <library>
    02699 E200      LDI	R16,0x20
    0269A DE47      RCALL	_Usart_Transmit
    0269B 9169      LD	R22,Y+
    0269C 9149      LD	R20,Y+
    0269D 9508      RET
_memset:
    0269E 8188      LD	R24,Y
    0269F 8199      LDD	R25,Y+1
    026A0 3080      CPI	R24,0
    026A1 0789      CPC	R24,R25
    026A2 F029      BEQ	0x26A8
    026A3 2FE0      MOV	R30,R16
    026A4 2FF1      MOV	R31,R17
    026A5 9321      ST	Z+,R18
    026A6 9701      SBIW	R24,1
    026A7 F7E9      BNE	0x26A5
    026A8 9508      RET
push_arg4:
    026A9 933A      ST	-Y,R19
    026AA 932A      ST	-Y,R18
push_arg2:
    026AB 931A      ST	-Y,R17
    026AC 930A      ST	-Y,R16
    026AD 9508      RET
div32u:
    026AE 94E8      BCLR	6
    026AF C001      RJMP	0x26B1
mod32u:
    026B0 9468      BSET	6
    026B1 D030      RCALL	long_div_prolog
    026B2 24CC      CLR	R12
    026B3 C009      RJMP	0x26BD
div32s:
    026B4 94E8      BCLR	6
    026B5 C001      RJMP	0x26B7
mod32s:
    026B6 9468      BSET	6
    026B7 D02A      RCALL	long_div_prolog
    026B8 FD37      SBRC	R19,7
    026B9 940E 27C9 CALL	neg32
    026BB FDB7      SBRC	R27,7
    026BC D052      RCALL	neg_R24_R27
    026BD 2477      CLR	R7
    026BE 2488      CLR	R8
    026BF 2499      CLR	R9
    026C0 24AA      CLR	R10
    026C1 24BB      CLR	R11
    026C2 D042      RCALL	tst_R16_R19
    026C3 F0C1      BEQ	0x26DC
    026C4 D045      RCALL	tst_R24_R27
    026C5 F0B1      BEQ	0x26DC
    026C6 E2E8      LDI	R30,0x28
    026C7 0F00      LSL	R16
    026C8 1F11      ROL	R17
    026C9 1F22      ROL	R18
    026CA 1F33      ROL	R19
    026CB 1C77      ROL	R7
    026CC 1C88      ROL	R8
    026CD 1C99      ROL	R9
    026CE 1CAA      ROL	R10
    026CF 1CBB      ROL	R11
    026D0 1688      CP	R8,R24
    026D1 0699      CPC	R9,R25
    026D2 06AA      CPC	R10,R26
    026D3 06BB      CPC	R11,R27
    026D4 F028      BCS	0x26DA
    026D5 1A88      SUB	R8,R24
    026D6 0A99      SBC	R9,R25
    026D7 0AAA      SBC	R10,R26
    026D8 0ABB      SBC	R11,R27
    026D9 9503      INC	R16
    026DA 95EA      DEC	R30
    026DB F759      BNE	0x26C7
    026DC F426      BRTC	0x26E1
    026DD 2D08      MOV	R16,R8
    026DE 2D19      MOV	R17,R9
    026DF 2D2A      MOV	R18,R10
    026E0 2D3B      MOV	R19,R11
    026E1 C013      RJMP	long_div_epilog
long_div_prolog:
    026E2 927A      ST	-Y,R7
    026E3 928A      ST	-Y,R8
    026E4 929A      ST	-Y,R9
    026E5 92AA      ST	-Y,R10
    026E6 92BA      ST	-Y,R11
    026E7 92CA      ST	-Y,R12
    026E8 93EA      ST	-Y,R30
    026E9 938A      ST	-Y,R24
    026EA 939A      ST	-Y,R25
    026EB 93AA      ST	-Y,R26
    026EC 93BA      ST	-Y,R27
    026ED 858B      LDD	R24,Y+11
    026EE 859C      LDD	R25,Y+12
    026EF 85AD      LDD	R26,Y+13
    026F0 85BE      LDD	R27,Y+14
    026F1 2EC3      MOV	R12,R19
    026F2 F00E      BRTS	0x26F4
    026F3 26CB      EOR	R12,R27
    026F4 9508      RET
long_div_epilog:
    026F5 FCC7      SBRC	R12,7
    026F6 940E 27C9 CALL	neg32
    026F8 91B9      LD	R27,Y+
    026F9 91A9      LD	R26,Y+
    026FA 9199      LD	R25,Y+
    026FB 9189      LD	R24,Y+
    026FC 91E9      LD	R30,Y+
    026FD 90C9      LD	R12,Y+
    026FE 90B9      LD	R11,Y+
    026FF 90A9      LD	R10,Y+
    02700 9099      LD	R9,Y+
    02701 9089      LD	R8,Y+
    02702 9079      LD	R7,Y+
    02703 9624      ADIW	R28,4
    02704 9508      RET
tst_R16_R19:
    02705 2FE0      MOV	R30,R16
    02706 2BE1      OR	R30,R17
    02707 2BE2      OR	R30,R18
    02708 2BE3      OR	R30,R19
    02709 9508      RET
tst_R24_R27:
    0270A 2FE8      MOV	R30,R24
    0270B 2BE9      OR	R30,R25
    0270C 2BEA      OR	R30,R26
    0270D 2BEB      OR	R30,R27
    0270E 9508      RET
neg_R24_R27:
    0270F 9580      COM	R24
    02710 9590      COM	R25
    02711 95A0      COM	R26
    02712 95B0      COM	R27
    02713 5F8F      SUBI	R24,0xFF
    02714 4F9F      SBCI	R25,0xFF
    02715 4FAF      SBCI	R26,0xFF
    02716 4FBF      SBCI	R27,0xFF
    02717 9508      RET
empy16s:
    02718 920A      ST	-Y,R0
    02719 921A      ST	-Y,R1
    0271A 938A      ST	-Y,R24
    0271B 939A      ST	-Y,R25
    0271C 9F02      MUL	R16,R18
    0271D 01C0      MOVW	R24,R0
    0271E 9F12      MUL	R17,R18
    0271F 0D90      ADD	R25,R0
    02720 9F03      MUL	R16,R19
    02721 0D90      ADD	R25,R0
    02722 018C      MOVW	R16,R24
    02723 9199      LD	R25,Y+
    02724 9189      LD	R24,Y+
    02725 9019      LD	R1,Y+
    02726 9009      LD	R0,Y+
    02727 9508      RET
empy32s|empy32u:
    02728 940E 27D2 CALL	long_prolog
    0272A 927A      ST	-Y,R7
    0272B 940E 27EB CALL	tstzero1
    0272D F159      BEQ	0x2759
    0272E 2477      CLR	R7
    0272F 940E 27F1 CALL	tstzero2
    02731 F419      BNE	0x2735
    02732 018C      MOVW	R16,R24
    02733 019D      MOVW	R18,R26
    02734 C024      RJMP	0x2759
    02735 920A      ST	-Y,R0
    02736 921A      ST	-Y,R1
    02737 9F08      MUL	R16,R24
    02738 2CB0      MOV	R11,R0
    02739 2CA1      MOV	R10,R1
    0273A 9F28      MUL	R18,R24
    0273B 2C90      MOV	R9,R0
    0273C 2C81      MOV	R8,R1
    0273D 9F18      MUL	R17,R24
    0273E 0CA0      ADD	R10,R0
    0273F 1C91      ADC	R9,R1
    02740 1C87      ADC	R8,R7
    02741 9F09      MUL	R16,R25
    02742 0CA0      ADD	R10,R0
    02743 1C91      ADC	R9,R1
    02744 1C87      ADC	R8,R7
    02745 9F19      MUL	R17,R25
    02746 0C90      ADD	R9,R0
    02747 1C81      ADC	R8,R1
    02748 9F0A      MUL	R16,R26
    02749 0C90      ADD	R9,R0
    0274A 1C81      ADC	R8,R1
    0274B 9F38      MUL	R19,R24
    0274C 0C80      ADD	R8,R0
    0274D 9F29      MUL	R18,R25
    0274E 0C80      ADD	R8,R0
    0274F 9F1A      MUL	R17,R26
    02750 0C80      ADD	R8,R0
    02751 9F0B      MUL	R16,R27
    02752 0C80      ADD	R8,R0
    02753 9019      LD	R1,Y+
    02754 9009      LD	R0,Y+
    02755 2D0B      MOV	R16,R11
    02756 2D1A      MOV	R17,R10
    02757 2D29      MOV	R18,R9
    02758 2D38      MOV	R19,R8
    02759 9079      LD	R7,Y+
    0275A 940C 27E0 JMP	long_epilog
pop_xgset003C:
    0275C 90A9      LD	R10,Y+
    0275D 90B9      LD	R11,Y+
    0275E 90C9      LD	R12,Y+
    0275F 90D9      LD	R13,Y+
    02760 9508      RET
pop_xgset00FC:
    02761 90A9      LD	R10,Y+
    02762 90B9      LD	R11,Y+
    02763 90C9      LD	R12,Y+
    02764 90D9      LD	R13,Y+
    02765 90E9      LD	R14,Y+
    02766 90F9      LD	R15,Y+
    02767 9508      RET
pop_xgset30FC:
    02768 90A9      LD	R10,Y+
    02769 90B9      LD	R11,Y+
    0276A 90C9      LD	R12,Y+
    0276B 90D9      LD	R13,Y+
    0276C 90E9      LD	R14,Y+
    0276D 90F9      LD	R15,Y+
    0276E 9149      LD	R20,Y+
    0276F 9159      LD	R21,Y+
    02770 9508      RET
pop_xgsetF0FC:
    02771 90A9      LD	R10,Y+
    02772 90B9      LD	R11,Y+
    02773 90C9      LD	R12,Y+
    02774 90D9      LD	R13,Y+
    02775 90E9      LD	R14,Y+
    02776 90F9      LD	R15,Y+
    02777 9149      LD	R20,Y+
    02778 9159      LD	R21,Y+
    02779 9169      LD	R22,Y+
    0277A 9179      LD	R23,Y+
    0277B 9508      RET
push_xgsetF0FC:
    0277C 937A      ST	-Y,R23
    0277D 936A      ST	-Y,R22
push_xgset30FC:
    0277E 935A      ST	-Y,R21
    0277F 934A      ST	-Y,R20
push_xgset00FC:
    02780 92FA      ST	-Y,R15
    02781 92EA      ST	-Y,R14
push_xgset003C:
    02782 92DA      ST	-Y,R13
    02783 92CA      ST	-Y,R12
    02784 92BA      ST	-Y,R11
    02785 92AA      ST	-Y,R10
    02786 9508      RET
push_xgset300C:
    02787 935A      ST	-Y,R21
    02788 934A      ST	-Y,R20
    02789 92BA      ST	-Y,R11
    0278A 92AA      ST	-Y,R10
    0278B 9508      RET
pop_xgset300C:
    0278C 90A9      LD	R10,Y+
    0278D 90B9      LD	R11,Y+
    0278E 9149      LD	R20,Y+
    0278F 9159      LD	R21,Y+
    02790 9508      RET
push_xgsetF000:
    02791 937A      ST	-Y,R23
    02792 936A      ST	-Y,R22
    02793 935A      ST	-Y,R21
    02794 934A      ST	-Y,R20
    02795 9508      RET
pop_xgsetF000:
    02796 9149      LD	R20,Y+
    02797 9159      LD	R21,Y+
    02798 9169      LD	R22,Y+
    02799 9179      LD	R23,Y+
    0279A 9508      RET
push_xgsetF00C:
    0279B 937A      ST	-Y,R23
    0279C 936A      ST	-Y,R22
    0279D 935A      ST	-Y,R21
    0279E 934A      ST	-Y,R20
    0279F 92BA      ST	-Y,R11
    027A0 92AA      ST	-Y,R10
    027A1 9508      RET
pop_xgsetF00C:
    027A2 90A9      LD	R10,Y+
    027A3 90B9      LD	R11,Y+
    027A4 9149      LD	R20,Y+
    027A5 9159      LD	R21,Y+
    027A6 9169      LD	R22,Y+
    027A7 9179      LD	R23,Y+
    027A8 9508      RET
push_xgset303C:
    027A9 935A      ST	-Y,R21
    027AA 934A      ST	-Y,R20
    027AB 92DA      ST	-Y,R13
    027AC 92CA      ST	-Y,R12
    027AD 92BA      ST	-Y,R11
    027AE 92AA      ST	-Y,R10
    027AF 9508      RET
pop_xgset303C:
    027B0 90A9      LD	R10,Y+
    027B1 90B9      LD	R11,Y+
    027B2 90C9      LD	R12,Y+
    027B3 90D9      LD	R13,Y+
    027B4 9149      LD	R20,Y+
    027B5 9159      LD	R21,Y+
    027B6 9508      RET
push_xgsetF03C:
    027B7 937A      ST	-Y,R23
    027B8 936A      ST	-Y,R22
    027B9 935A      ST	-Y,R21
    027BA 934A      ST	-Y,R20
    027BB 92DA      ST	-Y,R13
    027BC 92CA      ST	-Y,R12
    027BD 92BA      ST	-Y,R11
    027BE 92AA      ST	-Y,R10
    027BF 9508      RET
pop_xgsetF03C:
    027C0 90A9      LD	R10,Y+
    027C1 90B9      LD	R11,Y+
    027C2 90C9      LD	R12,Y+
    027C3 90D9      LD	R13,Y+
    027C4 9149      LD	R20,Y+
    027C5 9159      LD	R21,Y+
    027C6 9169      LD	R22,Y+
    027C7 9179      LD	R23,Y+
    027C8 9508      RET
neg32:
    027C9 9500      COM	R16
    027CA 9510      COM	R17
    027CB 9520      COM	R18
    027CC 9530      COM	R19
    027CD 5F0F      SUBI	R16,0xFF
    027CE 4F1F      SBCI	R17,0xFF
    027CF 4F2F      SBCI	R18,0xFF
    027D0 4F3F      SBCI	R19,0xFF
    027D1 9508      RET
long_prolog:
    027D2 928A      ST	-Y,R8
    027D3 929A      ST	-Y,R9
    027D4 92AA      ST	-Y,R10
    027D5 92BA      ST	-Y,R11
    027D6 93EA      ST	-Y,R30
    027D7 938A      ST	-Y,R24
    027D8 939A      ST	-Y,R25
    027D9 93AA      ST	-Y,R26
    027DA 93BA      ST	-Y,R27
    027DB 8589      LDD	R24,Y+9
    027DC 859A      LDD	R25,Y+10
    027DD 85AB      LDD	R26,Y+11
    027DE 85BC      LDD	R27,Y+12
    027DF 9508      RET
long_epilog:
    027E0 91B9      LD	R27,Y+
    027E1 91A9      LD	R26,Y+
    027E2 9199      LD	R25,Y+
    027E3 9189      LD	R24,Y+
    027E4 91E9      LD	R30,Y+
    027E5 90B9      LD	R11,Y+
    027E6 90A9      LD	R10,Y+
    027E7 9099      LD	R9,Y+
    027E8 9089      LD	R8,Y+
    027E9 9624      ADIW	R28,4
    027EA 9508      RET
tstzero1:
    027EB 27EE      CLR	R30
    027EC 2BE0      OR	R30,R16
    027ED 2BE1      OR	R30,R17
    027EE 2BE2      OR	R30,R18
    027EF 2BE3      OR	R30,R19
    027F0 9508      RET
tstzero2:
    027F1 27EE      CLR	R30
    027F2 2BE8      OR	R30,R24
    027F3 2BE9      OR	R30,R25
    027F4 2BEA      OR	R30,R26
    027F5 2BEB      OR	R30,R27
    027F6 9508      RET
lsl32:
    027F7 920F      PUSH	R0
    027F8 9009      LD	R0,Y+
    027F9 2000      TST	R0
    027FA F031      BEQ	0x2801
    027FB 0F00      LSL	R16
    027FC 1F11      ROL	R17
    027FD 1F22      ROL	R18
    027FE 1F33      ROL	R19
    027FF 940A      DEC	R0
    02800 CFF8      RJMP	0x27F9
    02801 900F      POP	R0
    02802 9508      RET
lsr16:
    02803 2322      TST	R18
    02804 F021      BEQ	0x2809
    02805 9516      LSR	R17
    02806 9507      ROR	R16
    02807 952A      DEC	R18
    02808 CFFA      RJMP	lsr16
    02809 9508      RET
lsr32:
    0280A 920F      PUSH	R0
    0280B 9009      LD	R0,Y+
    0280C 2000      TST	R0
    0280D F031      BEQ	0x2814
    0280E 9536      LSR	R19
    0280F 9527      ROR	R18
    02810 9517      ROR	R17
    02811 9507      ROR	R16
    02812 940A      DEC	R0
    02813 CFF8      RJMP	0x280C
    02814 900F      POP	R0
    02815 9508      RET
asgnblk:
    02816 93AA      ST	-Y,R26
    02817 93BA      ST	-Y,R27
    02818 93EA      ST	-Y,R30
    02819 93FA      ST	-Y,R31
    0281A 920A      ST	-Y,R0
    0281B 81AF      LDD	R26,Y+7
    0281C 85B8      LDD	R27,Y+8
    0281D 81ED      LDD	R30,Y+5
    0281E 81FE      LDD	R31,Y+6
    0281F 3000      CPI	R16,0
    02820 0701      CPC	R16,R17
    02821 F029      BEQ	0x2827
    02822 9001      LD	R0,Z+
    02823 920D      ST	X+,R0
    02824 5001      SUBI	R16,1
    02825 4010      SBCI	R17,0
    02826 CFF8      RJMP	0x281F
    02827 9009      LD	R0,Y+
    02828 91F9      LD	R31,Y+
    02829 91E9      LD	R30,Y+
    0282A 91B9      LD	R27,Y+
    0282B 91A9      LD	R26,Y+
    0282C 9624      ADIW	R28,4
    0282D 9508      RET
